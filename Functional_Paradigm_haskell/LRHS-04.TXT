    2ЛАБОРАТОРНАЯ РАБОТА 4.
    2СПИСКИ. ФУНКЦИИ ОБРАБОТКИ СПИСКОВ ИЗ БИБЛИОТЕКИ Prelude

 ш1.0
                  1- А это кто 0?
                  1- Он со мной, ответила Лошадь.
                  1- Со слоном нельзя, - сказал контролёр.
                  1- А с лошадьми можно 0? 1 - спросил Слон.
                  1- С лошадьми можно, - ответил контролёр.
                  1- Она со мной, - сказал Слон и прошёл на ипподром.
                                              1В.Левин. Слон и лошадь
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - понятия:  " 1список над элементами типа A 0", " 1уровень вложенности
 1списочной структуры 0";
   - конструкторы типа данных " 1список 0";
   - операции над списками;
   - функции обработки списков;
   - кортежи (тьюплы), функции обработки кортежей;
   - способ конструирования списков с помощью  1определителя списков 0;
   - понятия: " 1списочная нотация 0", " 1графическая нотация 0";
   - правило перевода точечной записи в списочную.

    _ 1Уметь . 0:
   - задавать списки в списочной и точечной нотациях;
   - изображать списки в графической нотации;
   - осуществлять перевод списочной записи списка в точечную и нао-
борот;
   - осуществлять запись структуры с данным графическим представле-
нием в списочной и точечной нотациях;
   - осуществлять композицию функций для решения задач по обработке
списков;
   - конструировать список с помощью определителя списка.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                         3Тип данных 0  3"список"
   Пусть A - конечное множество элементов  1одинакового 0  1типа 0.
    2Определение 0 ( 1индуктивное 0) [Душкин,2007,с.102,103-104].
 ш1.1
    _ 1Список над элементами типа . A 0 (обозначается  1List(A) 0) определяется
так:
 ш1.0

   (1) [] 7е 1List 0(A);

   (2) x 7е 0A & y 7е 1List 0(A) => (x:y) 7е 1List 0(A).

 ш1.2
   Пусть {a 41 0,a 42 0,...,a 4n 0} - множество элементов одного типа A.
   Другими словами,  _ 1список над элементами типа . A 0 - это пара, первый
элемент которой является атомарным значением, а второй - 1 списком 0:
 ш1.0

    2( 0a 41 2: 0(a 42 2: 0(... 2: 0(a 4n 2: 0[])...)) 2)

 ш1.2
   Самым простым  способом конструирования списка является  _ 1перечис-
 _ 1ление элементов списка . 0:  элементы заключают в квадратные  скобки  и
разделяют запятыми. Элементами списка могут быть как константы, так
и выражения, например:
 ш1.0

   (1) x = 10                       (2) p = True; q = False; a = 3
       y:: [Int]                        z:: [Bool]
       y = [1+2,3*x,length [1,2]]       z = [3<4,a==5,p && q]

 ш1.2
   Ограничений на длину списка нет,  он может содержать,  например,
один элемент (такой список называется  _ 1синглетоном . 0).
   Например, список [[1,2,3]] является синглетоном,  т.к. он содер-
жит один элемент, являющийся списком.
                      3Конструкторы типа данных
                              3"список"
    21. 0  _ 1Пустой список . 0  (список,  не  содержащий  элементов),  который
предназначен для конструирования самого себя:
 ш1.0

    2[] 0 ( 1квадратные скобки 0).

 ш1.2
    22. 0 Конструктор создания списка из  _ 1элемента . 0 и  _ 1списка . 0:
 ш1.0

    2: 0 ( 1двоеточие 0).

 ш1.2
   Приведём часто используемую операцию  (которая,  конечно,  конс-
труктором не является) создания списка из  _ 1пары списков . 0:
 ш1.0

   ( 2++ 0) (читается " 1плюс-плюс 0").

 ш1.2
   Операция помещает элемент в начало списка, результатом её приме-
нения является список большей длины:
 ш1.0

   (:):: a -> [a] -> [a].

 ш1.2
    2Примеры 0.
 ш1.0

    21. 0 1:2:[] ++ [2,3] ++ [4] => [1,2,2,3,4].

    22. 0 1:2:3:[]               => [1,2,3].

 ш1.2
   Итак, список можно  _ 1конструировать с помощью операции . 0 (:).
    3Замечание 0.
 ш1.1
   В языке программирования LISP аналогом:
   (1) конструктора [] является атом NIL или () ( 1круглые скобки 0);
   (2) конструктора (:) является функция CONS и операция  2. 0 ( 1точка 0).
   (3) функции (++) является функция APPEND.

 ш1.2
                     3Уровень вложенности списка
   Элементами списка могут быть как атомы, так и другие списки.
    2Определение 0 (по [Душкин,2007,с.104]).
 ш1.1
    _ 1Уровнем вложенности списка . 0  называется  максимальное  количество
открывающих скобок "[", которые предваряют собой какой-либо элемент
списка (однако в это количество не входят те скобки, которые закры-
ваются до этого элемента).

 ш1.2
    2Примеры 0 ( 1конструирования списков по определению 0).
 ш1.1

    21. 0 []                 => []            (уровень вложенности: 1)
    22. 0 2:[]               => [2]           (уровень вложенности: 1)
    23. 0 0:(5:(7:(9:[])))   => [0,5,7,9]     (уровень вложенности: 1)
    24. 0 0:5:7:9:[]         => [0,5,7,9]     (уровень вложенности: 1)
    25. 0 'a':'b':'x':[]     => "abx"         (уровень вложенности: 1)
    26. 0 'a':'b':'x':[]     => ['a','b','x'] (уровень вложенности: 1)
    27. 0 (1:[]):[]:[]       => [[1],[]]      (уровень вложенности: 2)
    28. 0 ((1:[]):[]):[]     => [[[1]]]       (уровень вложенности: 3)

 ш1.2
                        3Списочная и точечная
                               3нотация
    _ 1Списочной нотацией . 0 назовём способ записи списков,  не содержащий
символа ":" и наиболее приближённый к математической записи.
    2Определение 0 ( 1индуктивное 0).
 ш1.1
    _ 1Список в списочной нотации . 0 - это:
   (1) [] - пустой список;
   (2) заключённая  в квадратные скобки последовательность однотип-
ных элементов (атомов или списков), разделённых  1запятой 0.

 ш1.2
    2Примеры 0 ( 1списочной нотации 0).
 ш1.0

    21. 0 []              23. 0 [[1],[2,3],[9],[8,7,6,5]]

    22. 0 [1,2,3,4,5]     24. 0 [[[[3]]],[[[7,6,5,4]]]]

 ш1.2
    _ 1Правила перевода списочной записи в точечную запись . 0:
 ш1.0

   (1) [] <=> [],

т.е. запись пустого списка [] остаётся без изменений;

   (2) [a 41 0,a 42 0,...,a 4n 0] <=> (a 41 0:(a 42 0:...:(a 4n 0:[]))).

 ш1.2
    2Пример 0 ( 1перевода списочной нотации в точечную 0).
 ш1.0

   [[1,2],[3]] ─ 76 0 [1,2]:[[3]] ─ 76 0 (1:[2]):([3]:[]) ─ 76

               ─ 76 0 (1:2:[]):((3:[]):[]).

 ш1.2
    _ 1Правило перевода точечной записи в списочную . 0.
 ш1.1
   Из списка выделяется  1пара
 ш1.0

    1Элемент 0 : 1 Список 0,

 ш1.1
у которой второй элемент является списком.
   Выделенная пара преобразуется в список путём добавления элемента
" 1Элемент 0" в " 1Список 0".
   Если " 1Список 0" не является пустым списком, то добавляемый элемент
отделяется запятой от остальных элементов списочной структуры.

 ш1.2
    2Примеры 0 ( 1перевода точечной нотации в списочную 0).
 ш1.0

    21. 0  2( _ 0(1:[]) 2: 0[] . 2) 0 ─ 76 0 [ _[1] 2: 0[] .] ─ 76 0 [[1]].

    22. 0 ((1: 2( _ 02 2: 0[] . 2) 0): 2( 0( _3:[]) 2: 0[] . 2) 0) ─ 76 0 ( 2( _ 01:[2] . 2) 0: 2[ _ 03:[] . 2] 0) ─ 76

                               ─ 76 0  2( _ 0[1,2]:[[3]] . 2) 0 ─ 76 0 [[1,2],[3]].

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Если необходимо вывести на экран пустой список (т.е. []), вообще
не используя функций для работы со списками, то:
   (1) либо явно укажите тип элементов пустого списка:
 ш1.0

   main > [] :: [Int]
   [] :: [Int]

 ш1.1
   (2) либо воспользуйтесь интерпретатором ghci.
 ш1.0

   main > []
   []

 ш1.2
                  3Конструирование 0  3конечных списков
                      3с помощью 0  3двух точек ".."
   В языке Haskell существует  1синтаксический сахар 0,  который позво-
ляет записывать списки сокращённо с помощью двух точек "..".
    2Определение 0 ( 1П.Ландин 0).
 ш1.1
    _ 1Синтаксическим сахаром . 0  называют  способ  записи  синтаксических
конструкций языка  программирования,  который  представляют   собой
удобное альтернативное  ("поверхностное")  представление синтаксиса
языка.
   Другими словами,  _ 1синтаксический сахар . 0 - это маленькие особеннос-
ти, нарушающие основные правила языка, чтобы сделать его более дру-
жественным по отношению к программисту.
   По словам А.Перлиса,  "синтаксический сахар вызывает рак точки с
запятой".

 ш1.2
   Комбинация символов ".." является  зарезервированной  последова-
тельностью символов языка Haskell и используется следующим образом:
при задании  1конечного списка 0 указывается первый и последний элемент
одного и того же типа данных, т.е. [a..z].
   При задании  конечного списка,  моделирующего  _ 1конечную арифмети-
 _ 1ческую прогрессию . 0 (подобные списки иногда называются  1арифметически-
 1ми последовательностями 0),  разность прогрессии определяется при по-
мощи указания первого и второго элементов последовательности:
 ш1.0

   [a,b..z].

 ш1.2
   При отсутствии указания второго элемента последовательности раз-
ность задаваемой арифметической последовательности равна 1.
    2Примеры 0 ( 1задания конечных списков 0).
 ш1.1
    21. 0 [1..100]   - список натуральных чисел от 1 до 100.
    22. 0 [2,4..100] - список чётных натуральных чисел от 1 до 100.
    23. 0 [2.6..6.0] - список чисел [2.6, 3.6, 4.6, 5.6].

 ш1.2
    1Указание числовых интервалов 0 позволяет  задавать  только  список
чисел,  поэтому  в  языке  Haskell существует возможность создавать
списки, моделирующие  1конечные математические последовательности 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    3Замечание 0 ( 1для знатоков 0).
 ш1.1
   Выражение [x..y] вычисляется с помощью вызова функции
 ш1.0

   enumFromTo:: Int -> Int -> [Int]
   enumFromTo x y | y<x  = []
                  | True = x : enumFromTo (x+1) y
 ш1.2

                        3Операции над списками

 ш1.0
                         1Это ещё не конец. Это даже не начало конца.
                         1Но это, возможно, конец начала. 0
                                                          1У.Черчилль
 ш1.2

   Приведём операции  стандартного  модуля  Prelude  для  обработки
списков с указанием их  1приоритета 0 и  1ассоциативности 0.
 ш1.0

   ┌────────┬──────────────────────┬───────────────┬─────────┐
   │  3Символ  0│        3Значение 0       │ 3Ассоциативность 0│ 3Приоритет 0│
   ╞════════╪══════════════════════╪═══════════════╪═════════╡
   │    2!! 0   │ Элемент списка по    │     Левая     │    9    │
   │        │ индексу              │               │         │
   ├--------┴----------------------┴---------------┴---------┤
   │           3Тип 0: [a] -> Int -> a                           │
   ╞════════╤══════════════════════╤═══════════════╤═════════╡
   │    2: 0    │ Добавление элемента  │     Правая    │    5    │
   │        │ в список             │               │         │
   ├--------┴----------------------┴---------------┴---------┤
   │          3Тип 0: a -> [a] -> [a]                            │
   ╞════════╤══════════════════════╤═══════════════╤═════════╡
   │    2++ 0   │ Конкатенация списков │     Правая    │    5    │
   ├--------┴----------------------┴---------------┴---------┤
   │          3Тип 0: [a] -> [a] -> [a]                          │
   └─────────────────────────────────────────────────────────┘

 ш1.2
    2Примеры 0 ( 1использования операций 0).
 ш1.0

   > [1,2,3] !! 2         > ['a','b'] !! 2
   3                      Program error: Prelude.!!: index to large

   > [1,2,3]++[4,5]       > ['a']++['b','c']
   [1,2,3,4,5]            "abc"

   > 22:[-1,3,-2]         > 'z':['a','b','c']
   [22,-1,3,-2]           "zabc"

 ш1.2
   Явное указание типа функции в её определении при помощи символов
"::" может  использоваться и для наложения ограничения на тип функ-
ции, которое сужает область использования функции (иногда  выполняя
оптимизирующие действия).
   Например, если функция должна обработать и вернуть только список
" 1ограниченных 0"  1целых чисел 0, то её тип задаётся так:
 ш1.0

   f:: [Int] -> [Int]
 ш1.2

                      2Функции обработки списков

 ш1.0
               1Он ...  высыпал "булавки" на бумагу.  В электрическом
               1свете  "булавки"  отливали  синевой  и только изредка
               1вдруг брызгали чистыми спектральными красками -  жёл-
               1тым, красным, зелёным. Он взял одну "булавку" и осто-
               1рожно, чтобы не уколоться, зажал между большим и ука-
               1зательным пальцами. Потом он выключил свет и подождал
               1немного, привыкая к темноте. Но "булавка" молчала.
                                1А. и Б.Стругацкие. Пикник на обочине
 ш1.2

                       3Арифметические функции
    21. 0 Функция, возвращающая длину списка:
 ш1.0

    2length 0:: [a] -> Int
    2length lst

   Например:

   > length []   > length [1,2]   > length [[[1,2]],[[-5]],[[]]]
   0             2                3

 ш1.2
    22. 0 Функция, возвращающая сумму элементов  1непустого одноуровнево-
 1го 0 (!) числового списка:
 ш1.0

    2sum 0:: Num a => [a] -> a
    2sum lst

   Например:

   > sum [1]   > sum [1,2]   > sum [-1,1,-3,2,1]   > sum [2,3..8]
   1           3             0                     35

   > sum []
   0

 ш1.2
    23. 0 Функция, возвращающая произведение элементов  1непустого  0  1одно-
 1уровневого 0 (!) числового списка:
 ш1.0

    2product 0:: Num a => [a] -> a
    2product lst

   Например:

   > product [1]        > product [1,2]   > product [-1,1,-3,-2,5]
   1                    2                 -30

   > product [2,3..8]   > product []
   40320                1

 ш1.2
                    3Логические функции на списках
    2Определения 0 ( 1в программировании 0).
 ш1.1
    2(1) 1  _Булев список . 0 - это список,  каждый элемент которого является
функцией, возвращающей логическое значение True или False.
    2(2) 0  _ 1Предикатом . 2  0называется функция,  возвращающая логическое зна-
чение True или False.
    2(3) 0  _ 1Логическими функциями . 0 ( _ 1на списках . 0) называются  1предикаты 0, об-
рабатывающие 1 булевы списки 0.

 ш1.2
    21. 0 Функция,  осуществляющая   1конъюнкцию 0  всех  элементов  булева
списка:
 ш1.0

    2and 0:: [Bool] -> Bool
    2and lst

   Например:

   > and [True,False,True]   > and [2*2==4]   > and [2*2==4,5<-2]
   False                     True             False

 ш1.2
    22. 0 Функция,  осуществляющая   1дизъюнкцию 0  всех  элементов  булева
списка:
 ш1.0

    2or 0:: [Bool] -> Bool
    2or lst

   Например:

   > or [True,False,True]   > or [2*2==4]   > or [2*2==5,5<-2]
   True                     True            False

 ш1.2
                      3Простейшие распознаватели
    21. 0 Функция-предикат, определяющая пустоту заданного списка:
 ш1.0

    2null 0:: [a] -> Bool
    2null lst

   Например:

   > null []   > null [1,2,3,4]   > null [[1,(-1)],[2],[3,4,5]]
   True        False              False

 ш1.2
    22. 0 Функция-предикат, определяющий принадлежность элемента задан-
ному  1одноуровневому 0 (!) 1  0списку:
 ш1.0

    2elem 0:: Eq a => a -> [a] -> Bool
    2elem x lst

   Например:

   > elem 'a' ['a']   > elem 5 [1,3,4]   > elem (-2) [-1,-2,3]
   True               False              True

 ш1.2
    23. 0 Функция-предикат, определяющий отсутствие элемента в заданном
 1одноуровневом 0 (!) 1  0списке:
 ш1.0

    2notElem 0:: Eq a => a -> [a] -> Bool
    2notElem 0  2x lst

   Например:

   > notElem 'a' ['a']        > notElem 5 [1,3]
   False                      True

   > notElem (-2) [-1,-2,3]   > notElem 'x' ['a','s']
   False                      True

 ш1.2
   Данные функции можно также описать следующей таблицей:
 ш1.0

   ┌────────┬──────────────────────┬───────────────┬─────────┐
   │  3Символ  0│        3Значение 0       │ 3Ассоциативность 0│ 3Приоритет 0│
   ╞════════╪══════════════════════╪═══════════════╪═════════╡
   │   2elem 0  │ Существование элемен-│       -       │    4    │
   │        │ та в списке          │               │         │
   ├--------┴----------------------┴---------------┴---------┤
   │          3Тип 0: Eq a => a -> [a] -> Bool                   │
   ╞════════╤══════════════════════╤═══════════════╤═════════╡
   │  2notElem 0│ Отсутствие элемента  │       -       │    4    │
   │        │ в списке             │               │         │
   ├--------┴----------------------┴---------------┴---------┤
   │          3Тип 0: Eq a => a -> [a] -> Bool                   │
   └─────────────────────────────────────────────────────────┘

 ш1.2
                       3Простейшие компараторы
    21. 0 Функция, возвращающая "больший" список из двух заданных спис-
ков (в смысле лексикографического порядка):
 ш1.0

    2max 0:: Ord a => a -> a -> a
    2max lst1 lst2

   Например:

   > max [1] [2]  > max [1] [-2,3]  > max [2] [2,3]
   [2]            [1]               [2,3]

 ш1.2
    22. 0 Функция, возвращающая "меньший" список из двух заданных спис-
ков (в смысле лексикографического порядка):
 ш1.0

    2min 0:: Ord a => a -> a -> a
    2min lst1 lst2

   Например:

   > min [1] [2]  > min [1] [-2,3]  > min [2] [2,3]
   [1]            [-2,3]            [2]

 ш1.2
    23. 0 Функция,  возвращающая максимальное значение элементов исход-
ного 1 непустого 0 списка:
 ш1.0

    2maximum 0:: Ord a => [a] -> a
    2maximum lst

   Например:

   > maximum [1]         > maximum [-1,-2]
   1                     -1

   > maximum [-1,-2,5]   > maximum [[1],[1,1]]
   5                     [1,1]

   > maximum [[1],[-2,3],[4,5,6],[1,1,1]]
   [4,5,6]

 ш1.2
    24. 0 Функция, возвращающая минимальное значение элементов исходно-
го 1 непустого 0 списка:
 ш1.0

    2minimum 0:: Ord a => [a] -> a
    2minimum lst

   Например:

   > minimum [1]          > minimum [-1,-2]
   1                      -2

   > minimum [5,-5,-10]   > minimum [[1],[1,1]]
   -10                    [1]

   > minimum [[1],[(-2),3],[4,5,6],[1,1,1]]
   [-2,1]

 ш1.2
                       3Элементарные селекторы
    21. 0 Функция, возвращающая первый элемент  1непустого 0 (!) списка:
 ш1.0

    2head 0:: [a] -> a
    2head lst

   Например:

   > head ['a']   > head [1,2,3,4]   > head [[1,-1],[2],[3,4,5]]
   'a'            1                  [1,-1]

 ш1.2
    22. 0 Функция, возвращающая хвост 1 непустого 0 (!) списка, т.е. список
без его первого элемента:
 ш1.0

    2tail 0:: [a] -> [a]
    2tail lst

   Например:

   > tail ['a']   > tail [1,2,3,4]   > tail [[1,-1],[2],[3,4,5]]
   []             [2,3,4]            [[2],[3,4,5]]

 ш1.2
    23. 0 Функция, возвращающая последний элемент 1 непустого 0 (!) списка:
 ш1.0

    2last 0:: [a] -> a
    2last lst

   Например:

   > last ['a']   > last [1,2,3,4]   > last [[1,-1],[2],[3,4,5]]
   'a'            4                  [3,4,5]

 ш1.2
    24. 0 Функция,  возвращающая исходный  1непустой 0 (!) список без  пос-
леднего элемента:
 ш1.0

    2init 0:: [a] -> [a]
    2init lst

   Например:

   > init ['a']   > init [1,2,3,4]   > init [[1,-1],[2],[3,4,5]]
   []             [1,2,3]            [[1,-1],[2]]

 ш1.2
    25. 0 Функция,  возвращающая список из первых n элементов исходного
списка:
 ш1.0

    2take 0:: Int -> [a] -> [a]
    2take n lst

   Например:

   > take 2 [1,2,3]   > take 3 [[1,-1],[2],[3,4,5]]
   [1,2]              [[1,-1],[2],[3,4,5]]

   > take 1 []
   Cannot find "show" function for...

 ш1.2
    3Замечание 0.
 ш1.1
   В платформе Haskell полезно вместо вызова head [] (приводящего к
генерации исключения) воспользоваться функцией take 1 [], возвраща-
ющей [].

 ш1.2
    26. 0 Функция,  возвращающая список элементов исходного списка, на-
чиная с n-ого элемента (нумерация элементов списка начинается с ну-
ля):
 ш1.0

    2drop 0:: Int -> [a] -> [a]
    2drop n lst

 ш1.2
   Если указанный номер элемента превышает длину списка, то функция
возвращает пустой список.
   Например:
 ш1.0

   > drop 2 [1,2,3]   > drop 3 [[1,-1],[2],[3,4,5]]
   [3]                []

   > drop 1 []
   Cannot find "show" function for...

 ш1.2
    3Замечание 0.
 ш1.1
   В платформе Haskell полезно вместо вызова tail [] (приводящего к
генерации исключения) воспользоваться функцией drop 1 [], возвраща-
ющей [].

 ш1.2
                    3Элементарные преобразователи
    21. 0 Функция,  преобразующая список списков в список, элементы ко-
торого располагаются на один уровень ниже:
 ш1.0

    2concat 0:: [[a]] -> [a]
    2concat lst

   Например:

   > concat [[[2]]]   > concat [[[1]],[[2,3,4]]]
   [[2]]              [[1],[2,3,4]]

   > concat [[1,-1],[2],[3,4]]
   [1,-1,2,3,4]

 ш1.2
    22. 0 Функция, возвращающая список элементов исходного списка в об-
ратном порядке:
 ш1.0

    2reverse 0:: [a] -> [a]
    2reverse lst

   Например:

   > reverse [[[]]]   > reverse [[[1]],[[2,3,4]]]
   [[[]]]             [[[2,3,4]],[[1]]]

   > reverse [[1,-1],[2],[3,4],[-5]]
   [[-5],[3,4],[2],[1,-1]]

 ш1.2
                      3Элементарные конструкторы
    21. 0 Функция,  возвращающая список, составленный из заданного эле-
мента, повторенного указанное количество раз:
 ш1.0

    2replicate 0:: Int -> a -> [a]
    2replicate n x

   Например:

   > replicate 0 2   > replicate 2 1   > replicate 3 [1,-2]
   []                [1,1]             [[1,-2],[1,-2],[1,-2]]

   > replicate 3 'a'
   "aaa"

 ш1.2
    22. 0 Функция, конструирующая конечный список элементов (образующих
арифметическую прогрессию  с разностью 1) по двум заданным,  являю-
щихся границами списка:
 ш1.0

    2numericEnumFromTo 0:: Real a => a -> a -> [a]
    2numericEnumFromTo 0  2m n

   Например:

   > numericEnumFromTo 3 10
   [3,4,5,6,7,8,9,10]

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции следующее:
 ш1.0

    2enumFromTo m n

   Например:

   > enumFromTo 1 11
   [1,2,3,4,5,6,7,8,9,10,11]

 ш1.2
    23. 0 Функция, конструирующая конечный список элементов (образующих
арифметическую прогрессию с разностью, определяемую двумя начальны-
ми положительными значениями) до  заданного  элемента,  являющегося
третьим аргументом функции:
 ш1.0

    2numericEnumFromThenTo 0:: Real a => a -> a -> a -> [a]
    2numericEnumFromThenTo 0  2m n k

   Например:

   > numericEnumFromTo 1 4 28
   [1,4,7,10,13,16,19,22,25,28]

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции таково:
 ш1.0

    2enumFromThenTo 0  2m n k

   Например:

   > enumFromThenTo 3 10 31
   [3,10,17,24,31]

 ш1.2
    24. 0 Функция,  разделяющая  исходный  список на два и возвращающая
пару из полученных списков. Точкой деления исходного списка являет-
ся  указанное число элементов,  которые следует разместить в первом
выходном списке:
 ш1.0

    2splitAt 0:: Int -> [a] -> ([a],[a])
    2splitAt n lst

   Например:

   > splitAt 0 [1,2,3,4,5]   > splitAt 2 [[1,2],[3],[-4,-5,4]]
   ([],[1,2,3,4,5])          ([[1,2],[3]],[-4,-5,4])

   > splitAt 5 [[1,2],[3]]
   ([[1,2],[3]],[])

 ш1.2
    25. 0 Функция, формирующая по двум заданным спискам список пар, об-
разованных из  соответствующих  элементов  исходных списков (zip от
англ.  1zipper - застёжка-молния 0):
 ш1.0

    2zip 0:: [a] -> [b] -> [(a,b)]
    2zip lst1 lst2

 ш1.2
   Если списки имеют разную длину,  то длина результирующего списка
равна длине наиболее короткого списка.
   Например:
 ш1.0

   > zip [] []   > zip [1,-2] [-5,3]   > zip [1,2,3,4] [-1,-2,-3]
   []            [(1,-5),(-2,3)]       [(1,-1),(2,-2),(3,-3)]

   > zip [-1,-3,-5,-7,-9,-11,-13,-15] [-2,-4,-6,-8,-10]
   [(-1,-2),(-3,-4),(-5,-6),(-7,-8),(-9,-10)]

 ш1.2
    26. 0 Функция, формирующая  по трём заданным спискам  список троек,
образованных из соответствующих элементов исходных списков:
 ш1.0

    2zip3 0:: [a] -> [b] -> [c] -> [(a,b,c)]
    2zip3 lst1 lst2 lst3

 ш1.2
   Если списки имеют разную длину, то длина результирующего  списка
будет равна длине наиболее короткого списка.
   Например:
 ш1.0

   > zip3 [] [] []   > zip3 [1,4] [2,5] [3,6]
   []                [(1,2,3),(4,5,6)]

   > zip3 [1,2,3,4] [-1,-2,-3]
   [(1,-1),(2,-2),(3,-3)]

   > zip3 [-1,-2,-3,-4,-5] [1,2,3,4,5,6] [11,22,33,44]
   [(-1,1,11),(-2,2,22),(-3,3,33),(-4,4,44)]

 ш1.2
    27. 0 Функция, преобразующая список пар в пару списков:
 ш1.0

    2unzip 0:: [(a,b)] -> ([a],[b])
    2unzip lstPair

 ш1.2
   Например:
 ш1.0

    > unzip [(1,-5),(-2,3)]   > unzip [(1,-1),(2,-2),(3,-3)]
   ([1,-2],[-5,3])            ([1,2,3],[-1,-2,-3])

   > unzip [(-1,-2),(-3,-4),(-5,-6),(-7,-8),(-9,-10)]
   ([-1,-3,-5,-7,-9],[-2,-4,-6,-8,-10])

 ш1.2
    28. 0 Функция, преобразующая список троек в тройку списков:
 ш1.0

    2unzip3 0:: [(a,b,c)] -> ([a],[b],[c])
    2unzip3 0  2lstThree

 ш1.2
   Например:
 ш1.0

   > unzip3 [(1,2,3),(4,5,6)]
   ([1,4],[2,5],[3,6])

   > unzip3 [(1,-1,11),(2,-2,22),(3,-3,33)]
   ([1,2,3], [-1,-2,-3], [11,22,33])

   > unzip3 [(-1,1,11),(-2,2,22),(-3,3,33),(-4,4,44)]
   ([-1,-2,-3,-4],[1,2,3,4],[11,22,33,44])

 ш1.2
                    3Элементарные преобразователи
                             3на строках
    21. 0 Функция, возвращающая по строке символов, содержащей переносы
строки (\n),  список подстрок,  разделённых символом " 1Перенос стро-
 1ки 0":
 ш1.0

    2lines 0:: String -> [String]
    2lines 0  2str

   Например:

   > lines "abc\ndef"   > lines "\n\n\n"   > lines "\na\nb\nc\nd\n"
   ["abc","def"]        ["","",""]         ["","a","b","c","d"]

 ш1.2
    22. 0 Функция,  возвращающая по строке символов, содержащей символы
" 1Пробел 0", список слов, разделённых этими символами:
 ш1.0

    2words 0:: String -> [String]
    2words str

   Например:

   > words "abc def"   > words "   "   > words " a b c d "
   ["abc","def"]       []              ["a","b","c","d"]

 ш1.2
    23. 0 Функция,  возвращающая  по  списку  подстрок  единую  строку,
вставляя символ  2" 1Перенос строки 2" 0 между исходными подстроками:
 ш1.0

    2unlines 0:: [String] -> String
    2unlines 0  2lstStr

   Например:

   > unlines ["abc","def"]   > unlines ["","",""]
   "abc\ndef\n"              "\n\n\n"

   > unlines ["","a","b","c","d"]
   "\na\nb\nc\nd\n"

 ш1.2
    24. 0 Функция,  возвращающая по списку слов единую строку, вставляя
символ " 1Пробел 0" между исходными словами:
 ш1.0

    2unwords 0:: [String] -> String
    2unwords 0  2lstWrd

   Например:

   > unwords ["abc","def"]   > unwords [""]
   "abc def"                 ""

   > unwords ["",""]         > unwords ["","a","b","c","d"]
   " "                       " a b c d"
 ш1.2

                        3Свойства элементарных
                             3селекторов

 ш1.0
                  1Мыш перелетел ему  на  запястье,  понюхал  пыльный
                  1пергамент  и  звонко чихнул,  потом снова принялся
                  1рассматривать строчки.  Он почти всегда так делал,
                  1когда хозяин брал в руки книгу.  Наверное,  зверёк
                  1не терял надежды, что смешные маленькие таракашки,
                  1прятавшиеся внутри, однажды всё-таки поползут. 0
                             1М.Семёнова. Волкодав. Право на поединок
 ш1.2

   Приведём свойства важных функций,  которые называются  _ 1элементар-
 _ 1ными селекторами . 0 и предназначены для построения и анализа списков:
 ш1.0

   (1) head (x:y), y 7е 1List 0(A)   => x 7е 0A;
   (2) 2  0y 7е 1List 0(A), y 7- 0[]         => (head y) 7е 0A;

   (3) tail (x:y)              => y 7е 1List 0(A);
   (4) 2  0y 7е 1List 0(A), y 7- 0[]         => (tail y) 7е 1List 0(A);

   (5) head (x:y) : tail (x:y) => (x:y);

   (6) init y = reverse $ tail $ reverse y, y 7е 1List 0(A);
   (7) init y = (reverse. tail. reverse) y, y 7е 1List 0(A);
   (8) last y = (head . reverse) y, y 7е 0List(A);

   (9) take m y ++ drop m y  => y, m 7е ═N 0, y 7е 1List 0(A).

 ш1.2
    3Замечание 0 ( 1для знатоков теории комбинаторов 0).
 ш1.0

    2S 0 ( 2B 0 (++) (take m)) (drop m) y => y, m 7е ═N 0, y 7е 1List 0(A).

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 2, Пример 3.

                  3Конструирование списков с помощью
                    3функций из библиотеки Prelude 0
                3Работа с демонстрационными примерами
   См. Пример 4, Пример 5.

                          3Понятие "кортеж"

 ш1.0
                        1Установился странный, беспорядочный порядок.
                                       1Н.В.Гоголь. Мёртвые души, т.2
 ш1.2

   Все элементы в списке должны иметь один и тот же тип: невозможно
поместить целое число, например, в список строк.
   Тем не менее,  в процессе программирования  возникает  необходи-
мость группировать элементы различных типов. В этих случаях исполь-
зуют способ организации комбинированных типов:  данные группируются
в  _ 1кортежи . 0 (или  _ 1тьюплы . 0) - упорядоченные множества величин 9.
    3Замечание 0.
 ш1.1
    1tuples 0          (англ.) - кортеж;
    1ordered n-tuple 0 (англ.) - упорядоченная n-ка.

 ш1.2
    2Определение 0 ( 1в программировании 0).
 ш1.1
    _ 1Кортеж . 0 - это набор значений разного типа (заключённых в  круглые
скобки и разделённых запятыми), который составляет единое самостоя-
тельное значение, участвующее в вычислительном процессе.

 ш1.2
   Элементы кортежа заключают в круглые скобки и разделяют  запяты-
ми. В  кортеже важен порядок элементов,  а тип кортежа определяется
указанием типа каждого элемента.
   Например, (1,(2,3)) и ((1,2),3) являются  различными  кортежами,
имеющими соответственно типы:
 ш1.0

   (Int,(Int,Int)) и ((Int,Int),Int).

 ш1.2
   Для кортежа  из  двух элементов используется термин 1  0" 1пара 0",  для
кортежа из трёх элементов - " 1тройка 0" (или " 13-тьюпл 0") и т.д.
    2Пример 0.
 ш1.1
   Кортеж, содержащий три элемента,  а именно: целое число, символ,
список целых чисел:
 ш1.0

   (31,'k',[1,3])

 ш1.2
   Существует   _ 1пустой кортеж . 0  ( 10-тьюпл 0),  который обозначается () и
имеет тип ().
    11-тьюпл 0 существует,  но его использование не имеет смысла,  т.к.
выражение (7) - это просто целое число.
 ш1.0

    4┌ 0──────────────────────────────────────────────────────── 4┐
   │Всегда можно заключить любое выражение в круглые скобки.│
    4└ 0──────────────────────────────────────────────────────── 4┘

 ш1.2
    3Замечания 0 ( 1для знатоков 0).
 ш1.1
    21. 0 Кортежи в языке Haskell иногда используются для задания аргу-
ментов функций, называемых 1  _некаррированными 0  1функциями . 0.
    22. 0 Кортежи напоминают структуры языка программирования C,  кото-
рые определяются с помощью ключевого слова struct.
 ш1.2

                  3Функции обработки двухэлементных
                           3кортежей  2( 1пар 2)

 ш1.0
           1Нечего и говорить,  что список был составлен по всем пра-
           1вилам этикета 0: 1  сначала шёл король,  потом королева-мать,
           1потом королева, принц, принцесса и т.д. Все сердца трепе-
           1тали во время этого чтения. приглашённых было более трёх-
           1сот. Каждый спрашивал себя, будет ли в списке его имя. 0
                   1А.Дюма. Виконт де Бражелон, или Десять лет спустя
 ш1.2

    21. 0 Функция, возвращающая первый элемент кортежа, содержащего два
элемента:
 ш1.0

    2fst 0:: (a,b) -> a
    2fst (a,b)

   Например:

   > fst (1,2)  > fst ([-1],2)  > fst ("qwe qwe",-22)
   1            [-1]            "qwe qwe"

 ш1.2
    22. 0 Функция, возвращающая второй элемент кортежа, содержащего два
элемента:
 ш1.0

    2snd 0:: (a,b) -> b
    2snd (a,b)

   Например:

   > snd (1,2)   > snd (1,[-2])   > snd (11,"qwe qwe")
   2             [-2]             "qwe qwe"

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6.
 ш1.2

                  3Конструирование списков с помощью
                         3определителя списка

 ш1.0
                                1Лишь в ограничении познаётся мастер.
                                            1С.Лем. Несчастный случай
 ш1.2

    1Определитель списка 0 является " 1синтаксическим сахаром 0" и  исполь-
зуется для моделирования математического понятия " 1множество 0", опре-
деляемого с помощью  _ 1характеристической функции множества . 0  ( 1характе-
 1ристического предиката 0).
   Напомним, что  1синтаксический сахар 0 - это особенности языка,  ко-
торые  упрощают чтение и написание кода и дают возможность выразить
одни и те же действия разными способами.
    2Определение 0.
 ш1.1
    _ 1Определитель .  0( 1формирователь 0) 1   _списка . 0 - это метод конструирования
списка, элементы которого определяются с помощью данного предиката.
    _ 1Синтаксис определителя списка . 0 таков (читается: "список элементов
x, выбираемых из списка xs"):
 ш1.0

   [x | x <- xs].

 ш1.2
    _ 1Генератором списка . 0 называется слово x <- xs;  генератор для каж-
дого x должен быть определён однозначно.

 ш1.2
   Генерация элементов списка происходит в соответствии с  предика-
том:
 ш1.0

   < 1Имя_функции 0> = [x | x <- xs, < 1Условное_выражение_1 0> 1,
                                 < 1Условное_выражение_2 0> 1,
                                          ...
                                 < 1Условное_выражение_n 0>]

 ш1.2
   Условия, составляющие предикат определителя списка, можно предс-
тавить в отдельной функции:
 ш1.1

   < 1Имя_функции 0> = [x | x <- xs, < 1Имя_функции-предиката 0>]
       where < 1Имя_функции-предиката 0> 1 =  0< 1Условное_выражение 0>

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 В языке программирования Python определитель списков  называ-
ется  _ 1списковым включением . 0 (англ.  1comprehension 0 -  1понимание, включе-
 1ние, охват 0).
    22. 0 [Марков,2016,с.172]  В языке  Visual Prolog 7.5  определитель
списков называется  _ 1коллектором списков . 0 и выглядит так:
 ш1.0

   [X || p(X)].

 ш1.1
    23. 0 В  _ 1платформе . 0 (!) Haskell существует  1синтаксический сахар 0, поз-
воляющий  производить поочерёдный выбор элементов из двух списков с
последующим выполнением операции:
 ш1.0

   > :s -XParallelListComp
   > [x*y | x <- [1..3] | y <- [1..5]]
   [1,4,9]
 ш1.2

                      3Графическое представление
                         3списочных структур

 ш1.0
                      1Волкодав вспомнил, как мать учила его отличать
                      1котов от кошек по форме мордочки,  и рассудил,
                      1что к ним в гости пожаловала именно кошка. 0
                                                1М.Семёнова. Волкодав
 ш1.2

    _ 1Графическая нотация . 0 - это графическое представление списков, ос-
нованное на ссылочной структуре списков языка Haskell.
   Оперативная память компьютера,  на котором  "работает"  Haskell,
логически разбивается на области, называемые  _ 1списочными ячейками . 0.
   Эти области состоят из  1полей 0 с именами  2head 0  ("голова")  и   2tail
("хвост"), каждое из которых содержит  _ 1указатель . 0 (!).  Указатель мо-
жет ссылаться на другую списочную ячейку, на атом языка Haskell или
быть "пустым",  т.е.  ни на что не указывать (в случае  обозначения
пустого списка).
   Соединение ячеек памяти с помощью  указателей  образует   1цепочку
 1ячеек 0,  по которой можно передвигаться до атомарных объектов, попа-
дая из предыдущей ячейки в следующую.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Каждый атом записывается в определённом месте памяти  _ 1один единс-
 _ 1твенный раз . 0.

 ш1.2
   Списочную ячейку графически будем представлять  прямоугольником,
разделённым на поля,  называемые head и tail. Указатель будем изоб-
ражать в виде стрелки, начинающейся в одной из частей прямоугольни-
ка и заканчивающейся на изображении другой ячейки или атоме,  адрес
которого содержит соответствующий указатель.
   Пустой указатель изобразим символом "N".
    2Примеры 0 ( 1графической нотации 0).
 ш1.1
    21.  0Изобразим список [1,2,3,4] в графической нотации:
 ш1.0

   head tail   head tail   head tail   head tail
   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
   │ * │ * ┼── 76 0│ * │ * ┼── 76 0│ * │ * ┼── 76 0│ * │ N │
   └─│─┴───┘   └─│─┴───┘   └─│─┴───┘   └─│─┴───┘
      7^ 0            7^ 0            7^ 0            7^
     1 ( 1атом 0) 1    0 2 ( 1атом 0) 1    0 3 ( 1атом 0) 1    0 4 ( 1атом 0)

 ш1.1
    22. 0 Изобразим список [[10], [10], [9]] в графической нотации дву-
мя эквивалентными способами (обратите внимание на разное количество
используемых ячеек):
 ш1.0

  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐   ┌───┬───┐  ┌───┬───┐  ┌───┬───┐
  │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │   │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │
  └─┼─┴───┘  └─│─┴───┘  └─│─┴───┘   └─┼─┴───┘  └─│─┴───┘  └─│─┴───┘
    │        ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐   ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐
     4└ 0─────── 76 0│ * │ N │  │ * │ N │   │ * │ N │  │ * │ N │  │ * │ N │
             └─│─┴───┘  └─│─┴───┘   └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
                7^ 010         7^ 09           7^ 010         7^ 010         7^ 09

 ш1.1
    23. 0 Представим список [[1,2], [3]] в графической нотации:
 ш1.0

   ┌───┬───┐             ┌───┬───┐
   │ * │ * ┼──────────── 76 0│ * │ N │
   └─┼─┴───┘             └─│─┴───┘
   ┌─ 7^ 0─┬───┐  ┌───┬───┐  ┌─ 7^ 0─┬───┐
   │ * │ * ┼─ 76 0│ * │ N │  │ * │ N │
   └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
      7^ 01          7^ 02          7^ 03

 ш1.2
    2Примеры 0 ( 1построений точечных и списочных записей по
             1графическому представлению 0).
 ш1.1
    21. 0  _ 1Графическое представление . 0:
 ш1.0

   ┌───┬───┐  ┌───┬───┐  ┌───┬───┐    1Точечная запись 0 : 1:2:3:[]
   │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │
   └─│─┴───┘  └─│─┴───┘  └─│─┴───┘    1Списочная запись 0: [1,2,3]
      7^ 01          7^ 02          7^ 03

 ш1.1
    22. 0  _ 1Графическое представление . 0:
 ш1.0

   ┌───┬───┐  ┌───┬───┐
   │ * │ * ┼─ 76 0│ * │ N │               _ 1Точечная запись . 0 :
   └─┼─┴───┘  └─│─┴───┘                       (1:[]):((2:3:[]):[])
   ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐  ┌───┬───┐    _ 1Списочная запись . 0: [[1],[2,3]]
   │ * │ N │  │ * │ * ┼─ 76 0│ * │ N │
   └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
      7^ 01          7^ 02          7^ 03
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

    2Пример 0  26.
 ш1.0

 ш1.2

    2Пример 0  27.
 ш1.0

 ш1.2

    2Пример 0  28.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                             1Холмс засмеялся.
                             1- Ничего себе задачка 0! 1 - сказал он.
                                     1А.Конан Дойл. Скандал в Богемии
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                    21. 3 Обработка элементов списка
    21. 0 Определите прагматику функций, приведённых ниже:
 ш1.0

   (1) cdr:: [Int] -> [Int]
       cdr lst | null lst = lst
               | True     = tail lst

   (2) doub:: [Int] -> [Int]
       doub lst | null lst = lst
                | True     = head lst : lst

   (3) posl lst | null lst = error "Недопустимый аргумент!"
                | True     = (head.reverse) lst

   (4) xinLst:: [Int] -> Bool
       xinLst lst | null lst = undefined
                  | True     = elem (head lst) (tail lst)

   (5) swap lst =
            reverse (head lst :
                    (reverse (head (reverse lst):
                             reverse (tail (reverse (tail lst)))))

 ш1.2
    22 4* 2. 0 Напишите функцию,  определяющую модуль  разности  первого  и
последнего элементов числового списка.
    23 4* 2. 0 Напишите функцию,  определяющую  индекс  элемента  числового
списка, значение которого равно сумме первого и последнего элемента
того же списка.
    24 4* 2. 0 Напишите функцию,  определяющую, равен ли "центральный" эле-
мент числового списка произведению крайних элементов.
    25 4* 2. 0 Напишите  предикат,  определяющий,  является ли произведение
элементов числового списка факториалом числа, равного длине списка.
    26 4* 2. 0 Напишите предикат,  определяющий,  все ли элементы числового
списка являются: (1) трёхзначными числами; (2) чётными числами.
    27 4* 2. 0 Напишите функцию, возвращающую по заданному списку целых чи-
сел список их факториалов; при этом вычисление факториала числа ре-
ализуйте с помощью  1нерекурсивной 0 функции.
    28 4* 2. 0 Напишите  предикат,  определяющий,  встречается ли указанный
своим индексом элемент первого заданного списка во втором  заданном
списке.
    29. 0 Напишите функцию, которая по двум спискам, имеющим одинаковую
длину, возвращает:
 ш1.1
   (1) первый список, если сумма элементов первого списка совпадает
с суммой элементов второго списка;
   (2) сумму элементов второго списка в противном случае.

 ш1.2
    210 4* 2. 0 По закону Российской федерации производители обязаны марки-
ровать  продукцию  с   1генетически модифицированными 0 ингредиентами с
помощью номера ( 1PLU- _кода . 0) на наклейке производителя; при этом:
 ш1.1
   (1) если номер состоит из пяти цифр,  начинающихся с 9,  то про-
дукт был выращен без  применения  химикатов,  пестицидов  или  ген-
ной модификации;
   (2) четырёхзначное число,  начинающееся с 3 или 4, означает, что
продукт выращен на обычной ферме, которая использует химические ве-
щества и пестициды, и не является генно-модифицированным;
   (3) продукты,  отмеченные пятизначным кодом, начинающимся с 8, -
это генетически модифицированные культуры.

 ш1.2
   По заданному PLU-коду установите свойства продукта.
    211. 0 Напишите функцию,  определяющую в списке,  содержащем списки
целых чисел, количество таких списков, содержащих заданное число.
    212. 0 ( 1Покер 0.) Задан список из пяти чисел. Если одинаковы 5 чисел,
то напечатайте число 1, иначе если одинаковы 4 числа, то напечатай-
те число 2,  иначе если одинаковы 3 и 2 числа, то напечатайте число
3, иначе если одинаковы 3 числа, то напечатайте число 4, иначе если
одинаковы 2 и 2 числа, то напечатайте число 5, иначе если одинаковы
2 числа, то напечатайте 6, иначе напечатайте число 7.
    213 5* 2. 0 Напишите  функцию,  возвращающую  наибольший элемент списка
типа [[Int]].
                       22. 3 Трансформация списка
    21 4* 2. 0 Напишите функцию, удаляющую "крайние" элементы списка.
    22 4* 2. 0 Напишите функцию, меняющую местами "крайние" элементы списка.
    23. 0 Напишите  функцию,  меняющую местами пару элементов списка по
их указанным индексам.
    24. 0 Напишите функцию, добавляющую в начало списка копию его пред-
последнего элемента.
    25. 0 Напишите  функцию,  удваивающую  первый элемент списка (путём
создания копии),  если его значение меньше значения второго элемен-
та.
    26. 0 Напишите функцию rotate, реализующую  _ 1циклическую ротацию . 0  за-
данного списка влево, т.е.
 ш1.0

   > rotate 3 [1..10]
   [4,5,6,7,8,9,10,1,2,3]

 ш1.2
   Напишите также бесточечную реализацию rotate?
                     23. 3 Конструирование конечных
                               3списков
    21 4* 2. 0 Напишите  функцию,  объединяющую первую "половину" элементов
первого списка со второй "половиной" элементов второго списка.
    22 4* 2. 0 Напишите  функцию,  объединяющую три заданных списка в один,
после предварительного удаления из них последних элементов.
    23 4* 2. 0 Напишите  функцию,  конструирующую  список  из "центральных"
элементов трёх заданных списков.
    24 4* 2. 0 Напишите  функцию,  объединяющую  два заданных списка,  если
сумма максимального элемента первого списка и минимального элемента
второго списка  равна  заданному числу;  в противном случае функция
возвращает пустой список.
    25 4* 2. 0 Напишите функцию,  конструирующую список из заданных списков
[A 41 0,A 42 0,...,A 4n 0] и [B 41 0,B 42 0,...,B 4n 0] следующим образом:
 ш1.1
   (1) если A 41 0=B 4n 0 и A 4n 0=B 41 0, то [A 42 0,...,A 4n-1 0,B 42 0,...,B 4n-1 0];
   (2) если A 41 0=B 4n 0 и A 4n 7- 0B 41 0, то [A 42 0,...,A 4n 0,B 41 0,...,B 4n-1 0];
   (3) если A 41 7- 0B 4n 0 и A 4n 0=B 41 0, то [A 41 0,...,A 4n-1 0,B 42 0,...,B 4n 0];
   (4) в противном случае [A 41 0,...,A 4n 0,B 41 0,...,B 4n 0].

 ш1.2
    26 5* 2. 0 Напишите функцию, конструирующую список из двух заданных та-
ким образом,  что из первого списка  берутся  только  отрицательные
числа, а из второго - только положительные.
    27 5* 2. 0 Напишите  функцию,  конструирующую  список  путём повторения
каждого его элемента три раза.
                24. 3 Списочная, точечная и графическая
                           3запись 0  3списков
    21 4* 2. 0 Проверьте с помощью Haskell результат интерпретации списков:
 ш1.0

   (1) ['s','t','r','i','n','g'];
   (2) [' '];
   (3) [[[' ']], [['o']], [[' ']]];
   (4) [['h','e','a','d'], ['t','a','i','l']];
   (5) [['h','e','a','d'], ['t'], ['a'], ['i'], ['l']].

 ш1.2
    22. 0 Изобразите с помощью  графической  нотации  следующие  списки
(т.е. выполните перевод  1списочной 0 записи в  1графическую 0):
 ш1.0

   (1) [];
   (2) [[[]]];
   (3) [1,2,3];
   (4) [[11,22,33]];
   (5) [[[-1,-2,-3]],[[-123]],[[]],[[9,5,14,56]]].

 ш1.2
    23. 0 Запишите структуру со следующим  1графическим 0 представлением  в
 1списочной 0 нотации:
 ш1.0

       ┌───┬───┐  ┌───┬───┐  ┌───┬───┐
   (1) │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │
       └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
          7^ 01          7^ 00          7^ 01

       ┌───┬───┐                                  ┌───┬───┐
   (2) │ * │ * ┼───────────────────────────────── 76 0│ * │ N │
       └─│─┴───┘                                  └─│─┴───┘
       ┌─ 7^ 0─┬───┐                                  ┌─ 7^ 0─┬───┐
       │ * │ N │                                  │ * │ N │
       └─│─┴───┘                                  └─│─┴───┘
       ┌─ 7^ 0─┬───┐  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐ ┌─ 7^ 0─┬───┐
       │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │ │ N │ N │
       └─│─┴───┘  └─│─┴───┘  └─│─┴───┘  └─│─┴───┘ └───┴───┘
          7^ 0100        7^ 050         7^ 025         7^ 05

       ┌───┬───┐  ┌───┬───┐  ┌───┬───┐
   (3) │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │
       └─┼─┴───┘  └─│─┴───┘  └─│─┴───┘
         │           4└ 0───────── 4┐ 0│
         │                   ┌ 7^^ 0─┬───┐
          4└ 0────────────────── 76 0│ * │ N │
                             └─│─┴───┘
                                7^ 0-33

       ┌───┬───┐  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐
   (4) │ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ * ┼─ 76 0│ * │ N │
       └─┼─┴───┘  └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
       ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐  ┌─ 7^ 0─┬───┐
       │ * │ N │  │ * │ N │  │ * │ N │  │ * │ N │
       └─│─┴───┘  └─│─┴───┘  └─│─┴───┘  └─│─┴───┘
         │ 4┌ 0───────── 4┘ 0           4└ 0───────── 4┐ 0│
       ┌─ 7^^ 0┬───┐                        ┌ 7^^ 0─┬───┐
       │ * │ N │                        │ * │ N │
       └─│─┴───┘                        └─│─┴───┘
          7^ 05                                7^ 07

 ш1.2
    24. 0 Переведите следующие  1точечные 0 записи списка в  1списочные 0:
 ш1.0

   (1) (1:(2:(3:(4:(5:[])))));
   (2) ((1:[]):((2:[]):((3:[]):[])));
   (3) (((2:(1:[])):[]):[]);
   (4) ((5:(1:[])):((2:(3:[])):[]));
   (5) (((1:[]):((2:[]):[])):(((3:[]):[]):[])).

 ш1.2
    25. 0 Сформулируйте правило перевода списочной записи в точечную.
    26. 0 Сформулируйте правило перевода  1списочной 0 записи списка в   1то-
 1чечную 0, выполнение которого показано на примерах:
 ш1.0

   (1) [[[1]]]     ──> (((1:[]):[]):[]);
   (2) [[1,2],[3]] ──> ((1:(2:[]))):((3:[]):[])).

 ш1.2
    27. 0 Переведите следующие  1списочные 0 записи списка в  1точечные 0:
 ш1.0

   (1) [];
   (2) [[]];
   (3) [[1], [2], [3], [4]];
   (4) [[1,2], [3,4]];
   (5) [[1], [2,22], [3,33,333]];
   (6) [[[9,8,7,6]], [[5,4,3]], [[2,1]], [[0]]].

 ш1.2
   Проверьте результат с помощью интерпретатора  Haskell,  вводя  в
командной строке полученные точечные записи списков.

    _ 1Домашнее задание . 0:
 ш1.0

   №№  21 41,3,5,10,12 0;  22 41,2,4,6 0;  23 41,2,3 0;  24 42,3,4,7 0; ( 1всего 16 задач 0).

    _ 1Дополнительные задачи . 0: №№  24 45,6 0.
 ш1.2
