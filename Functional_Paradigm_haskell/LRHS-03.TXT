    2ЛАБОРАТОРНАЯ РАБОТА 3.
    2ПРОСТАЯ РЕКУРСИЯ  НА ЧИСЛОВЫХ СТРУКТУРАХ.  СЛОЖНЫЕ ТИПЫ РЕКУРСИИ
 2НА ЧИСЛОВЫХ СТРУКТУРАХ

 ш1.0
                             1Мы привыкли к тому, что люди издеваются
                             1над тем, чего они не понимают. 0
                                                                1Гёте
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать понятия . 0:
 ш1.0
   - рекурсия, рекурсивная функция;
   -  _ 1простая рекурсия . 0:  рекурсия по аргументам,  рекурсия по значе-
нию, рекурсия по значению и по аргументам;
   - хвостовая рекурсия, накапливающий параметр;
   -  _ 1сложные типы рекурсии . 0:  параллельная рекурсия, взаимная рекур-
сия, рекурсия высших порядков.

    _ 1Уметь . 0:
   - реализовывать простой тип рекурсии  (рекурсию  по  аргументам,
рекурсию по значению, рекурсию по значению и по аргументам) в прог-
раммах на языке Haskell;
   - применять технологии построения рекурсивных определений  функ-
ций (нисходящая рекурсия, восходящая рекурсия);
   - реализовывать сложный тип рекурсии в программах на языке  Has-
kell.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

 ш1.0
                1Функциональное программирование  - это ставка на да-
                1лёкий успех. Это в корне иной взгляд на программиро-
                1вание в целом. Из-за этого его трудно изучать, и да-
                1же после изучения трудно принять, поскольку различие
                1носит революционный, а не эволюционный характер. 0
                1До сих пор неясно сможет ли функциональное  програм-
                1мирование  стать в итоге ведущим стилем.  Зато ясно,
                1что функциональное программирование оказало  влияние
                1на ведущие языки, и это влияние растёт. Вот вам при-
                1меры 0: 1  сборка мусора,  полиморфные типы   0( 1генерики 0) 1,
                1итераторы, LINQ, безымянные функции и т.д. 0
                                                      1С.Пейтон-Джонс
 ш1.2

   В языке  Haskell для описания циклических процессов используется
рекурсия.
    2Определения 0 ( 1содержательные 0).
 ш1.1
    2(1) 0 [Кондаков,1976,с.515]   _ 1Рекурсия . 0 (от лат. 1  recurso 0 -  1бегу на-
 1зад 0,  1возвращаюсь 0) - это способ задания функции, при котором её зна-
чения для  произвольных значений аргументов выражаются через значе-
ния этой функции для меньших значений аргументов.
    2(2) 0 [Дейтел,Дейтел,2002,с.199]   _ 1Рекурсивная функция . 0   1  0( 1в  языках
 1Common LISP, Scheme, OCaml, Haskell, Scala, Clojure, F#, Erlang 0)  1  0-
это  функция,  которая вызывает сама себя или непосредственно,  или
косвенно через другую функцию.

 ш1.2
    3Замечание 0 ( 1повторение 0).
 ш1.1
   Haskell - это  1чисто функциональный 0 и  1ленивый 0 язык,  т.е.  в  нём
невозможны ни присваивания,  ни циклы. Вообще отсутствует всё импе-
ративное. Это  даёт значительное преимущество,  но является своеоб-
разной пропастью для изучения.  Хотя там и  можно  начинать  писать
сразу же якобы императивно, это совсем не то, чем кажется.
   Чтобы полностью понять Haskell (если до того долго  программиро-
вал на  императивных  языках и отсутствует математическое образова-
ние) довольно сложно (но  не  невозможно),  требуется  значительная
настойчивость.  Зато  с определённой уверенностью можно утверждать,
что после него уже не будет существовать языка программирования (не
обязательно функционального!), который бы не изучался за полдня.
   Зато в смысле отдачи получаешь невероятную мощь всего,  что при-
думала  наука  " 1computer science 0" в области языков программирования
за последние 30 лет (плюс,  видимо, самая большая надёжность кода),
а именно:
   (1)  _ 1вывод типов . 0:  появился в ML (1979),  стал  1мэйнстримом 0 в 2007
(C#, Scala, C++0x);
   (2)  _ 1параметрический полиморфизм . 0: появился в 1983, сейчас -  1мэйн-
 1стрим 0 в Java, C#, C++;
   (3)  _ 1сборка мусора . 0:  появилась в LISP (1958), стала  1мэйнстримом 0 в
1995 (Java);
   (4)  _ 1замыкания . 0:  появились в Scheme (1975),  стали  1мэйнстримом 0  в
2000-х (C#, JavaScript);
   (5)  _ 1функции высшего порядка . 0:  появились в LISP, сейчас  1мэйнстрим
везде, кроме языка Java;
   (6)  _ 1ленивая обработка . 0:  появилась в Miranda (1985),  стала  1мэйн-
 1стримом 0 в 2000-е (LINQ).
   Недостатком языка является то,  что очень долго Haskell был иск-
лючительно  1академическим языком программирования 0, т.е. его развива-
ли программисты,  которым это нужно было не для того,  чтобы писать
программное обеспечение, а для того, чтобы  1писать научные работы 0.
   В настоящее время язык Haskell превращается  в   1производственный
 1язык 0.
 ш1.2

                          2Простая рекурсия
    2Определение 0.
 2   0ш1.1
    _ 1Простой рекурсией . 0 ( 1CDR- _рекурсией . 0) называется рекурсия, при кото-
рой вызов функции встречается в некоторой  ветви  программы  только
один раз.

 2   0ш1.2
    1Простая рекурсия 0 (по [Хювенен,Сеппянен,1990]) подразделяется на:
 2   0ш1.1
   (1)  1рекурсию по аргументам 0;
   (2)  1рекурсию по значению 0;
   (3)  1рекурсию по значению и по аргументам 0.

 2   0ш1.2
                      21. 0  3Рекурсия по аргументам
    2Определение 0.
 ш1.1
   Будем говорить,  что   _ 1в функции . 0  1F  _присутствует рекурсия по аргу-
 _ 1ментам . 0, если в качестве результата функция возвращает значение дру-
гой функции  1G 0, при этом в вычислении аргументов этой функции участ-
вует рекурсивный вызов  1F 0.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1, Пример 4, Пример 5.

 ш1.2
                       22. 0  3Рекурсия по значению
                       ( 1хвостовая рекурсия 0)
    2Определение 0.
 ш1.1
   Будем  говорить,  что   _ 1в функции . 0  1F  _на языке . Haskell  _присутствует
 _ 1рекурсия по значению . 0,  если в качестве результата возвращается зна-
чение функции  1F 0.

 ш1.2
   Частным случаем рекурсии по значению является  1хвостовая рекурсия 0.
    2Определение 0 (по [Душкин,2007,с.151]).
 ш1.1
    _ 1Хвостовой рекурсией . 0 называется специальный вид рекурсии, в кото-
рой имеется единственный вызов рекурсивной функции, и при этом этот
вызов выполняется только после всех вычислений.

 ш1.2
   В функциональном программировании часто для реализации хвостовой
рекурсии увеличивают  количество аргументов функции с помощью аргу-
ментов, в которых фиксируется состояние внешней среды (они  называ-
ются  _ 1аккумуляторами . 0).
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
   Хвостовой рекурсии в императивном программировании соответствует
цикл,  а "хороший" транслятор функционального языка должен  "уметь"
распознавать хвостовую рекурсию и реализовывать её в виде цикла.
                       23. 0  3Рекурсия по значению
                           3и по аргументам
   Напомним, что стандартная техника обеспечения хвостового  вызова
- это использование  1вспомогательной функции с аккумулятором 0.
    2Определение 0.
 ш1.1
   Будем говорить,  что  _ 1в функции . 0  1F  _присутствует рекурсия по значе-
 _ 1нию и по аргументам . 0, если выполнены два условия:
   (1) в качестве результата  функция  возвращает  значение  другой
функции  1G 0,  при этом в вычислении аргументов этой функции участвует
рекурсивный вызов  1F 0;
   (2) в качестве результата возвращается значение функции  1F 0.
 ш1.2

                  2Технология построения рекурсивных
                         2определений функций
   Существует два  разных  стиля  написания рекурсивных определений
функций с использованием простой рекурсии (по [Грэй,1989,с.72-73]):
 1нисходящая рекурсия 0 и  1восходящая рекурсия 0.
                       21. 0  3Нисходящая рекурсия
    2Определение 0 ( 1описательное 0).
 ш1.1
    _ 1Нисходящая рекурсия .  0последовательно разбивает данную  задачу  на
все более простые,  пока не доходит до  _ 1терминального случая . 0 (ситуа-
ции,  когда продолжения рекурсии не требуется),  в котором значение
определяемой функции получается без использования её вызова (с дру-
гими значениями аргумента),  характерного для рекурсивных определе-
ний. После этого ответ начинает "конструироваться" с помощью проме-
жуточных результатов, передаваемых обратно вызывающим функциям.

 ш1.2
   Процесс написания рекурсивного определения  функции  распадается
на отдельные шаги. Эти определения кажутся очевидными впоследствие,
но их не всегда легко придумать. Трудность, по-видимому, в том, что
мы должны повторно вызывать определяемую функцию в тот момент, ког-
да еще не знаем, будет ли работать создаваемое определение функции.
   Здесь нужно допустить,  что мы уже имеем функцию,  которая  пра-
вильно работает для аргумента, равного n-1 и построить определение,
которое будет работать для следующего случая, т.е. для n.
   Приведём  1рецепт 0 написания  индуктивного  определения  функции  в
случае  _ 1нисходящей рекурсии . 0 (по [Грэй,1989,с.78-80]):
 ш1.1
   (1) напишите определение для терминального случая (например, для
числа 0);
   (2) предположите, что у вас есть определение функции, работающее
для случая,  наиболее близкого к терминальному (например, для n-1).
Попытайтесь использовать его для построения выражения,  которое го-
дится для следующего случая при подъёме вверх;
   (3) соедините результаты пунктов (1) и (2), используя охраняющие
или условные выражения;
   (4) проведите тестирование.

 ш1.2
   Построение функций с накапливающим параметром - приём не универ-
сальный, и он не гарантирует получения хвостовой рекурсии.
    3Замечание 0 ( 1важное 0).
 ш1.1
   В силу рецептурного характера сказанного выше, мы приводим боль-
шое количество примеров.  Желательно, чтобы вы выполнили написанные
функции на компьютере и попытались их улучшить. Это один из  1класси-
 1ческих способов изучения рекурсивного программирования 0.

 ш1.2
                       22. 0  3Восходящая рекурсия
   При рекурсивных вызовах функций используется большой объём памя-
ти для хранения промежуточных результатов и адресов возврата значе-
ния рекурсивной функции.
   Использование  1вспомогательных переменных 0, которые называются  _ 1на-
 _ 1капливающими параметрами . 0,  позволяет использовать память только для
хранения адресов возврата значения функции.
   В функциональном программировании возможно осуществить такой ме-
ханизм с помощью   1восходящей  рекурсии 0,  используя   1вспомогательную
 1функцию 0, с аргументами, которыми являются накапливающие параметры.
    2Определение 0 ( 1описательное 0).
 ш1.1
   Для реализации  _ 1восходящей рекурсии . 0 к функции  добавляется  новый
параметр, который называется  _ 1накапливающим параметром . 0 (или  _ 1парамет-
 _ 1ром типа 0 " 1рабочая память 0" .).
   Промежуточные результаты вычисляются на каждой стадии  рекурсии,
при этом результат конструируется постепенно, хранится и передаётся
в виде накапливающего параметра до тех пор, пока не будет достигнут
терминальный случай. К этому времени  1результат уже содержится в на-
 1капливающем параметре 0  и  необходимо  лишь  вернуть  его вызывающей
функции верхнего уровня.

 ш1.2
   Приведём рецепт  написания  индуктивного  определения  функции в
случае  _ 1восходящей рекурсии . 0 [Грэй,1989,с.78-80; Душкин,2007,с.152]:
 ш1.1
   (1)  1придумайте 0 (!) функцию,  имеющую один или несколько накапли-
вающих параметров, один из которых будет содержать результат;
   (2) для  1терминального случая 0 положите  значение  функции  равным
значению некоторого накапливающего параметра;
   (3) для  1нетерминального случая 0 повторно вызовите функцию со зна-
чениями других ("главных") параметров, выраженными через "старые";
   (4) вызовите функцию с начальными значениями накапливающих пара-
метров;
   (5) проведите тестирование и исправьте, если необходимо, началь-
ные значения накапливающих параметров.

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 2, Пример 3.

                  2Сложные типы рекурсии на числовых
                             2структурах
   К сложным типам рекурсии относятся:   1параллельная рекурсия 0,  1вза-
 1имная 0  1рекурсия 0 и  1рекурсия высших порядков 0.
                      21. 0  3Параллельная рекурсия
    2Определение 0.
 ш1.1
    _ 1Параллельной рекурсией . 0 ( _ 1рекурсией . CAR-CDR 0,   _ 1рекурсией по дереву . 0)
называется рекурсия,  встречающаяся одновременно в нескольких аргу-
ментах функции.

 ш1.2
    3Замечание 0.
 ш1.1
   Название параллельной рекурсии " 1рекурсией по дереву 0"  связано  с
тем, что её часто приходится использовать  для  обхода   _ 1древовидных
 _ 1структур данных . 0, т.е. списка, элементами которого являются списки.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6, Пример 7, Пример 8.

 ш1.2
                        22. 0  3Взаимная рекурсия
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Взаимной рекурсией . 0  называется  рекурсия,  в которой две или
более функций вызывают друг друга.
    2(2) 0  _ 1Взаимно-рекурсивными функциями . 0 называют функции,  вызывающие
друг друга "по цепочке" (другими словами,  функция вызывает  другую
функцию 1, 0 а та, в свою очередь, вызывает первую).

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 9.

 ш1.2
                     23. 0  3Рекурсия высших порядков
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Рекурсией высших порядков . 0 называется форма рекурсии, при ко-
торой  рекурсивный вызов функции является аргументом вызова этой же
самой функции на определённом уровне рекурсии.
    2(2) 0 Функции, не обладающие рекурсией высших порядков, называются
 _ 1функциями с рекурсией нулевого порядка . 0.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 10.

 ш1.2
   Продемонстрируем с помощью рекурсии высших  порядков  тот  факт,
что интерпретатор языка Haskell использует  _ 1нормальный порядок . 7 b 0- _ 1ре-
 _ 1дукции . 0 при вычислениях.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 10, Пример 11.

 ш1.2
               24.  3Трансформация функций для приведения
                         3к простой рекурсии
   Существуют редкие случаи, когда с помощью  _ 1трансформации программ
рекурсия высших порядков может быть приведена к простой рекурсии.
    2Пример 0  21 0 ( 1Э.Дейкстра 0).
 ш1.1
   Рассмотрим следующие рекуррентные соотношения:
 ш1.0

   f(0)=0, f(1)=1, f(2n)=f(n), f(2n+1)=f(n)+f(n+1).

 ш1.1
   Преобразуем эту рекурсию высшего порядка в простую рекурсию.
   Рассмотрим новую функцию
 ш1.0

   g(n,i,j)=i 77 0f(n)+j 77 0f(n+1),

для которой

   f(n)=g(n,1,0).

 ш1.1
   Определим рекуррентные соотношения для функции g():
 ш1.0

   (1) g(2n,i,j)=i 77 0f(2n)+j 77 0f(2n+1)=i 77 0f(n)+j 77 0f(n)+j 77 0f(n+1)=

                =(i+j)f(n)+j 77 0f(n+1)=g(n,i+j,j);

   (2) g(2n+1,i,j)=i 77 0f(2n+1)+j 77 0f(2n+2)=i 77 0f(n)+i 77 0f(n+1)+j 77 0f(n+1)=

                  =i 77 0f(n)+(i+j) 77 0f(n+1)=g(n,i,i+j).

 ш1.1
   Итак, получена простая рекурсия
 ш1.0

   g(0,i,j)=j, g(2n,i,j)=g(n,i+j,j), g(2n+1,i,j)=g(n,i,i+j),

которая легко программируется.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 12.

 ш1.2
    2Пример 0  22 0 (по [Сергиевский,Волчёнков,2010,с.83]).
 ш1.1
   Рассмотрим следующее рекуррентное соотношение второго порядка:
 ш1.0

   f(0)=0, f(1)=1, f(n)=f(n-1)+f(n-2).

 ш1.1
   Преобразуем эту рекурсию высшего порядка в простую рекурсию.
   Рассмотрим новую функцию, значением которой является пара:
 ш1.0

   g(n)=(f(n+1),f(n)),

для которой

   g(0)=(f(1),f(0))=(1,1).

 ш1.1
   Определим рекуррентные соотношения для функции g():
 ш1.0

   g(n+1)=(f(n+2),f(n+1))=(f(n+1)+f(n),f(n+1)) =>

         => g(n+1)=(u+v,u)
               where (u,v)=(f(n+1),f(n))=g(n).

 ш1.1
   Остаётся преобразовать выражение для функции f():
 ш1.0

   f(n+2)=f(n)+f(n+1) => f(n+2)=u+v
                            where (u,v)=(f(n+1),f(n))=g(n).

 ш1.1
   Таким образом, получена взаимная рекурсия:
 ш1.0

    7( 0f(0)=0, f(1)=1,
   │f(n)=u+v
    72 0   where (u,v)=g(n-2),
    7*
   │g(0)=(1,1),
   │g(n)=(u+v,u)
    79 0   where (u,v)=g(n-1).

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 13.

 ш1.2
                    3Некоторые итерационные методы
                          3решения уравнений
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1(p), Пример 2(p), Пример 3(p), Пример 4(p).
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ

 ш1.0
                1Он подержал часы в руке, как бы взвешивая их, внима-
                1тельно рассмотрел циферблат,  потом открыл крышку  и
                1стал  рассматривать механизм,  сперва просто так,  а
                1потом вооружившись сильной двояковыпуклой лупой. 0
                                          1А.Конан Дойл. Знак четырёх
 ш1.2

    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

    2Пример 0  26.
 ш1.0

 ш1.2

    2Пример 0  26 41 2.
 ш1.0

 ш1.2

    2Пример 7.
 ш1.0

 ш1.2

    2Пример 8.
 ш1.0

 ш1.2

    2Пример 8 41 2.
 ш1.0

 ш1.2

    2Пример 9.
 ш1.0

 ш1.2

    2Пример 10.
 ш1.0

 ш1.2

    2Пример 11.
 ш1.0

 ш1.2

    2Пример 12.
 ш1.0

 ш1.2

    2Пример 0  213.
 ш1.0

 ш1.2

    2Пример 0  214.
 ш1.0

 ш1.2

    2Пример 0  215.
 ш1.0

 ш1.2

    2Пример 0  216.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
               1Экзаменационные задачи будут подобны тем,  которые мы
               1обсудили в аудитории. Конечно, числа могут различать-
               1ся. Но не все, 7 p 0  1по-прежнему будет равно 3.1415926...
                                                             1Анекдот
 ш1.2

    20 41 2. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
    20 42 2. 0 Приведите пример рекурсивной программы, которую нельзя запи-
сать без рекурсии.
    _ 1Решение . 0. Такой пример привести невозможно:  всегда вместо рекур-
сии можно использовать цикл и  _ 1стек . 0 (?!).
                21. 3 Определение прагматики 0  3рекурсивных
                           3функций по коду
    21 4* 2. 0 Укажите  1прагматику 0 (назначение) рекурсивных функций:
 ш1.0

   (1) mult n 0 = 0
       mult n m = mult n (m-1)+n

   (2) russ n 1 = n
       russ n m | m `mod` 2==0 = russ (n*n) (m `div` 2)
                | True         = n*russ (n*n) (m `div` 2)

   (3) z:: Int -> Int -> Int
       z p n | n<p  = 0
             | True = 1 + z p (n `div` p)

   (4) 5* 0 f:: Int -> String
        f n | n>=1000 = "M" ++ f (n-1000)
            | n>=500  = "D" ++ f (n-500)
            | n>=100  = "C" ++ f (n-100)
            | n>=50   = "L" ++ f (n-50)
            | n>=10   = "X" ++ f (n-10)
            | n>=5    = "V" ++ f (n-5)
            | n>=1    = "I" ++ f (n-1)
            | True    = ""
        ------------------------------
        -- Неудачные тестовые примеры:
         2-------------------- 0--------- 2----------
        testF = f 12=="XII" && f 1256=="MCCLVI"

 ш1.2
    22 4* 2. 0 Напишите  программу для вычисления значения приведённой ниже
функции (x,y,z 7е ═N 0) и вычислите с её помощью  1F 0(5,0,0),  1F 0(1000,0,0).
 ш1.0

    1F 0(x,y,z)= _ 1если . 0 x=0
               _ 1то . 0 0
               _ 1иначе . 0  _ 1если . 0 y+1=x
                       _ 1то . 0 z
                       _ 1иначе . 0  1F 0(x,y+1,z+1)

 ш1.2
   Вычислите значение  1F 0(5,0,0) с помощью "ручных" вычислений.
 ш1.1
    _ 1Указание .  0(по [Хендерсон,1983,с.6]). Известный американский мате-
матик  1А.Чёрч 0 (автор  1тезиса Чёрча 0), создал на подступах к теории ал-
горитмов   7l 0- 1исчисление 0,  являющееся  теоретической моделью функцио-
нального программирования.  Он безуспешно пытался выразить в  языке
 7l 0-исчисления операцию вычитания единицы из натурального числа (знак
операции " 1Sub 0")
 ш1.0

    7( 1Sub 0(0,1)=0,
    7*
    79 1Sub 0(n+1,1)=n.

 ш1.1
   А.Чёрч уже  уверился  в неполноте своего исчисления,  но С.Клини
(тогда молодой аспирант) в 1932 г. предложил конструкцию, полностью
отвечающую сути дела и приведённую нами выше.

 ш1.2
    23 4* 2. 0 Определите  1прагматику 0 функции и реализуйте её на Haskell:
 ш1.0

                 7( 01, если m=0;
                 72
    1Rem 0(n,m,b)  ═+ 0  7* 1Rem 0(n 52 0 MOD b,m/2,b), если m ─ чётное;
                 72
                 79 0n 77 1Rem 0(n 52 0 MOD b,(m-1)/2,b) в противном случае.

 ш1.1
    _ 1Указание . 0. Функция  1Rem 0(n,m,b) для целых чисел  n,m,b>0  вычисляет
остаток от деления n 5m 0 на b.

 ш1.2
    24 4* 2. 0 Определите  1прагматику 0 приведённой ниже рекурсивной функции и
реализуйте её на языке Haskell:
 ш1.0

   gcd(m,n)  ═+ 0 gcd'(│m│,│n│);

                7( 0m, если n=0;
   gcd'(m,n)  ═+ 0  7*
                79 0gcd'(n,r), r - остаток от деления m на n
                   в противном случае.

 ш1.2
    25. 0 (По [Бауэр,Гооз,1990,с.209])
   Определите  1прагматику 0  функции   1Rom 0(n)  и реализуйте её на языке
Haskell (" 77 0" - операция приписывания буквы слева к слову):
 ш1.0

             7( 0'M' 77 1Rom 0(n-1000), если n 7. 01000;
             72 0'D' 77 1Rom 0(n-500),  если n 7. 0500;
             72 0'C' 77 1Rom 0(n-100),  если n 7. 0100;
    1Rom 0(n)  ═+ 0  7* 0'L' 77 1Rom 0(n-50),   если n 7. 050;
             72 0'X' 77 1Rom 0(n-10),   если n 7. 010;
             72 0'V' 77 1Rom 0(n-5),    если n 7. 05;
             79 0'I' 77 1Rom 0(n-1),    если n 7. 01.

 ш1.1
    _ 1Указание . 0. Функция  1Rom 0(n) осуществляет перевод натурального числа
в его " 1римскую запись 0" и реализует  _ 1первоначальную  римскую  систему
 _ 1счисления . 0.  Такие  сокращенные способы записи,  как,  например,  IV
вместо IIII вошли в употребление лишь в начале XVI в.

 ш1.2
                   22. 3 Простая рекурсия на числовых
                             3структурах
    21 4* 2. 0 Напишите функцию, вычисляющую факториал натурального числа с
помощью рекурсии по аргументам.
    22 4* 2. 0 Напишите функцию, вычисляющую факториал натурального числа с
помощью рекурсии по значению.
    23 4* 2. 0 Напишите функцию, вычисляющую число сочетаний из n элементов
по m.
    24 4* 2. 0 Напишите функцию, вычисляющую значение функции при n,m 7е ═N 0:
 ш1.0

   (1) F(n)=4 5n 0;  (2) F(n)=n 5n 0;  (3) F(m,n)=m 5n 0.

 ш1.2
    25 4* 2. 0 [Бауэр,Гооз,1990]
   Напишите рекурсивную функцию, моделирующую операцию сложения на-
туральных чисел с помощью тождества
 ш1.0

   (a+1)+(b-1)=a+b.

 ш1.2
    26. 0 ( 1Душкин Р.В. 0) Напишите программу, вычисляющую значение следу-
ющих функций при значениях n 7еN 0\{0}:
 ш1.0

             n               n-1                  n   n
             7░▒ 0                7░▒ 0                   7░▒ 0   7░▒
   (1) F(n)=  7▓ 0 k;   (3) F(n)=  7▓ 0 (n-k);  (5) F(n)=  7▓ 0    7▓ 0 j.
             7│┤ 0                7│┤ 0                   7│┤ 0   7│┤
            k=1              k=1                 k=1 j=1

             n                n
             7░▒ 0                7░▒
   (2) F(n)=  7▓ 0 2 5k 0;  (4) F(n)=  7▓ 0 k!;
             7│┤ 0                7│┤
            k=1              k=0

 ш1.2
    27 4* 2. 0 Реализуйте вычисление значения функции n!!.
    28 4* 2.  0[Бауэр,Гооз,1990]
   Напишите функцию, определяющую для натурального числа n 7. 01 единс-
твенное натуральное число  1ld 0(n), такое, что
 ш1.0

     4ld(n)-1    ld(n)
   2        7, 0n<2     ,  1ld 0(1)=1.

 ш1.1
    _ 1Указание . 0. Для тестирования выразите функцию  1ld 0(n) из уравнения
 ш1.0

       4ld(n)-1
   n=2       .

 ш1.2
    29 4* 2. 0 [Ахо,Ульман,1978,с.345]
   Напишите программу для вычисления значения функции, заданной ре-
куррентными соотношениями:
 ш1.0

    1D 0(0)=1,  1D 0(n) = 1 +  1D 0(n-1) 52 0.

 ш1.1
    _ 1Указание . 0. Для тестирования воспользуйтесь тем, что
 ш1.0
            4n
    1D 0(n)=]k 52  0[, k=1.502837,

где ]x[ - наименьшее целое число, большее или равное 7  0x.

 ш1.2
    210 5* 2. 0 Напишите рекурсивную функцию,  осуществляющую перевод нату-
ральных чисел:
 ш1.1
   (а) из десятичной системы счисления в двоичную;
   (б) из двоичной системы счисления в десятичную.

 ш1.2
    211 5* 2. 0 [Анисимов,Пупышев,2006,с.62,№7.18])
   Дано целое положительное n. Найдите
 ш1.0

        7|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
       7/ 0     7|\\\\\\\\\\\\\\\\\\\\\
      7/ 0     7/ 0  7|\\\\\\\\\\\
     7/    0  7/ 0  7/ |\
    7? 0 ... 7? 0  7? 0  7? 03n + 3(n-1) + 3(n-2) + 7777 0+ 3.

 ш1.2
    212 5* 2. 0 [Анисимов,Пупышев,2006,с.63,№7.23])
   Дано целое положительное n. Найдите
 ш1.0

   1/(2 50 0+1/(2 51 0+1/.../(2 5n 0+1/2 5n+1 0)...)).

 ш1.2
    213 5* 2. 0 Напишите рекурсивную функцию,  реализующую  1факторизацию 0 на-
турального числа  n>1,  т.е.  возвращающую  разложение натурального
числа на простые множители.
                   23.  3Сложная рекурсия на числовых
                             3структурах
    21. 0 (По [Андерсон,2003,с.199-200])
   Напишите функцию, вычисляющую значения a 4n 0 по заданному рекурсив-
ному определению:
 ш1.0

        7( 0a 40 0=1;                          7( 0a 40 0=7;
       │                              │
   (1)  7* 0a 41 0=-6;                    (4)  7* 0a 41 0=4;
       │                              │
        79 0a 4k 0=6a 4k-1 0-9a 4k-2 0 при k>1;        79 0a 4k 0=-a 4k-1 0+6a 4k-2 0 при k>1;

        7( 0a 40 0=-3;                         7( 0a 40 0=2;
       │                              │
   (2)  7* 0a 41 0=-5;                    (5)  7* 0a 41 0=-6;
       │                              │
        79 0a 4k 0=6a 4k-1 0-8a 4k-2 0-3 при k>1;      79 0a 4k 0=a 4k-1 0+6a 4k-2 0+3 77 02 5k 0 при k>1;

        7( 0a 40 0=0;                          7( 0a 41 0=1;
       │                              │
   (3)  7* 0a 41 0=8;                     (6)  7* 0a 42 0=1;
       │                              │
        79 0a 4k 0=2a 4k-1 0+3a 4k-2 0 при k>2;        79 0a 4k 0=a 4k-1 0+a 4k-2 0 при k>1.

 ш1.1
    _ 1Указание . 0. Для тестирования воспользуйтесь соотношениями:
 ш1.0

   (1) a 4n 0=3 5n 0-n3 5n+1 0;      (4) a 4n 0=2(-3) 5n 0+5 77 02 5n 0;

   (2) a 4n 0=-1-2 5n+1 0;       (5) a 4n 0=3(-2) 5n 0+2 77 03 5n 0-3 77 02 5n 0;
                                            7|\ 0        7|\
                                  1   5  7(( 01+ 7? 05  7) 5n 0  7( 01- 7? 05  7) 5n 7)
   (3) a 4n 0=-2(-1) 5n 0+2 77 03 5n 0;  (6) a 4n 0= ─── 5─ 7722 0───── 72 0 - 72 0───── 72 0  72 0.
                                 5 51/2  799 0  2   70 0   79 0  2   70 0  70

 ш1.2
    22 4* 2. 0 Напишите функцию на языке Haskell, заданную так:
 2   0ш1.0

         7( 0n-3, если n>202;
    1F 0(n)= 7*
         79 1F 0( 1F 0(n+4)) в противном случае.

 2   0ш1.1
    _ 1Указание . 0. Для тестирования воспользуйтесь тем, что для n 7е ═Z
 2   0ш1.0

         7( 0n-3, если n>202;
    1F 0(n)= 7*
         79 0200 в противном случае.

 ш1.2
    23 4* 2. 0 Напишите  на  языке Haskell функцию " 191-МакКарти 0",  заданную
следующим образом:
 2   0ш1.0

   F(n)=If n>100
          then n-10
          else F(F(F(n+21)))

 2   0ш1.2
    24. 0 Напишите функцию на  языке  Haskell,  реализующую  вычисление
значения  1функции Аккермана 0:
 2   0ш1.0

               7( 0x+1,                 если n=0;
               72 0 x,                  если n=1, y=0;
    1A 0(n,x,y)  ═+ 0  7* 0 0,                  если n=2, y=0;
               72 0 1,                  если n=3, y=0;
               72 0 2,                  если n 7. 04, 7  0y=0;
               79 1A 0(n-1, 1A 0(n,x,y-1),x), если n 7- 00, y 7- 00.

 2   0ш1.1
    _ 1Указание . 0. Для тестирования воспользуйтесь тестовыми примерами:
 2   0ш1.0

    1A 0(0,x,y)=x+1,  1A 0(1,x,y)=x+y,  1A 0(2,x,y)=x 77 0y,  1A 0(3,x,y)=x 5y 0.

 2   0ш1.2
    25. 0 (По [Анисимов,Пупышев,2006,с.77,№8.18])
   Напишите программу  на языке Haskell для вычисления значения за-
данной функции f(x,y) при заданных x, y:
 2   0ш1.0

   f(0,y)=y,             если y 7е ═N 0;
   f(x,0)=x,             если x 7е ═N 0;
   f(x,x)=f(x-1,x-1)+1,  если x>0;
   f(y,y)=f(y+1,y+1)-1,  если y<0;
   f(x,y)=f(x,x)+f(y,y), если x 7- 0y.

 2   0ш1.2
    26. 0 [Анисимов,Пупышев,2006,с.34,№3.20])
   Что вычисляет данная программа?
 ш1.0

   F(x,y)= _ 1if . 0 y=0  _ 1then . 0 0  _ 1else . 0 F(F(x,y),F(y,x))  _ 1fi

 ш1.2
    27 5* 2. 0 [Анисимов,Пупышев,2006,с.191,№16.16]
   Определим функцию f(x) для целого неотрицательного аргумента x:
 ш1.0

   f(0)=0, f(1)=1, f(2n)=n, f(2n+1)=f(n)+f(n+1).

 ш1.2
   Напишите программу для вычисления f(k) по заданному k 7е ═N 0.

                          24. 3 Задача "3n+1"

 ш1.0
                   1- Так это известная задача.
                   1- А как она решается 0?
                   1- Да нет 0! 1 Условие известное, а решения я не знаю 0.
                                                     1А.Мигл. Диалоги
 ш1.2

    21. 0 [Скиена,Ревилла,2005,с.27-28; Гарднер,1988,с.262-263]
    _ 1Проблема . 0 " _ 13n+1 . 0". Рассмотрим следующий алгоритм генерации  после-
довательности чисел. Начнём с целого числа n.
   Если n чётно, то поделим его на два.
   Если n нечётно, то умножим на 3 и добавим 1.
   Будем повторять  этот  процесс  с новым полученным n,  пока n не
станет равным 1.
   Будем называть  _ 1длиной цикла . n 0 (для данного n)  число  сгенериро-
ванных чисел до и включая 1.
   Для двух заданных чисел i и j вы должны определить  максимальную
длину цикла для всех чисел между i и j, включая обе конечные точки.
   Приведём два примера:
 ш1.1
   (а) для n=22 будет  сгенерирована  следующая  последовательность
чисел:
 ш1.0

   22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1

 ш1.1
   В примере, приведённом выше, длина цикла 22 равна 16;
   (б) среди чисел, меньших 50, самым "противным" оказывается число
27:  после 3 77 0 шагов оно достигает максимума 9232, после чего требу-
ется ещё 3 34 0 шага, чтобы довести его до 1.
   Когда Дж. Конуэй на лекциях начинал рассказывать о задаче "3n+1",
он обычно встаёт у доски и начинает так:  "Давайте возьмём для при-
мера какое-нибудь небольшое число, ну, хотя бы 27, и посмотрим, что
у нас получится".

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 Впервые  задачу  "3n+1"  сформулировал Л.Коллатц незадолго до
второй мировой войны (в то время он был студентом!).
    22. 0 Вычислительные эксперименты показывают,  что процедура, начи-
ная с a 40 0 из очень широкого диапазона (вплоть  до  значений  порядка
10 512 0) приводит к n=1 для любого целого n (иногда после длительных и
весьма экзотических блужданий).
   Но так ли будет для всех a 40 7е ═N 0 -  _ 1пока неизвестно . 0.
   В 1982 г. П.Эрдош высказал мнение, что даже если указанное пред-
положение верно,  то современная теория чисел не располагает  соот-
ветствующими инструментами, для того, чтобы его доказать.
    23. 0 Было  замечено,  что  нет  необходимости проверять все чётные
числа, а также числа вида  4k+1, 16k+3, 128k+7. Это  обстоятельство
существенно упрощает компьютерные программы анализа данной задачи.

 ш1.0
    4┌ 0─────────────────────────────────────────────────────── 4┐
   │Итак, достаточно простые с виду рекурсивные определения│
   │функций могут таить  в себе  глубокие проблемы, решения│
   │которых лежат совсем не на поверхности.                │
    4└ 0─────────────────────────────────────────────────────── 4┘
 ш1.2

                     25. 3 Компьютерная "проверка"
                          3числовых равенств

 ш1.0
            1Его понимание  сущности  математического  доказательства
            1было более чем туманным 0; 1 он пришёл ко всем своим резуль-
            1татам,  как ранним, так и более поздним, как верным, так
            1и неверным,  при помощи странной смеси интуитивных дога-
            1док, интуитивных соображений и логических рассуждений...
                                             1Г.Харди о С.Рамануджане
 ш1.2

    21 4* 2. 0 "Проверьте", используя рекурсию, следующее равенство
 ш1.0

       7|\\\\\\\\\\\
      7/   |\\\\\\\\ 0      7 |\\\
     7/   / 0   7 |\\\\\ 0   1+ 7? 01+4 7a
    7? 0  7a 0+ 7? 0  7a 0+ 7? 0  7a 0+ 5... 0 = ───────, 7 aе ═R 0,  7a. 00.
                        2

 ш1.1
    _ 1Указание . 0. В качестве тестовых примеров  для  проверки  получения
 1целочисленных 0 (!) результатов вычислений рассмотрите случаи:
 ш1.0

    7a 0=  2,   6,  12,  20,  30,  42,  56,  72,  90, 110, 132,
     156, 182, 210, 240, 272, 306, 342, 380, 420, 462, 992,

которые получены с помощью функционалов filter и map:

   test = filter (\x -> denominator (snd x)==1) 
                 (map (\x -> (x,toRational ((1+sqrt (1+4*x))/2)))
                      [2..1000])

 ш1.2
    22.  0[Левин,1968,с.31]
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

        7|\\\\\\\\\\\\\\\\\
       7/ 0     7|\\\\\\\\\\\\\
      7/  0  7  /    |\\\\\\\\\
     7/   0  7 /    / 0    7 |\\\\\
    7? 0 1+2 7? 0 1+3 7? 0 1+4 7? 0 1+ 5... 0= 23 0.

 ш1.2
    23. 0 [Левин,1968,с.31]
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

        7|\\\\\\\\\\\\\\\\\
       7/ 0     7|\\\\\\\\\\\\\
      7/  0  7  /    |\\\\\\\\\
     7/   0  7 /  0  7  / 0     7|\\\\\
    7? 0 6+2 7? 0 7+3 7? 0 8+4 7? 0 9+ 5... 0= 24 0.

 ш1.2
    24. 0 (По [Левин,1968,с.32])
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

        7|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
       7/ 0         7|\\\\\\\\\\\\\\\\\\\\\
      7/  0      7  /    0     7 |\\\\\\\\\\\\\
     7/   0      7 /  0  7  0     7 / 0         7|\\\\\
    7? 0 1+(n+1) 7? 0 1+(n+2) 7? 0 1+(n+3) 7? 0 1+ 5... 0= 2n+2 0.

 ш1.2
    25. 0 "Проверьте",  используя рекурсию, следующий результат  1Ф.Виета
(1540-1603):
 ш1.0

                                 7|\\\\\\\\\\\\\\\\\\\
               7|\\\\\\\\\\\ 0      7/ 0          7|\\\\\\\\\\
       7|\\ 0     7/ 0          7|\\ 0     7/ 0          7/ 0          7|\
      7/  01     7/ 0 1   1    7/  01     7/ 0 1   1    7/ 0 1   1    7/  01         2
     7/ 0  7  0- 7 7 0  7/ 0  7  0- 7  0+ - 77 0  7/ 0  7  0- 7 7 0  7/ 0  7  0- 7  0+ - 77 0  7/ 0  7  0- + - 77 0  7/ 0  7  0-  77  5... 0 = ─.
    7? 0   7  02   7? 0   2   2  7? 0   7  02   7? 0   2   2  7? 0   2   2  7? 0   7  02          7p

 ш1.2
   Разумеется, что Ф.Виет не доказывает сходимости полученного бес-
конечного произведения, будучи  1интуитивно уверенным 0 в справедливос-
ти своего предельного утверждения):
    3Замечание 0 (по [Жуков,2004,с.133]).
 ш1.1
   "Любопытная формула!  - комментирует её Ф.Кыпман,  - она походит
на фантастический лабиринт с тысячами комнат,  в  которых  прячется
число  7p 0.  Если  мы  его ищем под первым радикалом,  то обнаруживаем
дверь, ведущую ко второму радикалу,  через которую  оно  удрало  от
нас. Если преследовать его дальше,  оно находит убежище под третьим
радикалом, как бы охраняемым дробью  51 0/ 42 0, и так далее".

 ш1.2
    26. 0 "Проверьте", используя рекурсию:
 ш1.0

    7p 0   2 2 4 4      2n   2n
   ─ = ─ 77 0─ 77 0─ 77 0─ 77 0... 77 0──── 77 0──── 77 0... ( 1формула Валлиса 0).
   2   1 3 3 5     2n-1 2n+1

 ш1.2
    27. 0 (По [Жуков,2004,с.136])
   "Проверьте", используя рекурсию,  результат  У.Броункера  (1620-
1684), полученный в 1665 г., и результат Л.Эйлера (1707-1783):
 ш1.0

   4            1            ║   7p 0             2
   ─ =1+ ─────────────────   ║  ─ =1+ ─────────────────
    7p 0              9          ║  2             1 77 03
         2+ ──────────────   ║        3+ ──────────────
                   25        ║                  3 77 05
            2+ ───────────   ║           4+ ───────────
                     49      ║                   5 77 07
               2+ ────────   ║              4+ ────────
                      81     ║                     7 77 09
                  2+ ─────   ║                 4+ ─────
                     2+ 7777 0   ║                    4+ 7777

 ш1.2
    28. 0 [Абельсон,Сассман,2006,с.82]
   Представление функции " 1тангенс 0" в виде  1цепной дроби 0 было опубли-
ковано немецким математиком Й.Х.Ламбертом (1770)
 ш1.0

              x
    1tg 0(x)= ─────────
                 x 52
          1 - ────────
                    x 52
              3 - ───────, x 7е ═R 0.
                  5 - 7 777

 ш1.2
   Определите функцию (tan x k), вычисляющей приближение к тангенсу
на основе  1формулы Ламберта 0 (аргумент k указывает  количество  шагов
вычислений).
    29. 0 (По [Жуков,2004,с.136])
   Известно представление функции " 1арктангенс 0" в виде  1цепной дроби 0:
 ш1.0

                  x
    1arctg 0(x)= ───────────
                      x 52
             1+ ──────────────
                           9x 52
                3-x 52 0+ ─────────────
                               25x 52
                      5-3x 52 0+ 7  0─────────, x 7е ═R 0.
                             7-3x 52 0+ 7777

 ш1.2
   Определите функцию (arctan x k),  вычисляющую приближение к зна-
чению функции " 1арктангенс 0" (аргумент k указывает  количество  шагов
вычислений).
    210. 0 (По [Жуков,2004,с.60-61])
   Реализуйте, используя рекурсию, алгоритм  1Дж.Борвейна 0 и  1П.Борвей-
 1на 0 [1988]  для расчёта десятичных знаков числа  7p 0,  который приведён
ниже. Члены  последовательности a 40 0,a 41 0,a 42 0,...  вычисляются по рекур-
рентным формулам:
 ш1.0

           7|\
   a 40 0=6-4 7? 0 2, a 4n+1 0=(1+y 4n+1 0) 54 0a 4n 0-2 52n+3 0y 4n+1 0(1+y 4n+1 0+y 4n+1 52 0), n=0,1,2,...,

                      54 7|\\\\\
        7|\ 0          1- 7? 0 1-y 4n 54
   y 40 0= 7? 0 2-1, y 4n+1 0= ─────────, n=0,1,2,...
                      54 7|\\\\\
                   1+ 7? 0 1-y 4n 54

 ш1.2
   По мере увеличения номера шага  n  величина  1/a 4n 0  очень  быстро
приближается к  7p 0 (уже при n=4 количество верных знаков равно 694).

 ш1.1
    _ 1Указание . 0. Этот алгоритм имеет  1фантастическую эффективность 0: каж-
дый новый шаг выполнения алгоритма уточняет количество верных  цифр
в разложении числа 7 p 0 более, чем вчетверо.
   Авторы алгоритма утверждают,  что у истоков их  открытия  лежали
идеи индийского математика С.Рамануджана (1887-1920).

 ш1.2
             26. 3 Компьютерная "проверка" и 0  3доказательство
                          3числовых равенств
    21 4* 2. 0 "Проверьте", используя рекурсию:
 ш1.0

   n 52 0=1+3+5+ 7777 0+2n-1.

 ш1.2
    22. 0 Напишите  функцию  для вычисления куба натурального числа без
использования умножения. Для этого воспользуйтесь следующим утверж-
дением  ( 1Никомах 0):  куб натурального числа n равен сумме n нечётных
чисел, следующих по порядку за числами, сумма которых составила куб
числа (n-1). Другими словами,
 ш1.0

    7^ 51 0  7^ 52 0     7^ 54 7        ^ 57 0             7^ 511
   1+( 23 0+5)+( 27 0+9+11)+( 213 0+15+17+19)+( 221 0+23+25+27+29)+ 7777
    7%   %      %           % 0               7%
   1 53   02 53      03 53 0          4 53 0             5 53

 ш1.2
   При этом первое слагаемое в n-ой скобке имеет номер 1+ 51 0/ 42 77 0n(n-1)
по порядку нечётных чисел (т.е. 2n-1).
    23. 0 [Левин,1968,с.31]
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

         7|\\\\\\\\\\\\\\\\\
        7/ 0    7|\\\\\\\\\\\\\\
       7/ 0    7/ 0    7|\\\\\\\\\\\
      7/  0  7 / 0  7  / 0    7|\\\\\\\\
     7/  0  7 /   0  7/ 0   7 / 0    7|\\\\\ 0        7|\
    7? 0 8- 7? 0 8+ 7? 0 8- 7? 0 8- 7? 0 8+ 7777 0 = 1+2 7? 03 7  1sin 0(20 5o 0) = X,

 ш1.2
где знаки перед корнями периодически повторяются группами  по  три:
"-", 2  0"+", 2  0"-".
   Выведите уравнение, корнем которого является X.
    _ 1Решение . 0 [Левин,1968,с.32-34]. Приведём следующие выкладки:
 ш1.0

        7|\ 0          4┌ 0     7|\ 0                     4┐1/2
   1+2 7? 03 7  1sin 0(20 5o 0)=│1+4 7? 03  1sin 0(20 5o 0)+12 1sin 52 0(20 5o 0)│   =
                   4└ 0                           4┘
       4┌ 0     7|\ 0            1- 1cos 0(40 5o 0) 4┐1/2
     =│1+4 7? 03  1sin 0(20 5o 0)+12 77 0──────────│   =
       4└ 0                      2      4┘
       4┌ 0     7|\ 0                    4┐1/2
     =│7+4 7? 03  1sin 0(20 5o 0)-6 77 1cos 0(40 5o 0)│   =
       4└ 0                          4┘
       4┌ 0     7|\ 0            7|\ 0                 4┐1/2
     =│7+4 7? 03  1sin 0(20 5o 0)-4 7? 03  1cos 0(30 5o 0) 1cos 0(40 5o 0)│   =
       4└ 0                                    4┘
       4┌ 0     7|\ 0            7|\ 0            7|\ 0         4┐1/2
     =│7+4 7? 03  1sin 0(20 5o 0)-2 7? 03  1cos 0(70 5o 0)-2 7? 03  1cos 0(10 5o 0)│   =
       4└ 0                                         4┘
       4┌ 0     7|\ 0            7|\ 0         4┐1/2 0  4┌ 0     7|\ 0                 4┐1/2
     =│7+2 7? 03  1cos 0(70 5o 0)-2 7? 03  1cos 0(10 5o 0)│   =│7-4 7? 03  1sin 0(30 5o 0) 1sin 0(40 5o 0)│   =
       4└ 0                            4┘ 0     4└ 0                       4┘
       4┌ 0   4┌ 0     7|\ 0         4┐┐1/2
     =│8-│1+2 7? 03  1sin 0(40 5o 0)││   .                                  (1)
       4└ 0   4└ 0               4┘┘
        7|\ 0          4┌ 0     7|\ 0                     4┐1/2
   1+2 7? 03  1sin 0(40 5o 0)=│1+4 7? 03  1sin 0(40 5o 0)+12 1sin 52 0(40 5o 0)│   =
                   4└ 0                           4┘
       4┌ 0     7|\ 0           4┌ 0           4┐┐1/2
     =│1+4 7? 03  1sin 0(40 5o 0)+6│1- 1cos 0(80 5o 0)││   =
       4└ 0                 4└ 0           4┘┘
       4┌ 0     7|\ 0                    4┐1/2
     =│7+4 7? 03  1sin 0(40 5o 0)-6 77 1cos 0(80 5o 0)│   =
       4└ 0                          4┘
       4┌ 0     7|\ 0            7|\ 0                 4┐1/2
     =│7+4 7? 03  1sin 0(40 5o 0)-4 7? 03  1cos 0(30 5o 0) 1cos 0(80 5o 0)│   =
       4└ 0                                    4┘
       4┌ 0     7|\ 0            7|\ 0             7|\ 0         4┐1/2
     =│7+4 7? 03  1sin 0(40 5o 0)-2 7? 03  1cos 0(110 5o 0)-2 7? 03  1cos 0(50 5o 0)│   =
       4└ 0                                          4┘
       4┌ 0     7|\ 0            7|\ 0         4┐1/2 0  4┌ 0     7|\ 0                 4┐1/2
     =│7+2 7? 03  1sin 0(40 5o 0)+2 7? 03  1sin 0(20 5o 0)│   =│7+4 7? 03  1sin 0(30 5o 0) 1cos 0(10 5o 0)│   =
       4└ 0                            4┘ 0     4└ 0                       4┘
       4┌ 0   4┌ 0   7|\ 0           4┐┐1/2
     =│8+│2 7? 03  1sin 0(80 5o 0)-1││   .                                  (2)
       4└ 0   4└ 0               4┘┘
      7|\ 0            4┌ 0               7|\ 0           4┐1/2
   2 7? 03  1sin 0(80 5o 0)-1=│12 1sin 52 0(80 5o 0)-4 7? 03  1sin 0(80 5o 0)+1│   =
                   4└ 0                           4┘
       4┌ 0  4┌ 0            4┐ 0    7|\ 0           4┐1/2
     =│6│1- 1cos 0(160 5o 0)│-4 7? 03  1sin 0(80 5o 0)+1│   =
       4└ 0  4└ 0            4┘ 0                4┘
       4┌ 0     7|\ 0                     4┐1/2
     =│7-4 7? 03  1sin 0(80 5o 0)-6 77 1cos 0(160 5o 0)│   =
       4└ 0                           4┘
       4┌ 0     7|\ 0            7|\ 0                  4┐1/2
     =│7-4 7? 03  1sin 0(80 5o 0)-4 7? 03  1cos 0(30 5o 0) 1cos 0(160 5o 0)│   =
       4└ 0                                     4┘
       4┌ 0     7|\ 0            7|\ 0             7|\ 0          4┐1/2
     =│7-4 7? 03  1sin 0(80 5o 0)-2 7? 03  1cos 0(190 5o 0)-2 7? 03  1cos 0(130 5o 0)│   =
       4└ 0                                           4┘
       4┌ 0     7|\ 0            7|\ 0         4┐1/2
     =│7-2 7? 03  1sin 0(80 5o 0)+2 7? 03  1sin 0(40 5o 0)│   =
       4└ 0                            4┘
       4┌ 0     7|\ 0                 4┐1/2 0  4┌ 0   4┌ 0     7|\ 0         4┐┐1/2
     =│7-4 7? 03  1cos 0(60 5o 0) 1sin 0(20 5o 0)│   =│8-│1+2 7? 03  1sin 0(20 5o 0)││   .      (3)
       4└ 0                       4┘ 0     4└ 0   4└ 0               4┘┘

 ш1.2
   Подстановка друг в друга (1), (2) и (3) приводит к равенству:
 ш1.0
                       7|\\\\\\\\\\\\\\\\\\\\\\\
                      7/ 0    7|\\\\\\\\\\\\\\\\\\\\
                     7/ 0    7/ 0    7|\\\\\\\\\\\\\\\\\
        7|\ 0           7/  0  7 / 0    7/ 0   4┌ 0     7|\ 0         4┐
   1+2 7? 03 7  1sin 0(20 5o 0)= 7? 0 8- 7? 0 8+ 7? 0 8-│1+2 7? 03 7  1sin 0(20 5o 0)│.
                               4└ 0               4┘

 ш1.2
   Искомая формула  может  быть получена отсюда  _ 1итерированием . 0 (пов-
торной подстановкой).
    24 5* 2. 0 [Левин,1968,с.31]
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

         7|\\\\\\\\\\\\\\\\\\\\\\\\\\
        7/ 0      7|\\\\\\\\\\\\\\\\\\\\\
       7/ 0      7/ 0      7|\\\\\\\\\\\\\\\\
      7/   0  7  /  0  7   / 0      7|\\\\\\\\\\\
     7/    0  7 /     / 0     7 / 0      7|\\\\\\
    7? 0 11-2 7? 0 11+2 7? 0 11-2 7? 0 11-2 7? 0 11+ 7777 0 = 1+4 77 1sin 0(10 5o 0) = X,

 ш1.2
где знаки  перед  корнями периодически повторяются группами по три:
"-", 2  0"+", 2  0"-".
   Выведите уравнение, корнем которого является X.
    25 5* 2. 0 [Левин,1968,с.31]
   "Проверьте" результат  1С 0. 1Рамануджана 0, используя рекурсию:
 ш1.0

         7|\\\\\\\\\\\\\\\\\\\\\\\\\\
        7/ 0      7|\\\\\\\\\\\\\\\\\\\\\
       7/ 0      7/ 0      7|\\\\\\\\\\\\\\\\
      7/   0  7  /  0  7   / 0      7|\\\\\\\\\\\
     7/    0  7 /     / 0    7  0  7/ 0      7|\\\\\\ 0        7|\
    7? 0 23-2 7? 0 23+2 7? 0 23+2 7?  023-2 7? 0 23+ 7777 0 = 1+4 7? 03 7  1sin 0(20 5o 0) = X,

 ш1.2
где знаки перед корнями периодически повторяются группами  по  три:
"-", 2  0"+", 2  0"+".
   Выведите уравнение, корнем которого является X.

                         2Контрольные задания
    21. 0 Деление числа A на число B  _ 1с произвольной точностью . 0  выполня-
ется выделением целой части A/B, т.е. └A/B┘, а затем использованием
рекуррентной формулы
 ш1.0

   A 4k 0=10 77 0(A 4k-1 0-└A/B┘ 77 0B).

 ш1.2
   Напишите функцию, возвращающую результат деления  с произвольной
точностью.
    22. 0 ( 1Е.В.Андреева, 2009 0)
   По заданным натуральным числам n 7, 0100 и m 7, 0100 вычислите
 ш1.0

        7|\\\\\\\\\\\\\\\\\\
       7/ 0   7|\\\\\\\\\\\\\\\\
      7/ 0   7/ 0        7|\\\\\\\\\
     7/ 0   7/ 0        7/ 0        7|\\ 0                    _ 1Тестовый пример . 0:
    7? 0m+ 7? 02m+ 7777 0+ 7? 0(n-1)m+ 7? 0n 77 0m.                  n=100, m=2 => 2.158177

 ш1.2
    23 4* 2. 0 ( 1М.Гарднер 0)
   Найдите два рациональных числа, сумма кубов которых равна 6.
 ш1.0

                                                 _ 1Ответ . 0:  517 0/ 421 0,  537 0/ 421
 ш1.2

    _ 1Домашнее задание . 0:
 ш1.0

   №№  21 41,3 0;  22 41,2,7,10 0;  23 42,4 0;  25 41,2,3,4 0;  26 43 0 ( 1всего 13 задач 0).

    _ 1Дополнительные задачи . 0: №№  24 41 0.
 ш1.2
