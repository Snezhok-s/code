   ; Демонстрация применения свёртки REDUCE для реализации
   ; некоторых рекурсивных алгоритмов на языке Lisp.
   ;
   ; Реализовано на занятиях студентами
   ; (ИС, 2 курс, 26.11.2013)
   ; ------------------------

   ; *********************************************
   ; Функция возвращает сумму элементов списка LST
   ; ---------------------------------------------
   (DEFUN Summ (LAMBDA (LST)
      (REDUCE '+ LST 0)
   ))
   ; ----------------------------------------------------
   ; Функция возвращает произведение элементов списка LST
   ; ----------------------------------------------------
   (DEFUN Umn (LAMBDA (LST)
      (REDUCE '* LST 1)
   ))
   ; -----------------------------------------------
   ; Функция возвращает значение функции "факториал"
   ; -----------------------------------------------
   (DEFUN Fact (LAMBDA (n)
      (cond ( (= n 0) 0 )
            (  T  (REDUCE '* (MAPLIST LENGTH (MAKE-LIST n 1))) ))
   ))
   ; ---------------------------------------
   ; Функция возвращает значение функции AND
   ; ---------------------------------------
   (DEFUN ANDF (LAMBDA (LST)
      (REDUCE 'AND LST T)
   ))
   ; --------------------------------------
   ; Функция возвращает значение функции OR
   ; --------------------------------------
   (DEFUN ORF (LAMBDA (LST)
      (REDUCE 'OR LST NIL)
   ))
   ; ------------------------------------------
   ; Функция возвращает значение функции APPEND
   ; ------------------------------------------
   (DEFUN APPENDF (LAMBDA (LST1 LST2)
      (REDUCE '(LAMBDA (x y) (REVERSE (CONS y (REVERSE x))))
              LST2
              LST1)
   ))
   ; --------------------------------------------
   ; Функция возвращает наименьший элемент списка
   ; --------------------------------------------
   (DEFUN Naim (LAMBDA (LST)
      (REDUCE 'MIN LST)
   ))
   ; --------------------------------------------
   ; Функция возвращает наибольший элемент списка
   ; --------------------------------------------
   (DEFUN Naib (LAMBDA (LST)
      (REDUCE 'MAX LST)
   ))

   ; **************************************
   ; Функции, возвращающие длину списка LST
   ; --------------------------------------
   (DEFUN Dlina1 (LAMBDA (LST)
      (REDUCE 'ADD1 LST 0)
   ))
   ; -------------------------
   (DEFUN Dlina2 (LAMBDA (LST)
      (REDUCE '(LAMBDA (n x) (+ n 1)) LST 0)
   ))
   ; -------------------------
   (DEFUN Dlina3 (LAMBDA (LST)
      (REDUCE '+ (MAPCAR '(LAMBDA (x) 1) LST))
   ))

   ; ******************************************************
   ; Функции, возвращают результат "переворачивания" списка
   ; ------------------------------------------------------
   (DEFUN Rev1 (LAMBDA (LST)
      (REDUCE '(LAMBDA (Lst x) (CONS x Lst))
              LST
              '()) 
   ))
   ; -----------------------
   (DEFUN Rev2 (LAMBDA (LST)
      (REDUCE '(LAMBDA (Lst x) (APPEND (LIST x) Lst))
              LST
              '()) 
   ))

   ; ****************************************************
   ; Функция, переводящая список битов в десятичное число
   ; ----------------------------------------------------
   (DEFUN Perevod (LAMBDA (Lst)
      (REDUCE '(LAMBDA (m n) (+ n (* 2 m))) Lst 0)
   ))

   ; **************************************************
   ; Функция, реализующая схему Горнера для  вычисления
   ; значения многочлена с коэффициентами, представлен-
   ; ными списком Lst, в точке x;
   ;
   ;  a0+a1*x+a2*x^2+...+an*x^n => Lst='(an ... a2 a1)
   ; -------------------------------------------------
   (DEFUN Gorner (LAMBDA (Lst x)
      (REDUCE '(LAMBDA (m n) (+ n (* x m))) Lst 0)
   ))

   ; ******************************************
   ; Моделирование функционала MAPCAR с помощью
   ; функционала REDUCE
   ; ---------------------------
   (DEFUN Mapf (LAMBDA (Fun Lst)
      (REDUCE 
         '(LAMBDA (L x) (APPEND L (LIST (APPLY Fun (LIST x)))))
         Lst
         '()
      )
   ))
   ; ******************************************
   ; Моделирование функционала Filter с помощью
   ; катаморфизма REDUCE
   ; ----------------------------------
   (DEFUN Filter (LAMBDA (Predicat LST)
      (REDUCE
         '(LAMBDA (Lst1 x) (COND ( (APPLY Predicat (LIST X))
                                      (APPEND Lst1 (LIST X)) )
                                 ( T  Lst1)))
         LST
         '()
      )
   ))
   ; ********************************************************
   ; Функция возвращает максимальный элемент из отрицательных
   ; элементов числового списка Lst
   ; (используются функционалы EVERY и REDUCE)
   ; -----------------------------------------
   (DEFUN Primer (LAMBDA (Lst)
      (COND ( (EVERY PLUSP Lst) -1)
            ( T (REDUCE MAX
                        (Filter '(LAMBDA (x) (< x 0)) Lst)) ))
   ))
   ; --------------------------------------------------------
   ; Функция возвращает сумму элементов матрицы, моделируемой
   ; списком списков числовых элементов
   ; ----------------------------------
   (DEFUN SumMatr (LAMBDA (Lst)
      (REDUCE '+ 
              (MAPCAR '(LAMBDA (Lst) (REDUCE '+ Lst 0)) Lst)
              0)
   ))

   ; ***************************
   ; Неудачные тестовые примеры:
   ; ---------------------------
   (AND
    (equal (Umn  '(1 2 3 4))  24)
    (equal (Summ '(1 2 3 4))  10)
    (equal (Naib '(2 3 4 1))   4)
    (equal (Naim '(2 3 4 1))   1)
    (equal (fact 0)            0)
    (equal (fact 1)            1)
    (equal (fact 2)            2)
    (equal (fact 3)            6)
    (equal (fact 5)          120)
   )
   (AND
    (equal (ANDF '( T T T))    T)   
    (equal (ORF  '( T T T))    T)
    (equal (ANDF '(NIL T T)) NIL)
    (equal (ORF  '(T T NIL))   T)
    (equal (ANDF '(NIL NIL)) NIL)
    (equal (ORF  '(NIL NIL)) NIL)
   )
   ; ------------------------------------------------
   (equal (APPENDF '(1 2 3 4) '(5 6)) '(1 2 3 4 5 6))
   (equal (APPENDF '(1 2 3 4) '())    '(1 2 3 4))
   (equal (APPENDF '() '(4 5))        '(4 5))
   ; ----------------------------------------
   (AND
    (equal (Dlina1 '(1 2 1 2))     4)
    (equal (Dlina2 '(1 2 1 2))     4)
    (equal (Dlina3 '(1 2 1 2 1 2)) 6)
   )
   (AND
    (equal (Rev1 '(1 2 3)) '(3 2 1))
    (equal (Rev2 '(1 2 3)) '(3 2 1))
   )
   (AND
    (equal (Perevod '(1 0 1 0 1 0 1 0)) 170)
    (equal (Perevod '(1 1 1 1 1 1 1 1)) 255)
   )
   (AND
    (equal (Mapf ADD1                  '(8 2 3 4)) '(9 3 4 5))
    (equal (Mapf CONS                  '(8 2 3 4)) '((8)(2)(3)(4)))
    (equal (Mapf '(LAMBDA (x) (+ x 9)) '(9 4))     '(18 13))
    (equal (Mapf '(LAMBDA (x) (* x x)) '(8 2 3 4)) '(64 4 9 16))
   )
   (AND
    (equal (Filter '(LAMBDA (x) (> x 0)) '(8 2 -3 4))    '(8 2 4))
    (equal (Filter evenp                 '(8 2 3 4 7 6)) '(8 2 4 6))
    (equal (Filter oddp                  '(8 2 3 4 7 6)) '(3 7))
    (equal (Filter numberp               '(8 a 3 b 7 b)) '(8 3 7))
   )
   ; --------------------------------
   (equal (Gorner '(3 2 1) 2)     17)
   (equal (Primer '(1 2 -3 4 -5)) -3)
   ; ---------------------------------------------
   (EQUAL (SumMatr '((1 2) (4 5)))             12)
   (EQUAL (SumMatr '((1 2 3) (4 5 6) (7 8 8))) 44)
   (EQUAL (SumMatr '((0 0) (0 0) (1 2)))        3)
   ; ---------------------------------------------
   (RDS)
