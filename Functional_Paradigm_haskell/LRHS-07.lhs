> import List
> import Random

    2ЛАБОРАТОРНАЯ РАБОТА 7.
    2ФУНКЦИОНАЛЫ-СВЁРТКИ НА СПИСКАХ

 ш1.0
               1- Ты ведёшь себя не как исчислитель, а как пиит.
               1Нержин не удивился 0: 1 и "математик" и "поэт" были заме-
               1нены по известному чудачеству Сологдина  говорить  на
               1так называемом Языке Предельной Ясности,  не употреб-
               1ляя  _птичьих ., то есть иностранных, слов. 0
                                        1А.Солженицын. В круге первом
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Вспомогательные понятия . 0:
 ш1.0
    1-  0" 1моноид 0",  1"паттерн рекурсии" 0.
 ш1.2

    _ 1Знать . 0:
 ш1.0
    1- понятие 0  1"свёртка" 0;
    1- 0  1функционалы свёртки справа  0  1на  списках   0( 1библиотека Prelude 0):
 1свёртка 0  1справа, свёртка справа на непустых списках 0;
    1- 0  1функционалы  0  1свёртки слева  на  списках   0( 1библиотека Prelude 0):
 1свёртка слева, свёртка слева на непустых списках 0;
    1- функционалы-конструкторы 0:  1scanl, scanl1, scanr, scanr1 0.
    1- сбалансированная свёртка 0;
    1- 0  1функционал развёртки на списках 0;
    1- теоремы двойственности для свёрток 0 ( _ 1без доказательства . 0).

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - применять функционалы свёртки для решения некоторых задач;
   - применять функционалы развёртки для решения некоторых задач.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                       2Вспомогательные понятия

 ш1.0
             1- Не понимаю, как можно жить, не прочитав Достоевского 0!
             1- Ну, жил же Пушкин 0!
                                                1Литературный анекдот
 ш1.2

                             21. 0  3Моноиды
   Пусть M - множество.
    2Определение 0.
 ш1.1
    2(1)  0[Голдблатт,1983,с.43]  _ 1Моноидом . 0 называется кортеж
 ш1.0

   (M,*, 3e 0),

 ш1.1
где *:M 52 0─ 76 0M,  причём отображение * является ассоциативным, т.е. для
любых x,y,z 7е 0M
 ш1.0

   x*(y*z)=(x*y)*z.                       ║  7А 0x,y,z(x*(y*z)=(x*y)*z)

 ш1.1
    _ 1Единицей моноида . 0 называется элемент  3e 7е 0M, такой, что для всех x 7е 0M
 ш1.0

    3e 0*x=x, x* 3e 0=x.                          ║  7Э 0x 7А 0y(x*y=y&y*x=y)

 ш1.1
    2(2) 0 [Лаллеман,1985,с.16]  _ 1Моноид . 0 <M, 77 0,1> - это множество M с  та-
кими  бинарной  операцией и выделенным элементом 1,  что (M, 77 0) есть
 1полугруппа с единицей 0 1.

 ш1.2
                        22. 0  3Паттерны рекурсии
   Вначале определим смысл термина " 1паттерн 0".
   По словам   1К.Александра 0 (см. [Гамма,Хелм,Джонсон,Влиссидес,2006,
с.16]), "любой  1паттерн 0 описывает задачу, которая снова и снова воз-
никает в вашей работе, а также принцип её решения, причём таким об-
разом, что это решение можно потом использовать миллион раз, ничего
не изобретая заново".
   Итак, смысл паттерна - предложить решение определённой задачи  в
конкретном контексте.
   Хотя К.Александр имел в виду паттерны,  возникающие при проекти-
ровании зданий и городов,  но его слова верны и в отношении паттер-
нов в программировании.
    2Определение 0.
 ш1.1
    _ 1Паттерном рекурсии . 0 (от англ.   1pattern - шаблон 0,   1примитив 0,  1обра-
 1зец 0) назовём описание взаимодействия функций и функционалов функци-
онального языка программирования,  адаптированных (приспособленных)
для  1рекурсивного решения 0 некоторой задачи в конкретном контексте.

 ш1.2
    3Замечания 0 ( 1важные 0).
 ш1.1
    21. 0 Фрагмент программы, который один программист воспринимает как
 1паттерн рекурсии 0,  для другого программиста может  являться  просто
 1строительным блоком 0.
    22.  0Свёртка - это не единственный полезный паттерн рекурсии.
   Например [Bird,de Moor,1997],  1двойственный оператор 0 используется
в целях спецификации.
    23. 0 Некоторые экспериментальные языки программирования  показыва-
ют, что использование паттернов рекурсии является более эффективным
способом использования рекурсивных функций.
   Среди них выделим:
   (а) язык программирования  2Charity 0 (Cockett & Fukushima,1992);
   (б) язык программирования PolyP (Jansson & Jeuring,1997);
   (в) алгебраический язык ADL (Kieburtz & Lewis,1994).
 ш1.2

                    2Функционалы свёртки в Prelude

 ш1.0
                                                1Стиль - это человек.
                                                   1Ж.Л.Бюффон 0 ( 11763 0)
 ш1.2

   Рассмотрим функционалы  языка программирования Haskell,  которые
являются паттернами рекурсии в функциональном  программировании;  к
таким функционалам относится " 1свёртка 0".
   Оператор свёртки  встречается  ещё  в теории рекурсивных функций
(С.Клини,1952), а также в языках программирования APL ( 1оператор ре-
 1дукции 0, К.Айверсон, 1962), и FP ( 1оператор вставки 0, Дж.Бэкус,1978).
    2Определение 0 (по [Кирпичёв,2009,с.156]).
 ш1.1
    _ 1Свёрткой . 0 ( 1в программировании 0) называется индуктивный процесс вы-
числения  _ 1снизу вверх . 0, применяющий в каждом узле некоторой  1структуры
 1данных 0  функцию,  соответствующую данному типу узла,  к содержимому
узла и результатам для его подузлов.

 ш1.2
   Приведём (неполный) список языков, в которых можно найти свертку
- непосредственно или с помощью дополнительных модулей и библиотек.
   Вместо слова fold в названиях функций и соответствующих операций
может употребляться reduce или accumulate:
 ш1.1
    2C++ 0 (std::accumulate),
    2Perl 5 0 (reduce),  2Perl 6 0 (reduction metaoperator),
    2Python 0 (reduce, functools.reduce),
    2Ruby 0 (enum.inject, enum.reduce);
    2Scala 0 (foldLeft, foldRight, reduceLeft, reduceRight),
    2Common 0  2Lisp 0 (reduce),
    2Scheme R6RS 0 (fold-left, fold-right),
    2Standard ML 0 (foldl, foldr),
    2OCaml 0 (List.fold_left, List.fold_right);
    2Clojure 0 (reduce),
    2Erlang 0 (foldl, foldr),
    2Maxima 0 (lreduce, rreduce).

 ш1.2
                          21. 3 Свёртка справа
                             3на списках
   Функционал (от англ.   3fold 0 -  1свёртка 0,  3r 1ight 0 -  1справа 0), "сворачи-
вающий" заданный список с использованием бинарной функции и началь-
ного значения (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr 0:: (a -> b -> b) -> b -> [a] -> b
    2foldr funct k lst

 ш1.2
   Например:
 ш1.0

   > foldr (+) 0 []        > foldr (-) 0 [1,2,3,4,5]
   0                       3

   > foldr (*) 4 [5,6,7]   > foldr min 10 [-1,2,13,-4,5]
   840                     -4

 ш1.2
   Название  1fold 3r 0 можно объяснить следующим образом.
   Рассмотрим список [a,b,c,d], который с помощью операции добавле-
ния элемента в начало списка запишем в виде
 ш1.0
   
   a:(b:(c:(d:[]))).

 ш1.2
   Функционал fold 3r 0 заменяет [] на некоторый начальный элемент e, а
операцию (:) на бинарную операцию, которую обозначим  7Х 0, и возвраща-
ет результат, т.е. она осуществляет следующее преобразование:
 ш1.0

   a:(b:(c:(d:[]))) => a  7Х 0 (b  7Х 0 (c  7Х 0 (d  7Х 0 e))).

 ш1.2
   Так как операция (:) ассоциативна справа, то скобки в первом вы-
ражении можно было бы опустить;  однако оставляем их в результирую-
щем выражении, т.к. операция  7Х 0 может быть неассоциативной справа.
   Итак,  1денотационная семантика 0 функционала fold 3r 0 представима либо
в инфиксной, либо в префиксной форме записи:
 ш1.0

    4┌ 0──────────────────────────────────────────────────────────── 4┐
   │ fold 3r 0 ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n 0  7Х 0 e)...)) │
    1│                                                            │ 0,
   │ fold 3r 0 f e [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n 0 e)...)) 1   0 │
    4└ 0───────────────────────────────────────────────────────── 1── 0─ 4┘

 ш1.2
где  7Х 0 - бинарная операция, f - функция с двумя аргументами, e - на-
чальное значение.
   Другими словами,  функционал foldr "сворачивает" список  в  одно
значение,  вставляя  1между 0 всеми элементами списка операцию  7Х 0, прод-
вигаясь при этом справа налево от заданного начального значения.
    2Пример 0.
 ш1.1
   Для списка, содержащего три элемента, последовательно получим:
 ш1.0

   fold 3r 0 ( 7Х 0) e [] = e 4,

   fold 3r 0 ( 7Х 0) e [x 41 0] = x 41 0  7Х 0 e,

   fold 3r 0 ( 7Х 0) e [x 41 0,x 42 0] = x 41 0  7Х 0 (x 42 0  7Х 0 e),

   fold 3r 0 ( 7Х 0) e [x 41 0,x 42 0,x 43 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (x 43 0  7Х 0 e)).

 ш1.2
   Функционал " 1свёртка справа 0" для списков определён так:
 ш1.0

   foldr:: (a -> b -> b) -> b -> [a] -> b
   foldr f e []     = e
   foldr f e (x:xs) = f x (foldr f e xs)

 ш1.2
   Итак, fold 3r 0 f v, с  помощью  функции f :: a -> b -> b и значения
e :: b, обрабатывает список типа [a].
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Если операция  7Х 0 и функция e образуют  1моноид 0, то
 ш1.0

   fold 3r 0 ( 7Х 0) e []             = e;
   fold 3r 0 ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 7Х 0x 42 7Х 0... 7Х 0x 4n 0.

 ш1.2
    2Доказательство 0. Так  как операция  7Х 0 и функция e образуют моноид,
то x 4n 0  7Х 0 e = x 4n 0, поэтому
 ш1.0

   fold 3r 0 ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0]
       = ( 7Х 0) x 41 0  2( 0( 7Х 0) x 42 0  2( 0...  2( 0( 7Х 0) x 4n-1 0  2( 0( 7Х 0) x 4n 0 e 2)) 0... 2)) 0 =
       = ( 7Х 0) x 41 0  2( 0( 7Х 0) x 42 0  2( 0...  2( 0( 7Х 0) x 4n-1 0 x 4n 2) 0... 2)) 0 = x 41 7Х 0x 42 7Х 0... 7Х 0x 4n 0.

 ш1.2
    1Теорема доказана 0.
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
    2(1) 0 Если  операция   7Х 0 и функция e образуют  1моноид 0,  то для любых
списков xs и ys
 ш1.0

   fold 3r 0 ( 7Х 0) e (xs ++ ys) = (fold 3r 0 ( 7Х 0) e xs)  7Х 0 (fold 3r 0 ( 7Х 0) e ys).

 ш1.1
    2(2) 0 Для  1произвольных 0 f и e и для любых списков xs и ys
 ш1.0

   fold 3r 0 f e (xs ++ ys) = fold 3r 0 f (fold 3r 0 f e ys) xs.

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Пример 0 (" 1доказательства 0").
 ш1.0

> xs = [5.0,2.0..1.0]; ys = [7.0,2.0..2.0]
> f = (/)
> test1 = (foldr f 2 (xs ++ ys), foldr f (foldr f 2 ys) xs)

 ш1.2
    3Замечание 0.
 ш1.1
   В языке программирования  2Python 0  работа  с  функционалом свёртка
синтаксически выглядит так (с использованием безымянных функций):
 ш1.0

   >>> reduce(lambda x,y: x+y,[1,2,3],0)
   6

 ш1.2
                        22. 3 Свёртка справа на
                          3непустых списках 0
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве начального значения берёт пер-
вый элемент списка (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr1 0:: (a -> a -> a) -> [a] -> a
    2foldr1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldr1 (-) [1,2,3,4,5]      > foldr1 (*) [5,6,7]
   3                             210

   > foldr1 min [-1,2,-13,-4,5]
   -13

 ш1.2
   Итак,  1денотационная семантика 0 функционала fold 3r 01 представима ли-
бо в инфиксной, либо в префиксной форме записи:
 ш1.0

    4┌ 0────────────────────────────────────────────────────────────── 4┐
   │ fold 3r 01 ( 7Х 0) [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n-1 0  7Х 0 x 4n 0)...)) │
    1│                                                              │ 0,
   │ fold 3r 01 f [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n-1 0 x 4n 0)...))  1   0│
    4└ 0─────────────────────────────────────────────────────────── 1── 0─ 4┘

где  7Х 0 - бинарная операция, f - функция с двумя аргументами.

 ш1.2
    3Замечание 0 ( 1для знатоков нумералов в  7l 1-исчислении 0).
 ш1.1
   Представление натурального числа в  7l 0-исчислении неявно использу-
ет свёртку.
   Например, число 3 представляется  7l 0-термом f (f (f 0)) или в язы-
ке Haskell
 ш1.0

   succ (succ (succ 0)).

 ш1.1
   Последняя функция представима следующей свёрткой:
 ш1.0

   nat n = foldr1 f (replicate 1 n)
              where f = const . succ

 ш1.2
                          23. 3 Свёртка слева
                             3на списках
   Функционал (от англ.  3fold 0 -  1свёртка 0,  3l 1eft 0 -  1слева 0), "сворачиваю-
щий" заданный список с использованием бинарной функции и начального
значения (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl 0:: (a -> b -> a) -> a -> [b] -> a
    2foldl funct k lst

 ш1.2
   Например:
 ш1.0

   > foldl (+) 0 []        > foldl (-) 0 [1,2,3,4,5]
   0                       -15

   > foldl (*) 4 [5,6,7]   > foldl max 10 [-1,2,13,-4,5]
   840                     13

 ш1.2
    1Денотационная семантика 0 функционала fold 3l 0 такова:
 ш1.0

    4┌ 0──────────────────────────────────────────────────────────── 4┐
   │ foldl ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = (...((e  7Х 0 x 41 0)  7Х 0 x 42 0) ...)  7Х 0 x 4n 0 │,
    4└ 0──────────────────────────────────────────────────────────── 4┘

 ш1.2
где  7Х 0 - бинарная операция, e - начальное значение.
    2Пример 0.
 ш1.1
   Разберём подробно процесс применения fold 3l 0 к заданному списку:
 ш1.0

   foldl ( 7Х 0) e [a,b,c] = foldl ( 7Х 0) (e  7Х 0 a) [b,c] =
                       = foldl ( 7Х 0) ((e  7Х 0 a)  7Х 0 b) [c] =
                       = foldl ( 7Х 0) (((e  7Х 0 a)  7Х 0 b)  7Х 0 c) [] =
                       = ((e  7Х 0 a)  7Х 0 b)  7Х 0 c).

 ш1.2
   В языке Haskell функционал " 1свёртка слева 0" для списков определён
следующим образом:
 ш1.0

   foldl:: (b -> a -> b) -> b -> [a] -> b
   foldl f e []     = e
   foldl f e (x:xs) = foldl f (f e x) xs

 ш1.2
   Итак, foldl f e обрабатывает элементы списка  типа [a]  _ 1слева на-
 _ 1право . 0 с  использованием  функции  f :: b -> a -> b (для объединения
значений), и значение e :: b в качестве начального значения.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    3Замечание 0 ( 1для знатоков первой теоремы двойственности 0).
 ш1.1
   Если e  -  ассоциативная единица для операции  7Х 0,  то функционалы
fold 3r 0 ( 7Х 0) e и fold 3l 0 ( 7Х 0) e определяют одну и ту же функцию на конеч-
ных списках.

 ш1.2
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
   Для  1произвольных 0 f и e и для любых списков xs и ys
 ш1.0

   fold 3l 0 f e (xs ++ ys) = fold 3l 0 f (fold 3l 0 f e xs) ys

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Пример 0 ( 1примитивное тестирование 0).
 ш1.0

> xs' = [5.0,2.0..1.0]; ys' = [7.0,2.0..2.0]
> f'  = (/)
> test2  = (foldl f' 2 (xs' ++ ys'), foldl f' (foldl f' 2 xs') ys')
> test2' = (foldl f' 2 (xs' ++ ys'), foldl f' (foldr f' 2 xs') ys')

 ш1.2
                         24. 3 Свёртка слева на
                          3непустых списках
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве начального значения берёт пер-
вый элемент списка (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl1 0:: (a -> a -> a) -> [a] -> a
    2foldl1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldl1 (-) [1,2,3,4,5]       > foldl1 (*) [5,6,7]
   -13                            210

   > foldl1 min [-1,2,-13,-4,5]
   -13

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Функционал свёртки представляет собой  1паттерн рекурсии 0,  поэтому
для других рекурсивно определённых структур данных достаточно заме-
нить конструкторы [] и (:) другими значениями и функциями.

 ш1.2
    2Пример 0.
 ш1.1
   Построим функцию,  которая  позволяет  проследить  за  процессом
конструирования результата выполнения правых и левых свёрток:
 ш1.0

> paren :: String -> String -> String
> paren x y = concat ["(",x," * ",y,")"]
> ------------------------------------------
> test3 = foldr  paren "1" ["a","b","c","d"]
>                                    == "(a * (b * (c * (d * 1))))"
> test4 = foldl  paren "1" ["a","b","c","d"]
>                                    == "((((1 * a) * b) * c) * d)"
> test5 = foldr1 paren     ["a","b","c","d"]
>                                    == "(a * (b * (c * d)))"
> test6 = foldl1 paren     ["a","b","c","d"]
>                                    == "(((a * b) * c) * d)"

 ш1.2

                      2Функционалы-конструкторы

 ш1.0
            1В области мысли,  при постоянном умственном общении вряд
            1ли  можно  точно разграничить,  что принадлежит одному и
            1что другому.  Зато каждый имеет удовлетворение и радость
            1сознавать своё участие в общем результате.
                 1И.П.Павлов. Из предисловия к книге "Лекции о работе
                             1больших полушарий головного мозга"
 ш1.2

   Приведём функционалы из библиотеки Prelude,  с  помощью  которых
легко описывается операционная семантика функционалов-свёрток и ко-
торые иногда называются  _ 1префиксными суммами . 0 или  _ 1бегущими  свёртками
(кстати,  отсюда возникают термины " 1бегущая сумма 0",  " 1бегущий мини-
 1мум 0" и т.п.).
                    21. 3 Функционалы scanl и scanl1
    2А. 0 Функционал 2  0scanl (англ.  1scan 0 - " 1сканировать, бегло просматри-
 1вать 0") применяет бинарный оператор к начальному значению и к каждо-
му последующему элементу заданного списка, формируя при этом список
промежуточных результатов:
 ш1.0

    2scanl 0:: (a -> b -> a) -> a -> [b] -> [a]
    2scanl 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanl (+) 0 [1,2,3,4,5]           > scanl (*) 2 [5,6,7]
   [0,1,3,6,10,15]                     [2,10,60,420]

   > scanl min (-5) [-1,2,-13,-4,-6]
   [-5,-5,-5,-13,-13,-13]

 ш1.2
   Функционал scanl определяется следующим образом:
 ш1.0

    3scanl 0 _ x0 []     = [x0]
    3scanl 0 f x0 (x:xs) = x0 :  3scanl 0 f (f x0 x) xs

 ш1.2
    2Теорема 0.
 ш1.0

    2(1) 0 last . scanl f e = foldl f e;

    2(2) 0 [Bird,1998,p.124]
       scanl f e = map (foldl f e) . inits

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Б. 0 Функционал scanl1 применяет бинарный оператор к "голове"  за-
данного  непустого  списка  и  к каждому последующему его элементу,
формируя при этом список промежуточных результатов:
 ш1.0

    2scanl1 0:: (a -> a -> a) -> [a] -> [a]
    2scanl1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanl1 (+) [1,2,3,4,5]   > scanl1 (*) [5,6,7]
   [1,3,6,10,15]              [5,30,210]

   > scanl1 min [-1,2,-13,-4,-6]
   [-1,-1,-13,-13,-13]

 ш1.2
   Функционал scanl1 определяется следующим образом:
 ш1.0

    3scanl1 0 _ []     = []
    3scanl1 0 f (x:xs) =  3scanl 0 f x xs

 ш1.2
                    22. 3 Функционалы scanr и scanr1
    2А. 0 Функционал scanr применяет  бинарный  оператор  к  начальному
значению и к каждому последующему элементу заданного списка;  полу-
ченный результат записывается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту "хвоста" списка. Результат также записывается в список.
   Процесс продолжается  до  тех  пор,  пока хвост списка не станет
пустым; в этом случае возвращается исходное начальное значение:
 ш1.0

    2scanr 0:: (a -> b -> b) -> b -> [a] -> [b]
    2scanr 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanr (+) 0 [1,2,3,4,5]            > scanr (*) 2 [5,6,7]
   [15,14,12,9,5,0]                     [420,84,14,2]

   > scanr min (-5) [-1,2,-13,-4,-6]    > scanr (-) 0 [1,2,3,4,5]
   [-13,-13,-13,-6,-6,-5]               [3,-2,4,-1,5,0]

 ш1.2
   Функционал scanr определяется следующим образом:
 ш1.0

    3scanr 0 _ x0 []     = [x0]
    3scanr 0 f x0 (x:xs) = f x x' : (x' : xs')
          where (x':xs') =  3scanr 0 f x0 xs

 ш1.2
    2Теорема 0 [Bird,1998,p.125].
 ш1.0

   scanr f e = map (foldr f e) . tails

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Б. 0 Функционал scanr1 применяет бинарный  оператор  к  последнему
элементу  заданного  непустого  списка и к каждому последующему его
элементу,  начиная с предпоследующего. Полученный результат записы-
вается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту хвоста списка и результаты также записываются в список.
   Процесс продолжается до тех пор, пока хвост списка не станет од-
ноэлементным; в этом случае возвращается оставшийся элемент списка:
 ш1.0

    2scanr1 0:: (a -> a -> a) -> [a] -> [a]
    2scanr1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanr1 (+) [1,2,3,4,5]        > scanr1 (*) [5,6,7]
   [15,14,12,9,5]                  [210,42,7]

   > scanr1 min [-1,2,-13,-4,-6]
   [-13,-13,-13,-6,-6]

 ш1.2
   Функционал scanr1 определяется следующим образом:
 ш1.0

    3scanr1 0 _ []     = []
    3scanr1 0 _ [x0]   = [x0]
    3scanr1 0 f (x:xs) = f x x' : (x' : xs')
          where (x':xs') =  3scanr1 0 f xs

 ш1.2
    2Пример 0.
 ш1.1
   Построим функцию,  которая  позволяет  проследить  за  процессом
конструирования результата выполнения "бегущих свёрток":
 ш1.0

> paren' :: String -> String -> String
> paren' x y = concat ["(",x," * ",y,")"]
> ---------------------------------------
> test7  = scanr paren' "1" ["a","b","c"]
>          == ["(a * (b * (c * 1)))","(b * (c * 1))","(c * 1)","1"]
> test8  = scanl paren' "1" ["a","b","c"]
>          == ["1","(1 * a)","((1 * a) * b)","(((1 * a) * b) * c)"]
> -----------------------------------------------------------------
> test9  = scanr1 paren' ["a","b","c"]
>                                == ["(a * (b * c))","(b * c)","c"]
> test10 = scanl1 paren' ["a","b","c"]
>                                == ["a","(a * b)","((a * b) * c)"]

 ш1.2
   Фактически функционалы  scanl и scanr реализуют своеобразную  1ме-
 1моизацию 0.
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Мемоизация . 0 [Орлов,2013,с.91] - это специальная оптимизацион-
ная методика программирования, которая позволяет увеличить скорость
выполнения компьютерных программ и заключающаяся в том,  чтобы иск-
лючить повторное вычисление результатов предыдущих вызовов процедур
и функций.
    2(2) 0  _ 1Мемоизация . 0 [Марков,2016,с.138] - это способ увеличения  ско-
рости выполнения  программ за счёт запоминания результатов промежу-
точных вычислений.  Такой способ работает тогда, когда одни и те же
промежуточные результаты  неоднократно требуются при дальнейших вы-
числениях. Мемоизация,  как правило,  используется в реализации ре-
курсивных вычислений.
 ш1.2

                       2Функционал "развёртка"

 ш1.0
                    1Глаз должен выучиться видеть, как язык говорить.
                                                             1Д.Дидро
 ш1.2

                       21. 3 Основные определения
   Функционал " 1развёртка 0" охватывает достаточно общий образец гене-
рации списков 1.
    2Определение 1 0.
 ш1.1
    _ 1Функционал . 0 " _ 1развёртка . 0" определяется следующим паттерном рекурсии:
 ш1.0

   unfold:: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
   unfold p f g x | p x  = []
                  | True = f x : unfold p f g (g x)

   Другими словами,

   head $ unfold p f g x = f x,
   tail $ unfold p f g x = unfold p f g (g x),
   null $ unfold p f g x = p x.

 ш1.2
   Опишем шутливо  _ 1операционную семантику . 0 функционала: на каждом ша-
ге функция unfold "скармливает" предикату p  аргумент  x,  а  потом
спрашивает:  "Понравилось?".  Если "понравилось" (функция p вернула
True), то "кормёжка" прекращается и возвращается пустой список.
   Если же  "не понравилось" (функция p вернула False),  то функция
возвращает результат (f x) и "заказывает",  чем её "кормить" в сле-
дующий раз (т.е. вычисляет g x).
   Затем unfoldr собирает результаты в список и возвращает его.
    2Пример 0.
 ш1.1
   Представим процесс вычисления значения функции
 ш1.0

   enum n m = unfold (>m) id succ

 ш1.1
для значений аргументов n=1, m=3 в виде следующего рисунка:
 ш1.0

               1 ───── 76 0 2 ───── 76 0 3 ───── 76 0 4 ───── 76 0 []
               │   51>3 0   │   52>3 0   │   53>3 0       54>3
    1Полученный 0   7^ 1  0        7^ 0         7^
      1список 0     21 0         22 0         23

 ш1.2
    2Теорема 0 (по [Bird,Wadler,1988,p.173]).
 ш1.0

    3unfold 0 p f g =  3map 0 f .  3takeWhile 0 (not . p) .  3iterate 0 g

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5 41 0.

 ш1.2
    2Теорема 0 ( 1универсальное свойство unfold 0) [Gibbons,2003,p.45].
 ш1.0

    3h 0 =  3unfold 0 p f g <=>  3h 0 x | p x  = []
                            | True = f x :  3h 0 (g x)

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Теорема 0 ( 1свойство объединения unfold, fusion law 0)
           (по [Gibbons,2003,p.45,  1исправлено 0]).
 ш1.0

   p . h = p',  f . h = f',  g . h = g'

             =>  3unfold 0 p f g . h =  3unfold 0 p' f' g'.

 ш1.2
    2Доказательство 0. Вспомним определение развёртки
 ш1.0

    3unfold 0 p f g x | p x  = []
                  | True = f x :  3unfold 0 p f g (g x)

 ш1.2
и рассмотрим два случая:
   (1) p x = []:
 ш1.1

    3unfold 0 p f g (h x) => p (h x) = (p . h) x = [],
    3unfold 0 p' f' g' x =>  p' x    = [].

 ш1.2
   Значения предикатов равны, т.к. по условию  _p . h = p' .;
   (2) p (h x)  7- 0 [], p' x = p (h x)  7- 0 []:
 ш1.1

    3unfold 0 p  f  g (h x) = f (h x) :  3unfold 0 p  f  g  (g (h x)),
    3unfold 0 p' f' g'  x   = f' x    :  3unfold 0 p' f' g' (g' x),

 ш1.2
   Значения развёрток равны, т.к. по условию
 ш1.0

    _f . h = f' . => f (h x) = f' x,   _g . h = g' . => g (h x) = g' x

 ш1.2
    1Теорема доказана 0.
   Определим функционал  " 1развёртка 0"  с  помощью паттерна рекурсии,
использующего функцию, называемую  _ 1конструктором пары . 0.
    2Определение 2 0.
 ш1.0

   unfold':: (a -> Bool) -> (a -> (b,a)) -> a -> [b] 
   unfold' p fg x | p x  = []
                  | True = fx : unfold' p fg gx
       where (fx,gx) = fg x

 ш1.1
   Другими словами,
 ш1.0

   fg = \x -> (f x, g x)

 ш1.1
где элементы списка порождаются функцией f,  а начальный элемент  x
преобразуется функцией g.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5 42 0.

 ш1.2
                       22. 3 Обобщение развёртки
   Рассмотрим следующее обобщение функционала " 1развёртка 0":
 ш1.0

    3ana 0 q r p f g x = if p x
                       then r x
                       else q (f x) ( 3ana 0 q r p f g (g x))

 ш1.2
   Установим представления свёртки и развёртки на списках с помощью
указанного выше обобщения.
 ш1.0

   fold 3r 0 f e =  3ana 0 f (\x -> e) null head tail

   unfold    =  3ana 0 (:) (\x -> [])

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Имеют место следующие  1эквациональные утверждения 0:
 ш1.0

    2(1) 0 fold 3r 0 f e =  3ana 0 f (\x -> e) null head tail.

    2(2)  0unfold    =  3ana 0 (:) (\x -> []).

 ш1.2
    2Доказательство 0.
 ш1.0

    21. 0  3ana 0 f (\x -> e) null head tail x =
       = if null x
           then (\x -> e) x
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = if null x
           then e
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = fold f e,

где fold f e x = if null x
                   then e
                   else f (head x) (fold f e (tail x)).

    22. 0  3ana 0 (:) (\x -> []) p f g x =
            = if p x
                then (\x -> []) x
                else (:) (f x) ( 3ana 0 (:) (\x -> []) p f g (g x)) =
            = if p x
                then []
                else f x :  3ana 0 (:) (\x -> []) p f g (g x) =
            = unfold p f g x.

 ш1.2
    1Теорема доказана 0.

                      3Сбалансированная свёртка

 ш1.0
               1Часть работы программиста состоит в том, чтобы решать
               1сегодняшние  задачи.  Другая,  возможно более важная,
               1состоит в подготовке к решению завтрашних задач. 0
                                                          1Дж. Бентли
 ш1.2

   Для ассоциативных операций результаты вычисления выражений
 ш1.0

   fold 3r 01 (+) [a 41 0...a 4n 0] = a 41 0+(a 42 0+...+(a 4n-1 0+a 4n 0)...),

   fold 3l 01 (+) [a 41 0...a 4n 0] = (...(a 41 0+a 42 0)+...)+a 4n

 ш1.2
совпадают (по  1первой теореме двойственности 0).
   Более того, расставляя скобки произвольным образом, мы будем по-
лучать все тот же результат.
   Другими словами,  можно абстрагироваться от порядка вычислений и
говорить об "абстрактной" свертке как о результате выражения
 ш1.0

   fold (+) [a 41 0...a 4n 0] = a 41 0 + a 42 0 +...+ a 4n

 ш1.2
безотносительно к порядку выполнения операций.
   Теперь конкретизируем эту абстракцию, установив определённый по-
рядок вычислений.
    2Определение 0.
 ш1.1
    _ 1Сбалансированной . 0 ( _ 1древесной . 0)  _ 1свёрткой . 0 назовём свёртку,  произво-
дящую вычисления в следующем порядке:
 ш1.0

   fold 3b 0 (+) [a 41 0...a 4n 0] = (...((a 41 0+a 42 0)+(a 43 0+a 44 0))+(...(a 4n-1 0+a 4n 0)...).

 ш1.2
   Сбалансированную свёртку можно  выполнять  в  двух  направлениях
(приведём коды на языке Haskell):
   (а)  _ 1сверху вниз . 0:
 ш1.0

   foldb f [x] = x
   foldb f xs  = f (foldb f (take (length xs `div` 2) xs))
                   (foldb f (drop (length xs `div` 2) xs))

 ш1.2
   (б)  _ 1снизу вверх . 0:
 ш1.0

   foldb' f [x] = x
   foldb' f xs  = foldb' f (pair f xs)
   -----------------------------------
   pair f []         = []
   pair f [x]        = [x]
   pair f (x1:x2:xs) = f x1 x2 : pair f xs

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6.

                       3Теоремы двойственности
                             3для свёрток

 ш1.0
                1Планируя грядки на следующую весну, учтите главное -
                1там, где росли вершки, посадите корешки, и наоборот.
                                                        1Дачный совет
 ш1.2

   Приведём без доказательства три теоремы двойственности для свёр-
ток (эти теоремы  _ 1будут доказаны . 0 ниже).
   Используя эти теоремы,  можно выразить с  помощью  fold 3l 0  многие
функции, тем самым увеличивая их эффективность.
    2Теорема 0 ( 1первая теорема двойственности 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операция  7Х 0 и функция e образуют  1моноид 0, xs - конечное  1  0мно-
жество, то
 ш1.0

   fold 3r 0 ( 7Х 0) e xs = fold 3l 0 ( 7Х 0) e xs.

 ш1.2
   Другими словами, свёртки fold 3r 0 и fold 3l 0 на моноиде определяют од-
ну и ту же функцию.
   Однако иногда более эффективным является использование fold 3r 0,  а
иногда - fold 3l 0.
   Например, более эффективно использование fold 3l 0 для представления
функций sum и product, а для представления функций concat, and и or
использование fold 3r 0 более эффективно.
    2Теорема 0 ( 1вторая теорема двойственности 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операции  7Х 0,  7х 0 и функция e таковы, что
 ш1.0

   (а)  7А 0x 7А 0y 7А 0z(x 7Х 0(y 7х 0z)=(x 7Х 0y) 7х 0z);  (б)  7А 0x(x 7Х 0e=e 7х 0x),

то для любых конечных списков xs

   fold 3r 0 ( 7Х 0) e xs = fold 3l 0 ( 7х 0) e xs.

 ш1.1
   При этом  7Х 0 и  7х 0 называются  _ 1функциями, ассоциативными относительно
 _ 1друг друга . 0.

 ш1.2
    2Пример 0 ( 1иллюстрация второй теоремы 0).
 ш1.1
   Рассмотрим определения  функций length и reverse с помощью функ-
ционалов fold 3r 0 и fold 3l 0:
 ш1.0

   reverse' = fold 3r 0  7Х 41 0 e           ║  reverse' = fold 3l 0  7х 41 0 e
      where  7Х 41 0 = \x xs -> xs++[x]  ║     where  7х 41 0 = \ys x -> x:ys
            e 41 0 = []                ║           e 41 0 = []
                                   ║
   length' = fold 3r 0  7Х 42 0 e            ║  length' = fold 3l 0  7х 42 0 e
      where  7Х 42 0 = \x n -> n + 1     ║     where  7х 42 0 = \n x -> n + 1
            e 42 0 = 0                 ║           e 42 0 = 0

 ш1.1
   Очевидно, что
 ш1.0

    7Х 41 0  ═+ 0 (++),  7х 41 0  ═+ 0 flip (:),  7Х 42 0  ═+ 0 (+),  7х 42 0  ═+ 0 (+), e 41 0  ═+ 0 [], e 42 0  ═+ 0 0,

поэтому остаётся проверить выполнимость условий второй теоремы:

   x 7Х 41 0(y 7х 41 0z)=(x 7Х 41 0y) 7х 41 0z => flip (:) (x++y) z = flip (:) (x++y) z =>

        => z : (x++y) = z : (x++y);

   x 7Х 41 0e 41 0=e 41 7х 41 0x => x++[] = flip (:) [] x => x++[] = x:[] => x = x;

   x 7Х 42 0(y 7х 42 0z)=(x 7Х 42 0y) 7х 42 0z => x+(y+z)=(x+y)+z => x+y+z=x+y+z,

   x 7Х 42 0e 42 0=e 42 7х 42 0x => x+0=0+x.

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Первая теорема двойственности следует из второй, если операции  7Х
и  7х 0 совпадают.

 ш1.2
    2Теорема 0 ( 1третья теорема двойственности 0)
           [Bird,Wadler,1988,p.68-69].
 ш1.1
   Если  7Х 0 и  7Х 0~ - операции, удовлетворяющие условию x 7Х 0~y=y 7Х 0x, то для
любого конечного списка xs
 ш1.0

   fold 3r 0 ( 7Х 0) e xs = fold 3l 0 ( 7х 0~) e (reverse xs).

 ш1.2
    2Пример 0 ( 1иллюстрация третьей теоремы 0).
 ш1.1
   Рассмотрим определения функции plusPlus с помощью foldr и foldl:
 ш1.0

   plusPlus = flip $ fold 3r 0 (:),                               (*)

   plusPlus xs ys = fold 3l 0 (flip (:)) ys (reverse xs).         (**)

 ш1.1
   Выполним эквивалентные преобразования равенства  (*)  с  помощью
алгебры комбинаторов:
 ш1.0

   plusPlus xs ys = flip $ fold 3r 0 (:) xs ys =
                  = flip (fold 3r 0 (:)) xs ys = fold 3r 0 (:) ys xs.

 ш1.1
   Сравнивая полученный результат с равенством (**), получим:
 ш1.0

    7Х 0  ═+ 0 (:),  7Х 0  ═+ 0 flip (:).

 ш1.1
   Остаётся проверить выполнимость условия третьей теоремы:
 ш1.0

   x 7Х 0~y=y 7Х 0x => x:y = flip (:) y x = x:y.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                                       1Раз - везение, два - везение,
                                       1надобно и умение.
                                                         1А.В.Суворов
 ш1.2

                       21. 3 Функционалы свёртки
    21 4* 2. 0 Вычислите значения выражений и проверьте результат в HUGS 98:
 ш1.0

   (1) foldl (/) 480 [3,2,5,2];  (2) foldr (/) 2 [8,12,24,4].

 ш1.2
    22 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (1) test1      = foldr (+) 0 [1..10]
   (2) test2      = foldr (+) 0
   (3) test3      = foldr (*) 1
   (4) test4 lst  = foldr max (head lst) (tail lst)
   (5) test5 elem = (.) (foldr (||) False) (map (== elem))

   (6) test6 lst  = take (toInt (len lst `div` 2)) lst
          where len = foldr (\z -> \n -> n+1) 0

   (7) test7 = map fact
          where fact n = foldl1 (*) [1..n]
   (8) test8 = map (length . show . (scanl (*) 1 [1..] !!))

   (9) test9 x = sum $ map (\k -> power sin k x) [1..50]
          where power f 0     = id           
                power f (n+1) = f . power f n

   (10) test10 m n = takeWhile (<=n) $ iterate (+ 1) m

   (11) [Bird,Wadler,1988,p.172]
        group n = map (take n) . takeWhile (/=[])
                               . iterate (drop n)
   (12) [Bird,Wadler,1988,p.172]
        digits  = reverse . map (`mod` 10) . takeWhile (/=0)
                                           . iterate (`div` 10)

 ш1.2
    23. 0 Известно, что свёртка foldr приспособлена для работы с беско-
нечными списками:
 ш1.0

   > head $ (foldr (\x xs -> (x + pi) : xs) [] ) [1..]
   4.141592653589793

 ш1.2
   Однако иногда возникают неприятности.
   Например, рассмотрим функцию, которая удаляет из заданного спис-
ка элементы, расположенные на нечётных местах:
 ш1.0

   evenOnly = snd . foldr (\x (os,es) -> (x : es,os)) ([],[])

   > evenOnly [1..10]
   [2,4,6,8,10]

 ш1.2
   Однако на бесконечном списке её поведение становится  1странным 0:
 ш1.0

   > head $ evenOnly [1..]
   Interrupted.

 ш1.2
   Почему это происходит, и какие минимальные изменения можно в неё
внести, чтобы восстановить утраченную работоспособность?
    24 5* 2. 0 ( 1Для знатоков произвольных бинарных деревьев 0.)
   Постройте  1произвольное бинарное дерево 0, корень и внутренние вер-
шины  которого  помечены буквой "f",  а листья - буквами "e",  "1",
"2", "3",...,"9", и такое, что с его помощью можно было иллюстриро-
вать процесс вычислений с помощью функционалов свёртка и функциона-
лов-конструкторов (" 1скользящей свёртки 0").
                      22. 3 Функционалы развёртки
    21 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (1) test1      = unfold (\x -> False) id succ 1
   (2) test2     = unfold (== 0) id (\x -> x-1)
   (3) test3     = unfold (\x -> False) id id
   (4) test4     = unfold null last init
   (5) test5 f   = unfold null (f . head) tail
   (6) test6 f x = x : unfold (\x -> False) f f x
 ш1.2
