    2ЛАБОРАТОРНАЯ РАБОТА 6.
    2ФУНКЦИОНАЛЫ (функции высшего порядка)

 ш1.0
                1И за всем тем нас ждёт ещё "новое слово" ... но, бо-
                1же мой! сколько же есть прекрасных и вполне испытан-
                1ных старых слов,  которых мы даже не пытались произ-
                1нести,  как  уже хвастливо выступаем с чем-то новым,
                1которое мы, однако ж, не можем даже определить 0!
                                                 1М.Е.Салтыков-Щедрин
 ш1.2

    _ 1Знать . 0:
 ш1.0
   - понятия " 1аппликативный стиль программирования 0" и " 1функциональ-
 1ный стиль программирования 0";
   - понятие " 1функционал  0( 1функция высшего порядка 0)";
   - синтаксис  и  семантику стандартных функционалов из библиотеки
Prelude;
   - синтаксис  и  семантику  функционала  для организации итерации
(функционал iterate);
   - понятия: " 1каррирование 0", " 1каррированная функция 0";
   - функции и функционалы для работы со списками из модуля List;
   - алгебраические тождества для функционалов;
    1- 0 понятие " 1голофрастическая конструкция языка 0".

    _ 1Уметь . 0:
   - использовать функционалы для "быстрого" (но неэффективного)  и
"нерекурсивного" решения задач, связанных с обработкой списков;
   - пользоваться функционалом iterate.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                      3О стилях программирования
   Будем различать  1аппликативное 0 и  1функциональное программирование 0.
    _ 1Аппликативный стиль . 0  основан  на  использовании  при  построении
текста программы понятий " 1функция 0" и " 1аппликация 0" (применение функ-
ции); функционалы при этом моделируются.
    _ 1Функциональный стиль . 0  основан на использовании понятий " 1функция 0"
и " 1функционал 0"; функционалы при этом уже заданы. Это программирова-
ние  не  нуждается  в использовании переменных,  поэтому вычисления
осуществляются применением функционалов к функциям и значениям.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Вне зависимости  от  используемого  стиля  применение исчисления
комбинаторов к функционалам  позволяют  осуществлять  эквивалентные
(по семантике) преобразования программ.

 ш1.2
                        3Понятие "функционал"
    2Определение 0.
 ш1.1
    2(1) 0 [Математический,1995]   _ 1Функционалом . 0 называется  1отображение 0 f
произвольного множества X в множество  ═R 0 действительных или  ═C 0  комп-
лексных чисел.
    2(2) 0 [Хелемский,2004,с.18]  _ 1Функционал . 0 - это оператор со значения-
ми в поле скаляров.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 Термин " 1функционал 0" введён Ж.Адамаром (1903).
    22. 0 В математической литературе термины " 1оператор 0" и " 1функционал 0"
часто используются как синонимы.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Функционал . 0 ( 1в функциональном программировании 0) - это функция:
   (1) либо имеющая  _ 1функциональный аргумент . 0,  т.е. аргумент, значе-
нием которого является функция;
   (2) либо возвращающая функцию в качестве результата.

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   За счёт частичного применения в языке Haskell все функции, кото-
рые имеют более одного аргумента, являются функционалами (функциями
высшего порядка).

 ш1.2
                     3Классификация функционалов
    2Определение 0 [Хювенен,Сеппянен,1990].
 ш1.1
    2(1) 0  _ 1Аппликативными . 2  0( _ 1применяющими . 0) 2  _ 1функционалами . 0  называют  функ-
ции, которые позволяют вызывать другие функции.
   Другими словами,  аппликативные функционалы  применяют  функцио-
нальный аргумент к своим формальным параметрам.
    2(2) 0  _ 1Отображающие функционалы . 0 ( 1MAP- _функции . 0) 2  0- это функции,  кото-
рые  отображают исходный список в новый список или порождают побоч-
ный эффект, связанный с исходным списком.
    2(3) 0  _ 1Объединяющие функционалы . 0 - это функции,  которые  объединяют
соответствующие элементы двух или более списков-аргументов в  соот-
ветствии с заданной функцией, которая также является формальным па-
раметром функционала.
    2(4) 0  _ 1Функционалы планирования функций . 0 - предикаты,  которые  осу-
ществляют выполнение предикатов над элементами одного или  несколь-
ких  списков до тех пор,  пока не будет выполнен заданный " 1критерий
 1окончания 0" или какой-либо из списков-аргументов не закончится.
    1Критерий окончания  0основывается на истинном значении, возвращае-
мом тестовой функцией.
 ш1.2

                      2Функционалы 0 ( 1из Prelude 0)

 ш1.0
                 1... я обратился с  просьбой  к  нескольким  друзьям
                 1прочитать эту работу и высказать свою критику. Кри-
                 1тические замечания были великолепны;  резкие, чест-
                 1ные и конструктивные, они противоречили друг другу.
                   1"Уж очень длинно", - говорил один.
                   1"Может, написать побольше", - говорил другой.
                        1П.Р.Халмош. Как писать математические тексты
 ш1.2

                   21. 0  3Функционалы-преобразователи
    21. 0 Функционал,  применяющий  заданную функцию к каждому элементу
входного списка и возвращающий преобразованный исходный список:
 ш1.0

    2map 0:: (a -> b) -> [a] -> [b]
    2map f lst

   Например:

   > map abs [-1,2,-3]   > map sqrt [0,4,9,16,25]
   [1,2,3]               [0.0,2.0,3.0,4.0,5.0]

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1, Пример 7.

 ш1.2
    22. 0 Функционал,  применяющий  заданную функцию к каждому элементу
заданного списка и объединяющий  полученные  результаты  с  помощью
функции  1concat 0:
 ш1.0

    2concatMap 0:: (a -> [b]) -> [a] -> [b]
    2concatMap f lst

   Например:

   > concatMap init [[1,2,3],[4],[4],[6,7,8,9]]
   [1,2,6,7,8]

   > concatMap reverse [[-1,-2,-3],[0],[2,1],[6,5,4,3]]
   [-3,-2,-1,0,1,2,3,4,5,6]

 ш1.2
                     22. 0  3Функционалы-компараторы
    21. 0 Функционал,  возвращающий список элементов исходного  списка,
для которых заданный предикат является истинным:
 ш1.0

    2filter 0:: (a -> Bool) -> [a] -> [a]
    2filter p lst

   Например:

   > filter null [[2],[3,3],[],[5,4],[],[2]]
   [[],[]]

   > filter (elem 3) [[2],[3,3],[],[5,4,3],[],[3]]
   [[3,3],[5,4,3],[3]]

   > filter (0>) [2,3,4,(-4),9,(-1)]
   [-4,-1]

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
    22. 0 Функционал, возвращающий список элементов из начала исходного
списка до тех пор, пока они удовлетворяют заданному предикату:
 ш1.0

    2takeWhile 0:: (a -> Bool) -> [a] -> [a]
    2takeWhile 0  2p lst

   Например:

   > takeWhile (0<) [2,3,4,-4,9,-1,11,21]
   [2,3,4]

   > takeWhile (elem (-2)) [[1,-2,2],[-2],[4],[-2,-2]]
   [[1,-2,2],[-2]]

   > takeWhile (elem 7) [[2,3],[3,7,6],[9,7]]
   []

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 3.

 ш1.2
    23. 0 Функционал,  удаляющий элементы из начала списка до тех  пор,
пока они удовлетворяют заданному предикату (англ.  1drop 0 -  1отбрасыва-
 1ние 0):
 ш1.0

    2dropWhile 0:: (a -> Bool) -> [a] -> [a]
    2dropWhile 0  2p lst

   Например:

   > dropWhile (0<) [2,3,4,-4,9,-1,11,21]
   [-4,9,-1,11,21]

   > dropWhile (elem (-2)) [[1,-2,2],[-2],[4],[-2,-2]]
   [[4],[-2,-2]]

 ш1.2
    24. 0 Функционал, разделяющий исходный список на два и возвращающий
пару, содержащую полученные списки.  В первый список поступают эле-
менты из  начала исходного списка,  которые удовлетворяют заданному
предикату, во второй - оставшиеся элементы исходного списка:
 ш1.0

    2span 0:: (a -> Bool) -> [a] -> ([a],[a])
    2span p lst

   Например:

   > span (0>=) [-3,-4,1,0,-2,3,4,10,-2]    > span null [[],[],[]]
   ([-3,-4],[1,0,-2,3,4,10,-2])             ([[],[],[]],[])

   > span (0>=) [3,4,1,0,-2,3,4,10,-2]
   ([],[3,4,1,0,-2,3,4,10,-2])

 ш1.2
    25. 0 Функционал, разделяющий исходный список на два и возвращающий
 _ 1кортеж . 0 из полученных списков.  1Точкой деления 0 исходного списка явля-
ется  первый элемент,  для которого заданный предикат принимает ис-
тинное значение:
 ш1.0

    2break 0:: (a -> Bool) -> [a] -> ([a], [a])
    2break p lst

 ш1.2
   В том случае, если предикат не выполняется ни для одного из эле-
ментов,  то  первым  элементом кортежа является исходный список,  а
вторым - пустой список.
   Например:
 ш1.0

   > break (0>=) [3,4,1,0,-2,3,4,10,-2]    > break (0<) [-1,-2]
   ([3,4,1],[0,-2,3,4,10,-2])              ([-1,-2],[])

   > break ('a'==) ['b','c','a','d','e']
   ("bc","ade")

 ш1.2
                     23. 0  3Функционалы-конструкторы
    21. 0 Функционал,  возвращающий список элементов по  двум  исходным
спискам путём  применения  заданной функции к парам соответствующих
значений входных списков:
 ш1.0

    2zipWith 0:: (a -> b -> c) -> [a] -> [b] -> [c]
    2zipWith f lst1 lst2

   Например:

   > zipWith max [1,-2] [-5,3]   > zipWith (+) [1,-2,10] [-5,3,10]
   [1,3]                         [-4,1,20]

   > zipWith (-) [1,-2,10] [-5,3,10,-3,-4,2]
   [6,-5,0]

 ш1.2
                    24. 0  3Функционалы-распознаватели
    21. 0 Функционал,  возвращающий  True,  если  _ 1все . 0 элементы заданного
списка удовлетворяют заданному предикату:
 ш1.0

    2all 0:: (a -> Bool) -> [a] -> Bool
    2all p lst

   Например:

   > all (1=) []   > all (0>) [1,-2,3,-4]   > all (0<=) [0,1,2,3,4]
   False           False                    True

 ш1.2
    22. 0 Функционал, возвращающий True, если  _ 1некоторые . 0 элементы задан-
ного списка удовлетворяют заданному предикату:
 ш1.0

    2any 0:: (a -> Bool) -> [a] -> Bool
    2any p lst

   Например:

   > any (1=) []   > any (1=) [1,1,1,1]   > any (0<=) [0,1,2,3,4,5]
   False           True                   True

 ш1.2
    3Замечание 0 ( 1для знатоков языка Python 0).
 ш1.1
   Приведём примеры работы с некоторыми функционалами в языке прог-
раммирования Python (воспользуемся безымянными функциями):
 ш1.0

   >>> apply(lambda x,y: x+y,[2,3])
   5

   >>> map(lambda x: x+1,[1,2,3])
   [2,3,4]

   >>> filter(lambda x: x>0,[1,-2,-3])
   [1]

 ш1.1
   Репутация языка Python как языка, поддерживающего функциональное
программирование, могла возникнуть в результате наличия в нём lamb-
da,  map, filter и reduce, но это всего лишь  1синтаксические украше-
 1ния 0,  а  не основные конструктивные элементы,  как в функциональных
языках.  Более фундаментальным свойством языка Python, общим с язы-
ком Lisp, является представление функций в качестве объектов перво-
го класса, которые легко передавать, как и всякие другие объекты.
 ш1.2

               25. 0  3Функционал для организации 0  3итерации
                              2( 1iterate 2)

 ш1.0
                                      1Будем сами дуть в свои паруса.
                                                               1Е.Лец
 ш1.2

    2Определение 0.
 ш1.1
    _ 1Итерация . 0 (от лат.  1iteratio 0 -  1повторение 0) - это результат повтор-
ного применения какой-либо математической операции.

 ш1.2
    2Определение 0.
 ш1.1
    2(1)  _ 1Первой . 0,  _ 1второй .,  _третьей .,..., 0  1n- _ой итерациями . 0  функции y=f(x)
называются соответственно функции
 ш1.0

   f 41 0(x)=f(x), f 42 0(x)=f(f 41 0(x)), f 43 0(x)=f(f 42 0(x)),...,f 4n 0(x)=f(f 4n-1 0(x)).

 ш1.1
    _ 1Показателем итерации . 0 называется индекс n.
    2(2) 0  _ 1Итерированием . 0  называется процесс перехода от функции f(x) к
функциям 4  0f 41 0(x),f 42 0(x),...,f 4n 0(x).

 ш1.2
    2Пример 0 ( 1процесса итерирования 0).
 ш1.1
   Если f(x)=x 7Ф 0, то получаем
 ш1.0
                   42 0           42      3 0               4n-1     n
   f 42 0(x)=(x 7Ф 0) 7Ф 0 =x 7Ф 0 ,f 43 0(x)=(x 7Ф 4  0) 7Ф 0 =x 7Ф 0 ,...,f 4n 0(x)=(x 7Ф 4    0) 7Ф 0=x 7Ф 0 ,...

 ш1.2
   Для некоторых классов функций можно определить итерации с произ-
вольным действительным и даже комплексным показателем.
    2Определение 0.
 ш1.1
    2(1)  _ 1Итерационные методы . 0 - это методы построения последовательных
приближений к решению задачи.  Применение метода начинают с  выбора
одного или нескольких приближений.  Для получения каждого из после-
дующих приближений выполняют однотипный набор действий с  использо-
ванием  ранее найденных приближений,  который называется  _ 1итерацией ..
Неограниченное продолжение этого итерационного процесса теоретичес-
ки позволяет построить бесконечную последовательность приближений к
решению -  _ 1итерационную последовательность . 0.
    2(2)  0Говорят, что  _ 1итерационный метод сходится . 0, если  итерационная
последовательность сходится к решению задачи.

 ш1.2
    3Замечание 0.
 ш1.1
   Первые попытки изучения итераций выполнены Л.Эйлером (1778).

 ш1.2
   Функционал, применяющий функцию,  заданную первым аргументом  ко
второму  аргументу  и  возвращающий  1потенциально бесконечный список
результатов применений
 ш1.0

   [x, f(x), f(f(x)), f(f(f(x))),...]

имеет следующий синтаксис:

    2iterate 0:: (a -> a) -> a -> [a]
    2iterate f x

 ш1.2
   Например:
 ш1.0

   > iterate sqrt 256
   [256.0,16.0,4.0,2.0,1.4142135623731,1.18920711500272,...]

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 4.

                    26. 0  3Функционал для организации
                        3циклических процессов

 ш1.0
                                  1Рекурсия - это язык ассемблера для
                                  1функционального 0  1программирования.
                                                    1Автор неизвестен
 ш1.2

   В языке Haskell существует функционал,  способствующий организа-
ции  1циклических вычислений 0 заданной функции с передачей в  качестве
параметра на очередной итерации предыдущего вычисленного значения.
   Синтаксис и семантика функционала
 ш1.0

    2until 0:: (a -> Bool) -> (a -> a) -> a -> a
    2until p f x 0 = if (p x)
                   then x
                   else until p f (f x)

 ш1.2
   В качестве сигнала об остановке цикла используется предикат, пе-
редаваемый первым аргументом:  когда его значение становится истин-
ным, выполнение циклического процесса прекращается.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5.

 ш1.2
    3Замечание 0.
 ш1.1
   Семантика функционала  until  напоминает  семантику  функционала
iterate, формирующего бесконечный список промежуточных результатов,
последний элемент которого является возвращаемым значением функции.
 ш1.2

                        3Представление функций
                         3с помощью карринга

 ш1.0
                    1... что означает "плюс" или "+" в  конце  слова:
                    1"Работа+",  НТВ+, "Европа Плюс" 0? 1 Если ли бы были
                    1"Работа + отдых" или "Европа + Америка", ещё ку-
                    1да ни шло, а так совершенно непонятно.
                                                          1М.Кронгауз
 ш1.2

   Представление функций многих аргументов в виде последовательнос-
ти функций одного аргумента предложил  М.Шейнфинкель  (1924):  если
функция y=f(x 41 0,x 42 0,...,x 4n 0) имеет тип
 ш1.0

   A 41 0─ 76 0(A 42 0─ 76 0(...─ 76 0(A 4n 0─ 76 0B)...)),

 ш1.2
то для  вычисления значения f(a 41 0,a 42 0,...,a 4n 0),  необходимо последова-
тельно провести вычисление следующего вида:
 ш1.0

   (...(f(a 41 0) a 42 0)...) a 4n 0,

 ш1.2
результатом которого будет объект типа B.
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Каррингом . 0 (по имени Х.Карри, чьё имя носит язык Haskell) на-
зывается приём замены  структурированных  выражений  последователь-
ностью нескольких простых выражений.
    2(2) 0 (По [Кирпичёв,2009,с.107])  _ 1Каррингом . 0 называется явление, при
котором для  функции  нескольких  аргументов появляется возможность
зафиксировать несколько первых из них:  сам процесс фиксации  аргу-
ментов и подготовка функции к возможности их фиксации.
    2(3) 0  _ 1Каррингом . 0 ( _ 1каррированием . 0)  называется   2  0процесс   2  0(и  приём)
представления функции от нескольких аргументов в  виде  функции  от
одного аргумента (другими словами, процесс построения каррированной
функции).

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Каррированными функциями . 0  называются  функции y=f(x 41 0,x 42 0,...,x 4n 0),
синтаксически представимые в виде
 ш1.0

   (...(f(x 41 0) x 42 0)...) x 4n 0.

 ш1.2
    3Замечание 0.
 ш1.1
   В качестве синонима слова " 1карринг 0" используются термины  _ 1частич-
 _ 1ное применение функции . 0 и  _ 1частичная параметризация . 0.

 ш1.2
   Каррированные функции  "предполагают",  что их можно применять к
неполному количеству аргументов, и результатом применения будут но-
вые функции, которые " 1ожидают 0" на свой вход оставшиеся аргументы.
   В частности,  применяя карринг,  можно избавиться от  составного
объекта -  1пары 0,  получив функцию,  зависящую от двух простых объек-
тов, которые являлись компонентами пары.
   Библиотека Prelude содержит два функционала
 ш1.0

   curry:: ((a,b) -> c) -> (a -> b -> c)
   curry f x y = f (x,y)

   uncurry:: (a -> b -> c) -> ((a,b) -> c)
   uncurry f (x,y) = f x y

 ш1.2
   Отметим  _ 1преимущества частично применённых функций . 0:
   (1) карринг  позволяет уменьшить число скобок при записи выраже-
ния;
   (2) употребление карринговых функций позволяет сделать программу
значительно "функциональнее".
   В частности,  использование  механизма карринга предпочтительнее
использования пары, содержащей аргументы.
   В самом  деле,  каррированную  функцию  можно  1частично 0 вычислить
(параметризовать), а функцию, использующую упорядоченную пару аргу-
ментов - нет;  поэтому, в частности, все стандартные функции, зави-
сящие более чем от одного параметра, записаны в карринговой форме.
   Поясним последнее утверждение.
    2Пример 0.
 ш1.1
   Рассмотрим функцию twice,  которая применяет к аргументу одну  и
ту же функцию дважды:
 ш1.0

   twice:: (Double -> Double) -> (Double -> Double)
   twice f x = f (f x)

 ш1.1
   Используя исчисление комбинаторов,  легко получить  _ 1комбинаторное
 _ 1представление функции . 0 twice:
 ш1.0

   f(fx)= 2B 0ffx=((.) f f) x,

а функцию twice переписать следующим образом:

   twice':: (Double -> Double) -> (Double -> Double)
   twice' f = (.) f f

 ш1.1
   Получено  _ 1представление функции в карринговой форме . 0,  которое ха-
рактеризуется отсутствием аргументов:
 ш1.0

   twice':: (Double -> Double) -> (Double -> Double)
   twice' f = (.) f f

   Определение twice в некарринговой форме выглядит так:

   twice'':: (Double -> Double) -> (Double -> Double)
   twice'' (f,x) = f (f x)

 ш1.1
   Теперь уже невозможно вызвать функцию без указания аргумента,  к
которому функция применяется.
   Для тестирования можно использовать функцию
 ш1.0

   test = (twice sin 1,(twice' sin 1,twice'' (sin,1)))

 ш1.2
   Итак, в случае необходимости всегда можно преобразовать  функцию
к виду частично применённой с помощью функции curry,  которая берёт
"некарринговую" функцию и преобразует  её  к  частично  применённой
форме.
   Отметим, что функция curry сама представляет собой частично при-
менённую функцию (она получает три аргумента, один за другим).
   Функция uncurry осуществляет обратное преобразование:  она прев-
ращает функцию с двумя параметрами в её некарринговую форму.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6.

 ш1.2
    3Замечание 0 (по [Марков,2016,с.183]).
 ш1.1
    _ 1Эллипсисом . 0 ( 1в программировании 0) называется умолчание  количества
параметров.
   Необходимость использования эллипсиса возникает тогда, когда не-
обходимо передать на обработку заранее неизвестное количество пара-
метров определённого типа.
   Например, в Visual Prolog эллипсис позволяет передавать предика-
ту произвольное количество параметров.
 ш1.2

                  3Функции и функционалы для работы
                   3со списками 0  3из библиотеки List

 ш1.0
                  1- Опять эти классические теперь у нас языки 0: 1  одно
                  1сумасшествие,  и ничего больше... Вы опять, кажет-
                  1ся, не согласны со мной, Карамазов 0?
                  1- Не согласен, - сдержанно улыбнулся Алёша.
                                 1Ф.М.Достоевский. Братья Карамазовы.
                                                  1Ч.IV, кн.10, гл.5
 ш1.2

   В библиотеке List определены некоторые редко используемые опера-
ции над списками.
 ш1.0

   module List (
      elemIndex, elemIndices,
      find, findIndex, findIndices,
      nub, nubBy, delete, deleteBy, (\\), deleteFirstsBy,
      union, unionBy, intersect, intersectBy,
      intersperse, transpose, partition, group, groupBy,
      inits, tails, isPrefixOf, isSuffixOf,
      mapAccumL, mapAccumR,
      sort, sortBy, insert, insertBy, maximumBy, minimumBy,
      genericLength, genericTake, genericDrop,
      genericSplitAt, genericIndex, genericReplicate,
      zip4, zip5, zip6, zip7,
      zipWith4, zipWith5, zipWith6, zipWith7,
      unzip4, unzip5, unzip6, unzip7, unfoldr,

      -- ... и то, что экспортирует Prelude

      -- [] ((:),[]),             -- Это встроенный синтаксис
      map, (++), concat, filter,
      head, last, tail, init, null, length, (!!),
      foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,
      iterate, repeat, replicate, cycle,
      take, drop, splitAt, takeWhile, dropWhile, span, break,
      lines, words, unlines, unwords, reverse, and, or,
      any, all, elem, notElem, lookup,
      sum, product, maximum, minimum, concatMap,
      zip, zip3, zipWith, zipWith3, unzip, unzip3
      ) where
   infix 5 \\

   elemIndex        :: Eq a => a -> [a] -> Maybe Int
   elemIndices      :: Eq a => a -> [a] -> [Int]
   find             :: (a -> Bool) -> [a] -> Maybe a
   findIndex        :: (a -> Bool) -> [a] -> Maybe Int
   findIndices      :: (a -> Bool) -> [a] -> [Int]
   delete           :: Eq a => a -> [a] -> [a]
   deleteBy         :: (a -> a -> Bool) -> a -> [a] -> [a]
   (\\)             :: Eq a => [a] -> [a] -> [a]
   deleteFirstsBy   :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   union            :: Eq a => [a] -> [a] -> [a]
   unionBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   intersect        :: Eq a => [a] -> [a] -> [a]
   intersectBy      :: (a -> a -> Bool) -> [a] -> [a] -> [a]
   intersperse      :: a -> [a] -> [a]
   transpose        :: [[a]] -> [[a]]
   partition        :: (a -> Bool) -> [a] -> ([a],[a])
   group            :: Eq a => [a] -> [[a]]
   groupBy          :: (a -> a -> Bool) -> [a] -> [[a]]
   inits            :: [a] -> [[a]]
   tails            :: [a] -> [[a]]
   isPrefixOf       :: Eq a => [a] -> [a] -> Bool
   isSuffixOf       :: Eq a => [a] -> [a] -> Bool
   mapAccumL        :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
   mapAccumR        :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
   nub              :: Eq a => [a] -> [a]
   nubBy            :: (a -> a -> Bool) -> [a] -> [a]
   unfoldr          :: (b -> Maybe (a,b)) -> b -> [a]
   sort             :: Ord a => [a] -> [a]
   sortBy           :: (a -> a -> Ordering) -> [a] -> [a]
   insert           :: Ord a => a -> [a] -> [a]
   insertBy         :: (a -> a -> Ordering) -> a -> [a] -> [a]
   maximumBy        :: (a -> a -> Ordering) -> [a] -> a
   minimumBy        :: (a -> a -> Ordering) -> [a] -> a
   genericLength    :: Integral a => [b] -> a
   genericTake      :: Integral a => a -> [b] -> [b]
   genericDrop      :: Integral a => a -> [b] -> [b]
   genericSplitAt   :: Integral a => a -> [b] -> ([b],[b])
   genericIndex     :: Integral a => [b] -> a -> b
   genericReplicate :: Integral a => a -> b -> [b]
   zip4 :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
   zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
   zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f]
                                                 -> [(a,b,c,d,e,f)]
   zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
                                               -> [(a,b,c,d,e,f,g)]
   zipWith4 :: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
   zipWith5 :: (a->b->c->d->e->f) -> [a]->[b]->[c]->[d]->[e]->[f]
   zipWith6 :: (a->b->c->d->e->f->g) ->
                                  [a]->[b]->[c]->[d]->[e]->[f]->[g]
   zipWith7 :: (a->b->c->d->e->f->g->h) ->
                             [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
   unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])
   unzip5 :: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
   unzip6 :: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
   unzip7 :: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 8.

 ш1.2
                  3Реализация некоторых функционалов
                          3на языке Haskell
                3Работа с демонстрационными примерами
   См. Пример 9.

                       3Прагматика функционалов

 ш1.0
                                  1Человек, завоёвывая миры, не теряй
                                  1почву под ногами.
                                          1Е.Лец. Непричёсанные мысли
 ш1.2

   Функционалы (функции высшего порядка), такие как map  и  filter,
играют  в  функциональном программировании роль,  которую выполняют
 1управляющие структуры 0 (аналогичные for и while) в языках императив-
ного программирования.  Однако эти управляющие  структуры  являются
встроенными в язык, в то время как функционалы можно определить са-
мостоятельно.
   Это делает функциональное программирование очень гибким: имеется
лишь небольшое число встроенных функций,  но программист может  са-
мостоятельно конструировать свои программные инструменты.
   В частности,  функционалы  удобно  использовать для  _ 1тестирования
 _ 1функций . 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 10.

 ш1.2
                      3Алгебраические тождества
                          3для функционалов
    2Теорема 0 (по [Bird,1998,с.110-111]).
 ш1.0
                                     7)
    2(1) 0 map id = id;                  72 0 " 1Функторные 0" 1 тождества
                                     78 0  1 для функционала map
    2(2) 0 map (f . g) = map f . map g;  72 0
                                     70
    2(3) 0 f . head = head . map f;

    2(4) 0 map f . tail = tail . map f;

    2(5) 0 map f . reverse = reverse . map f;

    2(6) 0 map f . concate = concat . map (map f);

    2(7) 0 map f (xs ++ ys) = map f xs ++ map f ys.

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Теорема 0 (по [Bird,Wadler,1988,с.63; Bird,1998,с.112]).
 ш1.0

    2(1) 0 filter p . filter q = filter (p x && q x);

    2(2) 0 filter p . concat   = concat . map (filter p);

    2(3) 0 filter p (xs ++ ys) = filter p xs ++ filter p ys.

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    2Теорема 0 (по [Bird,1998,с.114]).
 ш1.0

    2(1) 0 [f x | x <- lst]    = map f lst;

    2(2) 0 [x | x <- lst, p x] = filter p lst;

    2(3) 0 [e | x <- lst1, y <- lst2] =
                           = concat [[e | y <- lst2] | x <- lst1].

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
                    3Голофрастические конструкции
   В определённом  смысле  язык Haskell является  1языком  _голофрасти-
 _ 1ческого типа . 0, т.е. включает в себя многочисленные теоретические ре-
зультаты, полученные в теоретическом программировании, представлен-
ные, разумеется, формальным образом.
   Можно сказать,  что язык Haskell воплощает своеобразный "постмо-
дернистский подход" к программированию.
    2Определение 0 [Комлев,2006].
 ш1.1
    2(1) 0 [Ахманова,2004]  _ 1Голофрасис . 0 ( _ 1голофраза . 0) (греч.  1holos 0 -  1целый 0,
 1весь 0;   1phrases 0 -  1выражение, высказывание 0) - это своеобразный техни-
ческий приём, продуктивный способ образования нового слова или осо-
бого рода синтагматической единицы из синтаксической  группы,  т.е.
из  нескольких самостоятельных,  но объединенных внутренним смыслом
слов,  путём их последовательного складывания или  подсоединения  и
оформления результатирующей структуры служебными элементами.
   Другими словами,  _ 1голофрасис . 0 - это отдельное слово, функционирую-
щее как фраза или предложение (например, "Иди!"), либо фраза, функ-
ционирующая как слово (например, "палочка-из-беды-выручалочка").
    2(2) 0 [Ахманова,2004]  _ 1Голофрастический . 0 ( 1инкорпорирующий 0,   1полисин-
 1тетический 0)  _ 1язык . 0 - это язык,  характеризующийся наличием   1голофразы
( 1голофрасиса 0), т.е. это язык, в котором "главной отличительной чер-
той является сращение всей фразы в своего рода единое слово".
    2(3) 0  _ 1Голофрастический 0  1тип языка . 0 - это тип языка,  который отлича-
ется широким включением в структуру глагольного ядра других  членов
предложения;  язык,  для которого типичны  1слова-предложения 0 (напри-
мер, языки американских индейцев, чукотский, эскимосский и др.).

 ш1.2
   Термин " 1голофрастическая конструкция 0" широко используется в пси-
холингвистике и обозначает в одной из трактовок "словарную единицу,
сложившуюся в цельнооформленное слово из достаточно крупных синтак-
сических  отрезков:  целых  предложений  или  глагольных синтагм по
принципу формально-компонентного тождества  с  этими  предложениями
или синтагмами"  (Н 1. 0Д 1. 0Миловская,1984).  При  этом   1принцип формаль-
 1но-компонентного тождества 0 означает, что складывание синтаксическо-
го  построения одной словоподобной единицы не сопровождается какими
бы то ни было изменениями или  усечениями  структурной  организации
исходного предложения или словосочетания.
   Такие конструкции нарушают своей  нестандартностью  и  неожидан-
ностью первичное течение текста, создавая возможности для "осмысли-
вания" и "переосмысливания" заключённой в них информации.
   Итак, "название " 1голофрастическая конструкция 0" подчеркивает сло-
вообразовательную нестандартность словесных единиц указанного типа,
формирующиеся  в результате стяжения линейного ряда слов в одну но-
вую отдельную лексему" (Н 1. 0Д 1. 0Миловская,1983).

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

    2Пример 0  26.
 ш1.0

 ш1.2

    2Пример 0  27.
 ш1.0

 ш1.2

    2Пример 0  28.
 ш1.0

 ш1.2

    2Пример 0  29.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                                   1Я задаю уклончивые вопросы, чтобы
                                   1пресечь 0  1уклончивые ответы.
                                          1Е.Лец. Непричёсанные мысли
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
             21. 3 Непосредственное применение функционалов
                        3из библиотеки Prelude
    21 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (1) ddd:: [Int] -> [Int]
       ddd lst = map (`mod` 2) lst

   (2) abc:: [Int] -> Bool
       abc lst = not $ sum (map (`rem` 2) lst) > 0

   (3) word2Int:: [Char] -> [Int]
       word2Int wrd = map (\x -> ord x - ord '0') wrd
       ----------------------------------------------
       test = word2Int wrd==map digitToInt wrd
            where wrd = "1235234345735745674567456742342342352342"

   (4) f lst1 lst2 = filter (< 0) lst1 ++ filter (>= 0) lst2

   (5) xil:: Int -> [[Int]] -> Int
       xil x lst = length $ filter (elem x) lst

   (6) map (\y -> (y,y^2))
           (filter (\x -> elem '3' (show (x^2))) [1..100])

   (7) length (takeWhile (=='0')
              (reverse (show (product [1..45]))))

   (8) binToInt s = sum $ zipWith (*)
                                  (map (2^) [0..])
                                  (map (\c -> if c=='0'
                                                then 0 else 1)
                                       $ reverse s)
   (9) f:: Double -> Int -> Double
       f x k = sum $ take k (tail $ iterate sin x)
       -------------------------------------------
       test1 = abs(f 1 1 - sin 1)<0.000000000001
       test2 = abs(f 1 3 - (sin 1)-((sin.sin) 1)-((sin.sin.sin) 1))
               <0.000001

   (10) log2 x = toInteger (length (takeWhile (>1)
                                              (iterate (/2) x)))

   (11) gold :: Int ->  Double
        gold n = last $ take n $ iterate (\x -> 1 / (1+x)) 1
        ----------------------------------------------------
        test' n | abs (gold n - gold (n+1)) < 0.00001 = n
                | True                                = test' (n+1)

 ш1.0
                               1Я изучил все ноты от и до,
                               1Но кто мне на вопрос ответит прямо 0? 1 -
                               1Ведь начинают гаммы с ноты  _до
                               1И ею же заканчивают гаммы.
                                           1В.Высоцкий. Песня о нотах
 ш1.2

    21 41 2. 0 Определите назначение функции
 ш1.0

   test = map (\x -> (x,2**(x/12.0))) [3,4,5,7,8,9,12]

 ш1.1
    _ 1Указание . 0. См. таблицу ( 1укажите значение 0 q):
 ш1.0

   ┌───────────────┬────────────────┬────────────────┬────┐
   │   3Гармоничные 0  │ 3Отношение частот 0│ 3Отношение частот 0│    │
   │    3интервалы 0   │ ( 1для скрипки 0)  │  ( 1для рояля 0)   │    │
   ╞═══════════════╪════════════════╪════════════════╪════╡
   │ Малая терция  │      6:5       │    7~ 01.18921...  │ q 53 0 │
   │ Большая терция│      5:4       │    7~ 01.25992...  │ q 54 0 │
   │ Кварта        │      4:3       │    7~ 01.33484...  │ q 55 0 │
   │ Квинта        │      3:2       │    7~ 01.49831...  │ q 57 0 │
   │ Малая секста  │      8:5       │    7~ 01.5874...   │ q 58 0 │
   │ Большая секста│      5:3       │    7~ 01.68179...  │ q 59 0 │
   │ Октава        │      2:1       │    2.0         │ q 512 0│
   └───────────────┴────────────────┴────────────────┴────┘

 ш1.2
    3Замечание 0.
 ш1.1
   Традиции делить тональности на "хорошие" и "плохие" и писать му-
зыку только в "хороших" была поколеблена И.С.Бахом (1685-1750), ко-
торый написал " 1Хорошо темперированный клавир 0" - сборник пьес  (пре-
людий и  фуг),  состоящий из двух частей;  в каждой - 24 прелюдии и
фуги, по одной в каждой мажорной и минорной тональности.
   Таким образом он продемонстрировал, что можно играть в любой то-
нальности,  1не перенастраивая инструмент 0.
   Неизвестно, как в точности И.С.Бах настраивал клавесин:  была ли
это  _ 1равномерная темперация . 0 (когда хроматическая гамма образует гео-
метрическую прогрессию) или какая-то не вполне равномерная.
   Но современные исполнители играют его на  равномерно  темпериро-
ванных   1роялях 0, на  которых  все  интервалы (за исключением октавы)
звучат не совсем чисто - но зато одинаково во всех тональностях.

 ш1.2
    22 4* 2. 0 Напишите функцию, в которой используется функционал filter с
предикатом >, возвращающую список элементов заданного списка, боль-
ших 5.
    23 4* 2. 0 Напишите функцию, содержащую функционал span с предикатом >,
разделяющую заданный список на два и возвращающую   _ 1пару . 0  полученных
списков.
 ш1.1
    _ 1Указание . 0. "Точкой деления" исходного списка является первый эле-
мент, для которого предикат > принимает истинное значение.

 ш1.2
    24 4* 2. 0 Напишите функцию,  содержащую функционал span  с  предикатом
<=, разделяющую заданный список на два и возвращающую  1список 0 из по-
лученных списков.
 ш1.1
    _ 1Указание . 0. В  первый список поступают элементы из начала исходно-
го, которые удовлетворяют предикату <=, во второй - оставшиеся эле-
менты исходного списка.

 ш1.2
    25 4* 2. 0 Напишите функцию, в которой используется функционал dropWhi-
le с предикатом ==, удаляющую элементы из начала списка.
    26. 0 Напишите функцию, использующую функционалы и вычисляющую зна-
чение функции
 ш1.0

    1sin 0(x) 3  0+ 3  1sin 0( 1sin 0(x)) 3  0+ 7777 0+ 3  1sin 0( 1sin 0...( 1sin 0(x))...).
                               ═└ 0─ 3── 0── ═┬ 3── 0──── ═┘
                                   1n 0  1раз

 ш1.2
    27. 0 (По [Bird,1998,p.***])
   Определите тип функционалов:
 ш1.0

   (1) (map map);          (3) (map (map . map . map)).
   (2) (map (map . map));

 ш1.1
    _ 1Указание . 0. Воспользуйтесь "песочницей":
 ш1.0

   > :t (map map)
   map map:: [a -> b] -> [[a] -> [b]]

 ш1.2
    28 5* 2. 0 Определите пропущенные функции  (отмеченные  знаком  "..."),
требуемые для получения указанного результата:
 ш1.0

   >   ...   (...) ((map map) [sin,cos]) [[1],[2]]
   [[0.841471],[-0.416147]]

 ш1.2
                   22. 3 Обработка списков с помощью
                            3функционалов
    21 4* 2. 0 Напишите функцию,  использующую  1функционалы 0 и конструирующую
список из двух заданных таким образом, что из первого списка берут-
ся только отрицательные числа, а из второго - только положительные.
    22. 0 Напишите функцию,  использующую   1функционалы 0  и  объединяющую
первую  половину  элементов первого списка со второй половиной эле-
ментов второго списка.
    23. 0 Напишите  функцию,  использующую  1функционалы 0 и конструирующую
список из n элементов k,  где k - неотрицательный минимальный  эле-
мент заданного списка.
   Если минимальный  элемент списка будет отрицательным числом,  то
функция должна вернуть пустой список.
    24. 0 Напишите функцию f:: [Int] -> [Int], используя следующие тес-
товые примеры:
 ш1.0

   test =   f [1,2,(-1)] [(-3),5,6]    == [(-1),5,6]
         && f [1,(-2),(-1)] [3,5,6]    == [(-2),(-1),3,5,6]
         && f [1,2,1] [(-3),(-5),(-6)] == []

 ш1.2
    25. 0 [Bird,1998,p.115]
   Функционал filter может быть определён с помощью функции  concat
и функционала map следующим образом:
 ш1.0

   filter p = concat . map box
         where box x = ...

 ш1.2
   Определите функцию box.
    26 4* 2. 0 Реализуйте двухместную операцию, называемую  _ 1вращением . 0 в язы-
ке программирования  2APL 0,  которая берёт первые k символов заданного
слова и помещает их в его конец.
                   23. 3 Рекурсивное конструирование
                      3функционалов 0  3из библиотек
    21. 0 Укажите назначение следующих функционалов:
 ш1.0

   (1) fun :: (Ord a, Ord b) => [(a,b)] -> [[(a,b)]]
       fun = (groupBy (\(a,b) -> \(c,d) -> a==c) . sort)

   (2) words' str = filter (any (not . ec)) (groupBy ecec str)
            where ec x     = elem' x " \r\n\t"
                  ecec x y = ec x==ec y        
 ш1.2
    22. 0 Реализуйте следующие функционалы из библиотеки  1Prelude 0:
 ш1.0

   (1) map, filter;     (5) scanr, scanr1;
   (2) foldl, foldl1;   (6) iterate, takeWhile, dropWhile;
   (3) scanl, scanl1;   (7) any, all.
   (4) foldr, foldr1;

 ш1.2
    _ 1Указание . 0.
 ш1.1
   Приведём классическую реализацию функционала map  и  реализацию,
подчёркивающую его "ленивость":
 ш1.0

   map f   []   = []             ║ map f   []   = []
   map f (x:xs) = f x : map f xs ║ map f (x:xs) = let x' = f x
                                 ║                    y' = map f xs
                                 ║                in x' 2  0: 2  0y'

 ш1.2
    23. 0 Реализуйте следующие функционалы из библиотеки  1List 0:
 ш1.0

   (1) nubBy, deleteBy, deleteFirstsBy;
   (2) unionBy, intersectBy, groupBy;
   (3) sortBy, insertBy;
   (4) maximumBy, minimumBy.
 ш1.2
