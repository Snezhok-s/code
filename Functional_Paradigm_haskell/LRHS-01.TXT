    2ЛАБОРАТОРНАЯ РАБОТА 1.
    2ОСНОВНЫЕ ТИПЫ ДАННЫХ, ОПЕРАЦИИ, СПОСОБЫ ОПРЕДЕЛЕНИЯ ФУНКЦИЙ

 ш1.0
                                       1Бояться нужно только одного -
                                       1своего собственного страха.
                                                          1Ф.Рузвельт
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Вспомогательные сведения . 0:
 ш1.0
   - инфиксная форма записи ( 1повторение 0).

 ш1.2
    _ 1Знать . 0:
 ш1.0
   - особенности парадигмы функционального программирования;
   - простейшие типы данных языка Haskell:  Integer,  Int,  Double,
Float, Char, Bool, String;
   - операции: инфиксная форма записи, приоритет операций, ассоциа-
тивность операций;
   - таблица приоритетов операций  стандартного  модуля  Prelude.hs
вместе с типом ассоциативности;
   - комментарии: строчные и вложенные;
   - постоянные функции;
   - описание типа функции:  операция аппликации для типа  функции,
полиморфный тип;
   - определение функций с помощью сопоставления с образцом:  клоз,
образец, пустой образец, именованный образец;
   - определение функций  с  помощью  условных  выражений:  простое
ветвление, множественное ветвление;
   - определение функций с помощью охраняющих выражений: охраняющее
выражение;
   - определение собственных операций;
   - понятие " 1чистота языка программирования 0";
   - инструментальное средство разработки языка Haskell.

    _ 1Уметь . 0:
   - осуществлять работу с инструментальным средством HUGS 98;
   - составлять  выражения и вычислять их значение с использованием
операций языка Haskell;
   - описывать типы собственных функций;
   - определять функции с помощью  1сопоставления с образцом 0;
   - определять функции с помощью  1условных выражений 0;
   - определять функции с помощью  1охраняющих выражений 0 ( 1охран 0).
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

 ш1.0
                           1Функциональное программирование сокращает
                           1разрыв между мыслью и кодом. 0
 ш1.2

    1Математические 0  1основы функционального программирования 0 были  за-
ложены  в 20-х годах XX века после разработки таких мощных вычисли-
тельных формализмов, как комбинаторная логика и  7l 0-исчисление. Впос-
ледствии  7l 0-исчисление и теория комбинаторов стали базисом всех раз-
работанных функциональных языков.
    1Парадигма функционального  программирования 0 (к которой относится
язык Haskell) основана на  математическом  понятии  " 1функция 0",  что
позволяет эффективно создавать программы, предназначенные для обра-
ботки символов.
    2Определение 0.
 ш1.1
    _ 1Функциональное программирование . 0  - это раздел  _ 1дискретной матема-
 _ 1тики . 0 и  _ 1парадигма программирования . 0,  в  которой  процесс  вычисления
трактуется как вычисление значения функции в математическом понима-
нии последних (в отличие от функций как подпрограмм  в  процедурном
программировании).
   Противопоставляется  1парадигме  императивного 0   программирования,
которая  описывает процесс вычислений как процесс изменения состоя-
ний. Функциональное программирование не  предполагает  изменяемости
данных (в отличие от императивного,  где одной из базовых концепций
является переменная).

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Термин " 1парадигма 0" означает набор теорий,  стандартов и методов,
которые совместно  представляют  собой  способ организации знаний -
иными словами,  1способ видения некоторого фрагмента мира 0.
   В программировании  этот термин используется для определения  _ 1мо-
 _ 1дели вычислений . 0,  т.е. способа структурирования информации, органи-
зации вычислений и данных.

 ш1.2
   Когда вы пишете программу на функциональном языке программирова-
ния,  вы вначале создаёте собственный язык (набор функций), а затем
с его помощью формулируете исходную задачу. Более точно, вы "подго-
няете" язык функционального программирования до тех пор, пока он не
станет совпадать с языком, на котором задача формулируется легко.
   С помощью функционального  программирования  решаются  следующие
задачи, традиционные для направления информатики, которое называет-
ся " 1искусственный интеллект 0":
 ш1.1
   (1) символьные вычисления (в частности,  при помощи функций  эф-
фективно реализуются алгоритмы сортировки и поиска);
   (2) вывод на знаниях;
   (3) обработка  формализованных  и естественных языков (например,
перевод одного формализованного языка на другой или разбор  синтак-
сических конструкций);
   (4) создание  общающихся  между  собой программных систем (аген-
тов).

 ш1.2
    _ 1Язык Haskell . 0 (названный в честь логика  1Хаскелла Б. Карри 0, одного
из  основоположников  функционального программирования) появился на
основе первого функционального языка LISP,  разработанного  Дж.Мак-
карти в начале 60-х годов.
   Следующие языки программирования были особенно важны для  созда-
ния языка  Haskell:  Lisp (Common Lisp,  Scheme),  ISWIM,  APL,  FP
Дж. Бэкуса, ML, Standard ML, Hope, Gofer, Miranda.
   По словам Саймона Пейтон Джонса, "без этих предшественников язык
Haskell был бы невозможен".
   Haskell -  это  1функциональный 0  _ 1чистый .  _нестрогий . 0 язык программиро-
вания,  изначально разработанный для того,  чтобы служить  открытым
стандартом для современных языков функционального программирования.
   Высокий уровень абстракций,  обеспечиваемый Haskell для  решения
задач, является непревзойдённым (на 2015 г.).
   Ряд характеристик языка Haskell уже включён или внедряется в не-
которые основные языки.
    1Функциональные замыкания 0 ( 7l 1-выражения 0) появились во многих  язы-
ках, включая Perl, JavaScript, Python, C 1# 0, Visual Basic, Scala.
    1Внутренние классы 0  появились  в языке Java как средство имитации
замыканий, а предложение добавить в Java настоящие замыкания (как в
Scala) широко обсуждается.  Влияние в пользу замыканий оказывает не
только Haskell, но и все функциональные языки, включая Scheme и се-
мейство ML.
    1Списочные выражения 0 имеются в языках Python,  C 1# 0 и Visual  Basic
(в  обоих сдучаях в связи с LINQ),  и Scala,  а также запланированы
для Perl и JavaScript. Язык Haskell не был первым языком со списоч-
ными выражениями, но весьма способствовал росту их популярности.
   В языках C 1# 0,  Visual Basic и Scala выражения применимы не только
к спискам,  но и к другим структурам, поэтому они больше напоминают
генерацию монад или do-синтаксис,  которые впервые появились в Has-
kell.
    1Обобщённые типы 0 в языке Java ( 1генерики 0)  появились  под  сильным
влиянием полиморфных типов и классов типов Haskell. Эти возможности
Java, в свою очередь, способствовали их появлению в языках C 1# 0 и Vi-
sual Basic.
    1Классы типов 0 есть в языке Scala. Теперь и в языке C++ рассматри-
вают  возможность  включения конструкции,  названной " 1концептами 0" и
весьма похожей на классы типов. Haskell также оказал влияние на ряд
менее распространённых языков, в том числе Cayenne, Clean, Mercury,
Curry, Eacher, Hal, Isabelle.
   Далее, программисты, которые изучили Haskell, но редко использу-
ют его в своей работе, отмечали, что это изучение положительно пов-
лияло  на их мышление и стиль программирования на императивных язы-
ках.
    3Замечания 0.
 ш1.1
    21. 0 Программирование - это раздел  1дискретной математики 0.
   Более точно,  программирование - это  "действующая"  математика,
т.е. математика,  исследующая формальные языки, предназначенные для
описания понятия " 1вычислимость 0".
    22. 0 Язык  Haskell  тесно  связан с языком программирования  2Curry 0,
являющимся универсальным языком программирования,  в котором соеди-
нены две парадигмы декларативного программирования -  1функциональная
и  1логическая 0. Более того, в этом языке использованы наиболее важные
операционные принципы подобных декларативных языков.
   Язык Curry соединяет в себе возможности функционального програм-
мирования (вложенные выражения,  функции высших  порядков,  ленивые
вычисления),  логического  программирования (логические переменные,
частичные структуры данных,  встроенная система поиска)  и  методов
программирования  для  параллельных систем (параллельное вычисление
выражений с синхронизацией по логическим переменным).
   Более того, язык Curry предоставляет дополнительные механизмы по
сравнению с чистыми языками программирования:
   (а) по  сравнению с функциональными языками - поиск и вычисления
по неполным данным;
   (б) по сравнению с логическими языками - более эффективный меха-
низм вычислений благодаря детерминизму и  вызову  по  необходимости
для функций.
   Приведём базовые  _ 1характеристики языка Curry . 0: функции определяют-
ся через выражения,  предикаты рассматриваются в  качестве  булевых
функций,  система  типизации Хиндли-Милнера с параметрическим поли-
морфизмом,  ленивая редукция функциональных выражений, задержка вы-
числения  функции  до  получения значения логической переменной при
помощи вычисления предиката, функции высшего порядка, декларативная
(монадическая)  система  ввода-вывода,  встроенные механизмы поиска
(сначала в глубину,  сначала в ширину,  поиск наилучшего решения) и
вычисления выражений в ограничениях.

 ш1.2
                  3Несколько слов об общей культуре
                          3программирования
                  (по [Мозговой,2006,с.319-320])
   Любой человек,  занимающийся программированием изо дня  в  день,
примерно  представляет  себе,  какого  рода задачи ставит перед ним
профессия и в общих чертах знает,  в какой литературе  можно  найти
ответы  на интересующие вопросы.  Но помимо жизненно важных знаний,
умений и навыков существует ещё такое понятие,  как  1общая  культура
 1программирования 0.
   Обычная жизнь, повседневное общение, вероятно, не требуют от че-
ловека каких-то особенных познаний (по крайней мере,  субъекты, ими
не отягощённые, но при этом прекрасно выживающие, встречаются с за-
видной регулярностью).  Но общая культурная образованность способна
сделать нашу жизнь если не проще, то заметно интереснее и богаче.
   Если во время прогулки где-нибудь в исторических кварталах горо-
да у Вас перед глазами возникают живые картины  из  прошлого,  если
ежедневные ситуации ассоциируются с событиями из любимых литератур-
ных произведений,  тем самым обретая новые яркие краски,  - уверен,
такое,  более  глубокое понимание происходящего вокруг когда-нибудь
сослужит Вам хорошую службу.
   Точно так  же  и общая культура программирования,  не призванная
содействовать достижению каких-либо конкретных целей, поднимает по-
нимание  программирования  как вида творчества на качественно новый
уровень.
   Взять, к примеру, такую популярную нынче идею как  _ 1паттерны прог-
 _ 1раммирования . 0 - высокоуровневые конструкции, выражающие общепринятый
подход к решению той или иной типичной задачи.  Начинающий програм-
мист без труда поймёт каждую отдельную инструкцию, входящую в алго-
ритм-паттерн, но общая архитектура останется для него неясной.
   Представьте, что,  глядя  на  загородный домик,  мы бы не видели
окон, стен и крыши, а понимали бы лишь, что он состоит из кирпичей,
стекла и черепицы. Немыслимо в реальной жизни, но вполне обыкновен-
но в программировании.
   Хороший пример  общей культуры - это  1функциональное программиро-
 1вание 0.  Думаю, что подавляющее большинство студентов никогда не ис-
пользовали языки, подобные языкам Haskell или Standard ML и вряд ли
когда-либо  будут это делать.  Тем не менее,  идеологию  1обобщённого
 1программирования 0 вообще и библиотеки  STL  (с  которой,  наверняка,
сталкивался  каждый  второй) понять гораздо труднее,  не зная основ
функциональной парадигмы.
                       3Простейшие типы данных
   В языках функционального программирования простейшим типом  дан-
ных, на основе которых строятся все остальные, является  1атом 0.
   Первоначальное значение слова " 1атом 0" (от греч. " 1а 0" ─  1не 0, " 1том 0" ─
 1часть 0) ─ это " 1тот, который не может быть дальше разделён 0".
   Фактически  _ 1атом . 0 - это слово в некотором алфавите.
   Приведём  _ 1простейшие . 0 ( _ 1базовые . 0) типы данных языка Haskell:
 ш1.0

                       4┌ 0───────────────────── 4┐
                      │  2Базовые типы данных 0 │
                       4└ 0──────────┬────────── 4┘
                4┌ 0───────────────── 7^ 0───────────────── 4┐
               │             7   0  3Атомы 0  7   0            │
                4└ 0─────┬───────────┬───────────┬───── 4┘
              4┌ 0─────── 4┘ 0           │            4└ 0──────── 4┐
      4┌ 0─────── 7^ 0──────── 4┐ 0  4┌ 0──────── 7^ 0───────── 4┐ 0  4┌ 0──────── 7^ 0──────── 4┐
     │  1Числовые атомы 0 │ │  1Литеральные атомы 0│ 1  0│ 1 Строковые атомы 0 │
     │  1    0( 1числа 0) 1     0 │ │ ( 1идентификаторы 0) 1  0│ │                 │
      4└ 0───┬────────┬─── 4┘ 0  4└ 0────┬────────┬──── 4┘ 0  4└ 0────────┬──────── 4┘
         │        │          │         4└ 0───────────── 4┐ 0  4└ 0─────── 4┐
         │         4└ 0───── 4┐ 0     4└ 0─────────── 4┐ 0          │         │
    4┌ 0───── 7^ 0───── 4┐ 0  4┌ 0────── 7^ 0─────────── 4┐┌ 0─── 7^ 0─── 4┐┌ 0───── 7^ 0───── 4┐┌ 0── 7^ 0─── 4┐
   │Целые числа│ │Вещественные числа││Символы││Специальные││Строки│
   │           │ │                  ││       ││  символы  ││      │
    4└ 0┬─────────┬ 4┘ 0  4└ 0──────┬─────────┬─ 4┘└ 0─────┬─ 4┘└ 0─────┬───── 4┘└ 0──┬─── 4┘
  4┌ 0── 7^ 0────── 4┐┌ 0─ 7^ 0─── 4┐ 0  4┌ 0─── 7^ 0──── 4┐┌ 0─── 7^ 0─── 4┐ 0  4┌ 0── 7^ 0─── 4┐ 0  4┌ 0── 7^ 0─── 4┐ 0  4┌ 0─── 7^ 0─── 4┐
 │   Тип   ││ Тип │ │  Тип   ││  Тип  │ │ Тип  │ │ Тип  │ │ Тип   │
 │  2Integer 0 ││  2Int  0│ │  2Double 0 ││  2Float 0 │ │  2Char 0 │ │  2Bool 0 │ │  2String 0│
  4└ 0───────── 4┘└ 0───── 4┘ 0  4└ 0──────── 4┘└ 0─────── 4┘ 0  4└ 0────── 4┘ 0  4└ 0────── 4┘ 0  4└ 0─────── 4┘

 ш1.2
   Формальное описание синтаксиса  приведённых  выше  типов  данных
представим в форме Бэкуса-Наура.
   Наименование простейших типов данных должно начинаться с  _ 1пропис-
 _ 1ной . 0 ( _ 1заглавной . 0)  _ 1латинской буквы . 0.
    21. 0  2Integer 0 - имя типа данных для представления целых чисел с  1лю-
 1бым 0 (более точно,  потенциально бесконечным)  количеством  значащих
цифр (" 1бесконечное 0"  1целое 0).
 ш1.0

   < 1Целый_числовой_атом 0>::=( 2+ 0│ 2- 0)< 1Десятичное_число 0>

                           │( 2+ 0│ 2- 0) 20o 0< 1Восьмеричное_число 0>

                           │( 2+ 0│ 2- 0) 20O 0< 1Восьмеричное_число 0>

                           │( 2+ 0│ 2- 0) 20x 0< 1Шестнадцатеричное_число 0>

                           │( 2+ 0│ 2- 0) 20X 0< 1Шестнадцатеричное_число 0>
                                  7%%
                           1Цифра 0── 4┘└ 0── 1Латинская буква

   < 1Цифра 0>                  ::= 21 0│ 22 0│ 23 0│ 24 0│ 25 0│ 26 0│ 27 0│ 28 0│ 29 0│ 20

   < 1Восьмеричная_цифра 0>     ::= 21 0│ 22 0│ 23 0│ 24 0│ 25 0│ 26 0│ 27 0│ 20

   < 1Шестнадцатеричная_цифра 0>::= 21 0│ 22 0│ 23 0│ 24 0│ 25 0│ 26 0│ 27 0│ 28 0│ 29 0│ 20 0│ 2A 0│ 2B 0│ 2C 0│ 2D 0│ 2E 0│ 2F
                                  1│ 2a 0│ 2b 0│ 2c 0│ 2d 0│ 2e 0│ 2f

   < 1Десятичное_число 0>::=< 1Цифра 0>│< 1Цифра 0>< 1Десятичное_число 0>

   < 1Восьмеричное_число 0>::=< 1Восьмеричная_цифра 0>
                          │< 1Восьмеричная_цифра 0>< 1Восьмеричное_число 0>

   < 1Шестнадцатеричное_число 0>::=< 1Шестнадцатеричная_цифра 0>
                │< 1Шестнадцатеричная_цифра 0>< 1Шестнадцатеричное_число 0>

 ш1.2
    2Примеры 0 ( 1записи чисел типа Integer 0).
 ш1.0

   0,  1+ 0123,  1- 01111111,  1- 00o5432,  1+ 00O345,  1+ 00x8A6F,  1- 00X0BCD21E

 ш1.2
    22. 0  2Int 0 - имя типа данных для представления целых чисел, входящих
в интервал [-2147483648,2147483647].
    2Примеры 0 ( 1записи чисел типа Int 0).
 ш1.0

   0,  1+ 0123,  1- 02147483648, 0o200000000,  1+ 00O345,  1+ 00x8000000,  1- 00X07FDE
                                        7%%
                                 1Цифра 0── 4┘└ 0── 1Латинская буква

 ш1.2
    23. 0  2Float 0 - имя типа данных для представления десятичных чисел  с
плавающей точкой.
   Значениями данных этого типа являются  1рациональные числа 0 (!)  из
диапазона: 3.4 77 010 5-38 7_ 03.4 77 010 538 0.
    2Примеры 0 ( 1записи чисел типа Float 0).
 ш1.0

   +12.234, -0.987654, -5.34e-12, 2147483648.30e+10

 ш1.2
    24. 0  2Double 0 - имя типа данных для представления десятичных чисел с
плавающей точкой двойной точности.
   Значениями данных этого типа являются  1рациональные числа 0 (!)  из
диапазона: 1.7 77 010 5-308 7_ 01.7 77 010 5308 0.
 ш1.0

   < 1Числовой_атом_с_плавающей_точкой_двойной_точности 0>::=
           ( 2+ 0│ 2- 0)< 1Десятичное_число 0> 2. 0< 1Десятичное_число 0>[< 1Экспонента 0>]
           │( 2+ 0│ 2- 0)< 1Десятичное_число 0>< 1Экспонента 0>

   < 1Экспонента 0>::=( 2e 0│ 2E 0)[ 2+ 0│ 2- 0]< 1Десятичное_число 0>

 ш1.2
    2Примеры 0 ( 1записи чисел типа Double 0).
 ш1.0

   +1234.2343, -0.9876543210, -5.34567e-12, 21474648.2147483630e+50

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Числа с плавающей точкой " 1стремятся к потере точности 0".

 ш1.2
    25. 0  2Char 1  0- имя типа данных для представления  1литералов 0 - объектов
языка программирования, занимающих в памяти один байт (8 битов).
   На базе этого типа данных формируются  1символьные 0 и  1строковые ли-
 1тералы 0.
    2Примеры 0 ( 1записи символьных и строковых литералов 0).
 ш1.0

    21. 0 'Q', 'u', '?', '0', ':', '\n'.

    22. 0 "Q", "u", "?", "0", ":", "\n", "2", "8".

 ш1.2
    3Замечание 0.
 ш1.1
   Транскрипция слова " 1char 0" начинается со звука " 1к 0", а не " 1ч 0", так
что устоявшееся в русском языке произношение  название  символьного
типа  - " 1чар 0" является некорректным и может быть не понято програм-
мистами из  _ 1англоязычных . 0 стран.

 ш1.2
    26. Bool 0  - имя типа данных для представления результата выполне-
ния логических  1операций 0 (см. далее).
   Значениями данных этого типа являются два значения:
 ш1.0

   True, False.

 ш1.2
    3Замечание 0 ( 1для знатоков алгебраических типов данных 0).
 ш1.1
   В языке Haskell булевский тип не является встроенным,  а опреде-
ляется в виде  1алгебраического типа данных
 ш1.0

   data Bool = True | False

 ш1.2
    27. String 0 - имя типа данных для представления  _ 1строк .  0─ последова-
тельности символов,  начинающейся и заканчивающейся кавычками (").
   Строки отличаются  от  литералов тем,  что могут содержать в ка-
честве элементов  1разделители 0: пробелы, точки, запятые и т.д., но не
должны содержать внутри себя символа " 1кавычка 0" (").
    3Замечание 0 ( 1для знатоков 0).
 ш1.1
   Остальные типы можно получить из перечисленных выше  при  помощи
операций  конструирования типов,  которые называются  1конструкторами
 1типов 0.

 ш1.2
                              3Операции
    2Определение 0.
 ш1.1
    _ 1Операциями . 0 ( 1в  программировании 0)  называются  функции  1одного 0 или
 1двух 0 аргументов.

 ш1.2
   В языке Haskell  _в основном . используется  1инфиксная запись  бинар-
 1ных операций 0.
   Пусть  7S 0 - алфавит,  7Q 0 - это множество букв, обозначающих бинарные
операции,  7G 0  ═+ 0 {(,)}.
    2Определение 0 ( 1повторение 0).
 ш1.1
    _ 1Инфиксная форма записи . 0 - это цепочка в алфавите  7SuQuG 0,  обладаю-
щая следующей индуктивно заданной структурой:
    2(1) 0 если x 7еS 0, то x является  1инфиксной формой записи 0;
    2(2) 0 если A и B - инфиксные цепочки и  7rеQ 0,  то (A 7r 0B) является  1ин-
 1фиксной формой записи 0;
    2(3) 0 никакие другие цепочки не являются  1инфиксными формами записи 0.

 ш1.2
    2Примеры 0 ( 1инфиксной формы записи операций 0).
 ш1.0

   1+2, (1-5)+34, 55/((45+23)*4).

 ш1.2
   Если имя операции является последовательностью  букв  ( 1текстовым
 1обозначением 0),  то  оно заключается в  1обратные кавычки 0 (``) (напри-
мер,  `rem`, `mod`, `div`) и используется по-прежнему инфиксным об-
разом, т.е.
 ш1.0

   34 `rem` 5.

 ш1.2
   В языке  Haskell  возможно также использование  1префиксной записи
 1бинарных операций 0: например,
 ш1.0

   rem 34 5.

 ш1.2
   Наконец, разрешается использование  1секционирования 0.
    2Определение 0.
 ш1.1
    _ 1Секционированием . 0 называется преобразование записи применения ин-
фиксной функции в виде x `f` y в префиксную форму записи применения
(f) x y.

 ш1.2
   Операции обладают  1приоритетом 0 и  1ассоциативностью 0.
    2Определение 0.
 ш1.1
    _ 1Приоритетом операции . 0  называется номер операции в очереди опера-
ций, используемых при вычислении значения некоторого выражения; чем
больший номер имеет операция, тем быстрее она будет выполнена.

 ш1.2
    2Пример 0 ( 1использования приоритета 0).
 ш1.1
   Выражение 3-4*2 интерпретируется как 3-(4*2),  т.к.  операция  *
имеет более высокий приоритет, чем операция -.

 ш1.2
   По приоритету (силе "связывания")  операции  делятся  на   _ 1десять
 _ 1групп . 0,  в  соответствии с уровнем приоритета от 0 до 9 включительно
(уровень 0 "связывает" операнды  1наименее сильно 0, а уровень 9 -  1наи-
 1более сильно 0).
   Наивысшим приоритетом обладает  1операция 0  1применения функции 0.
    2Определение 0.
 ш1.1
    _ 1Ассоциативностью . 0 ( 1в программировании 0) называется  последователь-
ность применения одинаковых операций в выражении.
   Ассоциативность определяет однозначный способ восстановления от-
сутствующих скобок в выражении.

 ш1.2
   По способу ассоциативности операции делятся на три вида:
 ш1.1
   (1)  1левоассоциативные 0  (infixl);
   (2)  1правоассоциативные 0 (infixr);
   (3)  1неассоциативные 0    (infix).

 ш1.2
   Применение неассоциативных  операций  несколько  раз в выражении
может привести к ошибке.
    2Пример 0 [Душкин,2007,с.587].
 ш1.1
   (8-2)-1=5 ( 1правильное 0 использование ассоциативности операции -);
   8-(2-1)=7 ( 1ошибочное 0 использование ассоциативности операции -);
   2==(1+1)==(3-1)
             ( 1ошибочное 0 использование неассоциативной операции).

 ш1.2
   Приведём  _ 1таблицу приоритетов операций . 0, определённых в библиотеке
Prelude, вместе с типом ассоциативности:
 ш1.0

   ┌─────────╥─────────────────┬───────────────┬──────────────────┐
   │ 3Приоритет 0║ 3Левоассоциативные 0│ 3Неассоциативные 0│ 3Правоассоциативные 0│
   │         ║ 3операции 0         │ 3операции 0       │ 3операции 0          │
   ╞═════════╬═════════════════╪═══════════════╪══════════════════╡
   │     39 0    ║ !!              │               │  2. 0                │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     38 0    ║                 │               │ ^, ^^, **        │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │         ║ *, /,           │               │                  │
   │     37 0    ║ `div`, `quot`,  │               │                  │
   │         ║ `mod`, `rem`,   │               │                  │
   │         ║ :%, %           │               │                  │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     36 0    ║ +, -            │               │                  │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     35 0    ║                 │               │ :, ++            │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │         ║                 │ ==, /=, <, <=,│                  │
   │     34 0    ║                 │ >, >=, `elem`,│                  │
   │         ║                 │ `notElem`     │                  │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     33 0    ║                 │               │ &&               │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     32 0    ║                 │               │ ||               │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     31 0    ║ >>, >>=         │               │ =<<              │
   ├─────────╫─────────────────┼───────────────┼──────────────────┤
   │     30 0    ║                 │               │ $, $!, `seq`     │
   └─────────╨─────────────────┴───────────────┴──────────────────┘

 ш1.2
    2Примеры 0 ( 1вычислений с помощью некоторых операций 0).
 ш1.0

    21. 0 Prelude> 2^4          22. 0 Prelude> 2.3**1.2
      16 :: Integer           2.7169 :: Double

    22. 0 Prelude> 2.4^5
      79.6262 :: Double

 ш1.2
                             3Комментарии
   Для пояснения назначения программы и некоторых её частей исполь-
зуют комментарии.
    _ 1Строчный 0  1комментарий . 0 начинается с  последовательности  двух  или
более  следующих  друг за другом символов "-" (тире) и простирается
до первого символа новой строки.
    _ 1Вложенный комментарий . 0 начинается с сочетания символов "{-" и за-
канчивается сочетанием  символов "-}",  при этом он может быть вло-
женным на любую глубину.
                        3Описание типа функции
                        ( 1сигнатура функции 0)
   В функциональном языке используется  _ 1статическая проверка  типов . 0,
т.е.  любое значение,  любое выражение,  любая функция должны иметь
определённый тип до начала процесса выполнения.
   Таким образом,  функции "ожидают" на вход только аргументы,  тип
которых  соответствует  описанному в определении функции типу аргу-
ментов, иначе на этапе выполнения программы возникнет ошибка, кото-
рая называется  _ 1ошибкой несоответствия типов . 0.
   Для указания типа в синтаксисе языка имеется специальный символ
 ш1.0

   "::" (читается: " 1имеет тип 0").

 ш1.1
   Описание типа функции выглядит так же,  как и  в  математической
нотации,  за исключением того,  что символ "─ 76 0" кодируется  1лексемой
"->", которая обозначает  _ 1операцию аппликации для типа функции . 0.
   Операция аппликации для типа функции является  1правоассоциативной
 1операцией 0.
    2Пример 0 ( 1сигнатуры функции 0).
 ш1.1
   Опишем эквивалентными  способами тип функции,  имеющей два цело-
численных аргумента и возвращающей число типа Double:
 ш1.0

                                  ═о 5Скобки не используются
   (1) someFn:: Int -> Int -> Double
                                     ═о 5Правая ассоциативность
   (2) someFn:: Int -> (Int -> Double)
                                       ═о 5Префиксная форма записи типа
   (3) someFn:: (->) Int ((->) Int Double)

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Полиморфным типом . 0 называется тип,  в описании которого использу-
ются   1переменные  типов 0,  обозначаемые строчными буквами латинского
алфавита.  При этом тип, к которому относится переменная, определя-
ется неявно из контекста, в котором она появилась.

 ш1.2
   Переменные типов приобретают значения  в  зависимости  от  типов
данных, поступающих на вход функции; они детерминированы и не могут
иметь разные значения в разных местах записи функции.
    2Пример 0.
 ш1.1
   Опишем тип функции f,  принимающей на вход два аргумента и возв-
ращающей булево значение (True или False):
 ш1.0

   f:: b -> b -> Bool

 ш1.1
   Если на вход функции f поступят два целых числа,  то  переменная
типов b получит значение Integer;  если же на вход поступят два ве-
щественных числа, то переменная типов b получит значение Double.

 ш1.2
                         3Постоянные функции
    1Функциональная программа 0  представляет  собой  набор определений
(деклараций) функций,  которые могут определяться с помощью  других
функций или  1рекурсивно 0 - через самих себя.
   Используя язык   функционального  программирования,  программист
обязан представить решение задачи в виде совокупности взаимосвязан-
ных  функций,  вычисление значений которых приведёт к желаемому ре-
зультату.
   Итак, в языке Haskell есть только функции (переменных нет).
   Имена функций начинаются только со  _ 1строчных букв . 0.
   Иногда имена функций (как, впрочем, и имена типов) заканчиваются
символом "'";  данный  символ  не имеет специального значения и ис-
пользуется для обозначения схожих понятий,  незначительно  отличаю-
щихся друг от друга.
    2Определение 0.
 ш1.1
    _ 1Постоянные функции . 0 - это функции без аргументов,  множество зна-
чений которых состоит из одного элемента.
   Постоянные функции имеют следующий синтаксис:
 ш1.0

   < 1Имя_функции 0>=< 1Выражение 0>

 ш1.2
   Значением функции является значение вычисленного выражения.
    2Пример 0 ( 1постоянных функций 0).
 ш1.0

   a = 3.0; b = 4.0; c = 5.0
   s = 1/2*a*b

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 1.

                    3Определение функций с помощью
                         3условных выражений

 ш1.0
                        1Программист ложится спать и ставит рядом два
                        1стакана 0: 1 один с водой, на случай, если захо-
                        1чет пить, другой - пустой, если не захочет. 0
                                                             1Анекдот
 ш1.2

   Для организации  _ 1простого ветвления . 0,  имеющего две  альтернативы,
используется  синтаксическая  конструкция 1  0(x 41 0,x 42 0,...,x 4n 0 - аргументы
функции):
 ш1.0

   < 1Имя_функции 0> 1  0x 41 0 x 42 0 ... x 4k 0 =  2if 0 < 1Условное_выражение 0>
                                   2then 0 < 1Выражение_1 0>
                                   2else 0 < 1Выражение_2 0>

 ш1.2
   Если значение < 1Условное_выражение 0> истинно, то возвращается зна-
чение < 1Выражение_1 0>, в противном случае - значение < 1Выражение_2 0>.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
    3Замечание 0.
 ш1.1
   Условное выражение - это механизация слова " 1если 0" в естественном
языке.

 ш1.2
   Для организации 1  _множественного ветвления . 0  используется  ключевые
слова 1  2case 0 и 2 of
 ш1.0

   < 1Имя_функции 0> x 41 0 x 42 0 ... x 4k 0 =  2case 0 (x 41 0,x 42 0,...,x 4k 0)  2of
                                 (v 411 0,v 421 0,...,v 4k1 0)  2-> 0 < 1Выражение_1 0>
                                                   ...
                                 (v 41n 0,v 42n 0,...,v 4kn 0)  2-> 0 < 1Выражение_n 0>

 ш1.2
   Здесь x 41 0,x 42 0,...,x 4n 0 - аргументы функции, v 4m1 0,v 4m2 0,...,v 4mn 0 - образ-
цы выражения,  соответствующие аргументу функции x 4m 0, многоточия за-
меняют пропущенные образцы и варианты их значений.
   После ключевого слова  2case 0 идёт выражение, на основании значения
которого производится ветвление.  После выражения записывается клю-
чевое слово 2  of 0,  вслед за которым идёт набор образцов,  с которыми
сопоставляется выражение оператора.
    1Первый сверху 0 образец,  с которым успешно сопоставилось значение
выражения,  определяет ветвь ветвления,  которая выбирается для вы-
числения.  Это значит,  что образцы, в принципе, могут определять и
пересекающиеся множества значений.
   Данная конструкция позволяет записывать программы с помощью  од-
ного клоза.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 3, Пример 3 41 0.

 ш1.2
   Простое ветвление может быть записано в виде:
 ш1.0

   < 1Имя_функции 0> 1  0x 41 0 x 42 0 ... x 4k 0 =  2case 0 (< 1Условное_выражение 0>)  2of
                                     (True)  -> < 1Выражение_1 0>
                                     (False) -> < 1Выражение_2 0>

 ш1.2
    3Замечание 0.
 ш1.1
   Существует "золотое" правило: применяйте везде, где это возможно
конструкцию 1 case 0 вместо вложенных конструкций 1 if...then...else 0.
 ш1.2

                    3Определение функций с помощью
                        3охраняющих выражений

 ш1.0
                         1Такие средства включены в язык сверх мощной
                         1технологии сопоставления с образцом. 0
                                                          1Р.В.Душкин
 ш1.2

    2Определение 0.
 ш1.1
    _ 1Охраняющим выражением . 0 называется выражение,  накладывающее огра-
ничения на аргументы функции и возвращающее значение True или False.

 ш1.2
   Определение функций с помощью охраняющих выражений имеет следую-
щий синтаксис:
 ш1.1

   < 1Имя_функции 0> x 41 0 x 42 0 ... x 4k 0 | < 1Условие_1 0> 2  0= 2  0< 1Выражение_1 0>
                              | < 1Условие_2 0> 2  0= 2  0< 1Выражение_2 0>
                                           ...
                              |  2otherwise  0  = 2  0< 1Выражение_n 0>

 ш1.2
   При определении функции  _ 1охраняющие выражения . 0 (< 1Условие_i 0>,  i 7еN 0;
 2otherwise 0) записываются после  _ 1образцов . 0 (x 41 0,x 42 0,...,x 4k 0), но перед вы-
ражениями,  являющими собой описание вычислительного процесса (< 1Вы-
 1ражение_i 0>, i 7еN 0).  Символ "|" используется для разграничения образ-
цов и охраняющих выражений.
   Просмотр охраняющих выражений производится сверху вниз до перво-
го выражения,  значение которого истинно;  в этом случае  значением
функции будет являться значение выражения, записанное после найден-
ной охраны.  На этом этапе вычислительный процесс останавливается и
оставшиеся охраняющие выражения игнорируются.
    3Замечание 0.
 ш1.1
   Вместо служебного слова  2otherwise 0 можно использовать слово True,
которое называется  1конструктором типа 0.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4, Пример 5.

 ш1.2
                    3Определение функций с помощью
                      3сопоставления 0  3с образцом
    2Определение 0 [Душкин,2007,с.120,121].
 ш1.1
    2(1) 0  _ 1Клоз . 0 (от англ.   1clause 0) -  это  запись  варианта  вычисления
функции,  зависящая от вида  1образцов 0, записанных правее имени функ-
ции:
 ш1.0

   < 1Имя_функции 0> [Образец 41 0 Образец 42 0 ... Образец 4n 0] = < 1Выражение 0>

 ш1.1
   Количество образцов  равно  количеству  аргументов  определяемой
функции.
    2(2) 0  _ 1Образец . 0 (от англ.  1pattern 0 -  1калька 0) - это выражение, постро-
енное с помощью операций конструирования данных,  которое использу-
ется в определениях функций для сопоставления с данными.
    2(3) 0  _ 1Пустой образец . 0  2_ 0 ( 1символ подчёркивания 0) - это образец,  зна-
чение которого не используется при вычислении выражения.

 ш1.2
    2Примеры 0 ( 1образцов 0).
 ш1.0

   5, x, x+4, _.

 ш1.2
   При сопоставлении образца с данными означивание переменных, вхо-
дящих в состав образца, должно происходить  1единственным образом 0, не
допускающим неоднозначностей.
    2Примеры 0.
 ш1.1
    21. 0 Выражение
 ш1.0

   (1+x)

 ш1.1
является образцом,  поскольку при сопоставлении  его,  например,  с
константой  5,  "означивание"  ( 1присваивание значения 0) переменной x
будет происходить единственным образом (x=4).
    22. 0 Выражение
 ш1.0

   (x+y)

 ш1.1
образцом быть  не может,  поскольку "означить" переменные x и y при
сопоставлении с константой можно различными способами.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Определением функции в языке Haskell . 0  называется  последователь-
ность  1клозов 0 (возможно,  состоящая из одного элемента),  каждый  из
которых пишется на отдельной строке.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6.

 ш1.2
                       3Операции, определяемые
                            3программистом
   Ассоциативность и приоритет операции задаётся с помощью объявле-
ния, которое называется  1infix- _объявлением . 0 и имеет такой синтаксис:
 ш1.0

   <infix-объявление>::=< 1Ассоциативность 0> [< 1Приоритет 0>]
                        Операция 41 0, Операция 42 0,..., Операция 4n

   < 1Ассоциативность 0>::=infixl│infixr│infix

   < 1Приоритет 0>::= 0│1│2│3│4│5│6│7│8│9

 ш1.2
   infix-объявление можно разместить всюду,  где  можно  разместить
 _ 1сигнатуру типа . 0 ( _ 1объявление типа . 0,  _ 1назначение типа . 0). Для любой опера-
ции можно задать не более одного infix-объявления.
   По умолчанию (если отсутствует infix-объявление) операция счита-
ется объявленной как
 ш1.0

   infixl 9

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7, Пример 7 41 0.

 ш1.2
   Отметим, что программисты,  использующие  язык  Haskell,  обычно
стараются избавиться от  1скобок 0 всюду, где это возможно.

                       3Понятие "чистота языка
                          3программирования"

 ш1.0
              1Что было трудно, так это найти добровольцев для работы
              1с  мелочами.  В языках огромное множество мелких дета-
              1лей... Масса деталей в библиотеках. Романтики никакой,
              1но делать это необходимо. 0
                     1Пейтон-Джонс С. 0 ( 1один из авторов языка Haskell 0)
 ш1.2

   Язык Haskell обладает  1свойством чистоты 0.
    2Определение 0.
 ш1.1
   Говорят,  что   _ 1язык программирования обладает свойством чистоты . 0,
если функции, определяемые и используемые в языке:
   (1) не являются  1недетерминированными 0, т.е. результат их выполне-
ния зависит исключительно от значений аргументов;
   (2) не могут иметь  1побочных эффектов 0.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Недетерминированными функциями . 0 называются функции,  для  которых
вызов  функции дважды с одним и тем же набором значений входных ар-
гументов может привести к тому, что в качестве результата возвраща-
ются разные значения.
   Другими словами,  _ 1недетерминированность функции . 0 - это возможность
возвращения функцией разных значений,  несмотря на то, что ей пере-
даются на вход одинаковые значения входных аргументов.

 ш1.2
   Итак, для недетерминированных функций их таблицы значений выгля-
дели бы как  1список 0 (возможно, бесконечный)  возможных значений, ко-
торые она принимает на заданном наборе входных параметров.
    2Определение 0.
 ш1.1
    _ 1Побочным эффектом функции . 0  ( 1в программировании 0) называется  воз-
можность в процессе выполнения вычислений:
   (1) чтения и модификации значений параметров, переданных в функ-
цию,  т.е. по сути возможность деструктивного  1присваивания 0, когда в
процессе вычисления выходного значения функции изменяется и  значе-
ние входного параметра;
   (2) осуществления операций ввода/вывода;
   (3) реагирования  на  1исключительные ситуации 0 и вызов их обработ-
чиков.

 ш1.2
   Заметим, что  в  математике  функции не имеют побочных эффектов,
поскольку отсутствует понятие " 1переменная 0".
   Итак, в чистом функциональном программировании:
 ш1.1
   (1) отсутствует оператор присваивания;
   (2) объекты нельзя изменять и уничтожать, можно только создавать
новые путём декомпозиции и синтеза существующих;
   (3) все функции свободны от побочных эффектов;  более точно, ут-
верждается,  что функциональные языки отличаются от  других  языков
тщательным контролем над побочными эффектами.

 ш1.2
   Тем не менее,  функции с побочными эффектами полностью убрать из
языков функционального программирования нельзя.  В  первую  очередь
это относится к вводу/выводу;  любая операция ввода данных от поль-
зователя является действием с побочным эффектом,  т.к. нельзя зара-
нее предвидеть,  что именно введёт пользователь в качестве значений
параметров, использующихся в вычислительном процессе.
   Однако сложно  представить  себе язык программирования,  где от-
сутствует возможность осуществлять ввод данных  от  пользователя  в
интерактивном режиме, а также осуществлять вывод данных.
    3Замечание 0 ( 1важное 0) [Душкин,2007,с.54].
 ш1.1
   Для обеспечения возможности использования ввода/вывода без  ума-
ления свойства  чистоты во многих языках функционального программи-
рования,  в том числе и в языке Haskell,  используется  специальный
механизм, названный  _ 1монадой . 0.
   Монады в определённом смысле "обёртывают" необходимые императив-
ные свойства,  не допуская их смешивания с чистым синтаксисом функ-
ционального языка.  Использование монад позволило реализовать узкие
места, которые регламентировали наличие побочных эффектов функций.
   Например, для обеспечения ввода/вывода в языке Haskell  реализо-
вана  _ 1стандартная  монада . IO 0,  минуя которую невозможно выполнить ни
одной операции ввода/вывода.

 ш1.2
                3Инструментальное средство разработки
                            3языка Haskell
    _ 1Инструментальное средство 0  1HUGS 0  198 . 0 -  это  программный  комплекс,
предназначенный  для  автоматизации  процесса составления,  отладки
программы на языке программирования Haskell и подготовки её  к  вы-
полнению. HUGS 98 включает в себя:
 ш1.1
   (1)  1интерпретатор 0 языка программирования Haskell стандарта  1998
года (Haskell-98);
   (2) интегрированную среду программирования.

 ш1.2
   Интерпретатор Hugs - это один из интерпретаторов Haskell, назва-
ние которого является аббревиатурой слов " 3H 1askell  3u 1ser's  3G 1ofer  3s 1ys-
 1tem 0", где  Gofer - это название языка программирования,  являющийся
одним из предшественников языка Haskell.
   Для запуска инструментального средства HUGS 98 требуется файл
 ш1.0

    1winhugs.exe

 ш1.2
   После запуска  указанного  файла  появится  1диалоговое окно 0 среды
разработчика со стандартным приглашением к работе
 ш1.0

   Prelude 2>

 ш1.2
и автоматически загрузится файл  1Prelude.hs 0,  содержащий определения
типов стандартных функций языка Haskell и их реализацию.
    3Замечание 0.
 ш1.1
   Перед символом приглашения к работе " 2> 0" выводится имя последнего
загруженного модуля.

 ш1.2
    _ 1Диалоговое окно среды разработчика . 0 состоит из:
 ш1.1
   (1) главного меню;
   (2) набора кнопок для быстрого доступа к наиболее часто  исполь-
зуемым командам;
   (3) консоли (см.  Приложение), в которой происходит работа с ин-
терпретатором. Консоль обеспечивает доступ ко всем командам инстру-
ментального средства HUGS 98.

 ш1.2
   В среде HUGS 98 отсутствует  1текстовый  редактор 0,  однако  в  ней
можно вызвать на редактирование открытые программные модули,  кото-
рые загрузятся в стандартном окне Notepad,  встроенном в операцион-
ную систему Windows любой версии.
   Создание и редактирование файлов с кодами программ можно  произ-
водить в  любом  текстовом редакторе,  поддерживающим стандарт ANSI
(например, блокнот Windows).
   Помимо оконного интерфейса среда HUGS 98 имеет и  более  простой
вид, который называется  _ 1консольной строкой . 0.
   Для запуска среды в таком виде требуется файл
 ш1.0

    1hugs.exe

 ш1.2
   Выход из среды HUGS 98 производится либо с помощью кнопки закры-
тия окна, либо с помощью команды на панели инструментов:
 ш1.0

   File -> Exit,

либо с помощью команды консоли:

   Hugs> 2:quit 0                                             ║ Hugs> 2:q

 ш1.2
                       3Биографические сведения
 ш1.1
    21. 0  _ 1Шейнфинкель Моисей Исаевич . 0 (04.09.1887(1889?),  Екатеринослав
- 1.09.1942, Москва) - советский математик, предшественник комбина-
торной логики,  отличался оригинальностью выдвигаемых им идей. Изу-
чал математику в г.Одессе в Новороссийском университете.  Его руко-
водителем  был  С.О.Шатуновский  -  известный российский математик,
много внимания уделявший вопросам геометрии и её оснований.  В 1914
М.Шейнфинкель  приезжает  в  Гёттинген  к Д.Гильберту.  Известность
пришла к М.Шейнфинкелю благодаря докладу,  который он сделал 7  де-
кабря  1920  перед Математическим обществом Гёттингена.  Д.Гильберт
рекомендовал доклад к публикации,  которая и была осуществлена  че-
тырьмя  годами  позже в математическом журнале "Mathematische Anna-
len". Помощь в подготовке публикации оказал Г.Беман.
   В Гёттингене М.Шейнфинкель тесно общался с П.Бернайсом,  который
был его ровесником.  В 1929 ими была подготовлена совместная публи-
кация, посвящённая проблеме разрешимости для одного частного класса
формул исчисления предикатов. К тому времени М.Шейнфинкель уже вер-
нулся в СССР.  Последние годы жизни он провёл в Москве, где страдал
от нищеты,  лечился  от  психического  расстройства и умер в 1942 в
госпитале. Ни точная дата смерти,  ни место погребения  неизвестны.
Во время  войны,  чтобы  хоть  как-нибудь согреться,  бывшие соседи
М.Шейнфинкеля сожгли все его рукописи в печи.
   При всей ясности изложения результаты  М.Шейнфинкеля  были  нас-
только необычны,  что требовали глубокого осмысления. Он всего лишь
заложил первый камень в исследования по комбинаторной логике, но не
успел оформить их в законченную систему. Её современным видом и са-
мим термином мы обязаны  1Хаскеллу Бруксу  Карри 0,  который  самостоя-
тельно переоткрыл комбинаторную логику и вдохнул в неё жизнь.
    22. 0  _ 1Карри Хаскелл Брукс . 0  (12.09.1900-01.09.1982)  -  американский
математик, логик и философ. Им разработаны основы  1комбинаторной ло-
 1гики 0 (пользующейся системой исходных функций, называемых комбинато-
рами),  которая, в свою очередь, явилась стимулом становления пара-
дигм аппликативного и функционального программирования. Существенно
повлиял на развитие   1математической  логики 0  (логики  Чёрча-Карри).
Программа  его исследований способствовала становлению конструктив-
ного подхода к анализу оснований математики. Способствовал формиро-
ванию направлений  1структурализм 0 и  1формализм 0 в метаматематике.
   В честь Х.Карри были названы языки  программирования  Haskell  и
Curry (создан на основе языка Haskell).
   Основными трудами являются:
   [1] Curry H.B.,  Feys R. Combinatory Logic. - Vol. I, North-Hol-
land Co., Amsterdam, 1958.
   [2] Curry  H.B.,  Hindley  R.,  Seldin  J.P.  Combinatory Logic.
- Vol. II. Studies in Logic 65, North-Holland Co., Amsterdam, 1972.
   [3] Карри Х.Б. Основания математической логики. - М.: Мир, 1969.
- 568 с.
   В [3] выполнено детальное изучение основных понятий математичес-
кой логики.  Представлена общая теория формальных систем и исчисле-
ний. Обсуждены общие методологические вопросы, последовательно опи-
саны исчисления, содержащие импликацию, отрицание и кванторы.
   Рассмотрены вопросы теории модальностей.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
 ш1.0

   См. Пример 1, Пример 2, Пример 3, Пример 31, Пример 4,
       Пример 5, Пример 51, Пример 6, Пример 7, Пример 7 41 0.

    4┌ 0───────────────────────────────────────────── 4┐
   │Все демонстрационные примеры распространяются│
   │только с пометкой " 1General Public License 0".  │
    4└ 0───────────────────────────────────────────── 4┘

 ш1.2
    3Замечание 0 ( 1важное 0) (по [Рэймонд,1996,с.152,242]).
 ш1.1
    _ 1Copyleft . 0 -  это  пометка " 1General Public License 0" в графе об ав-
торских правах, имеется на GNU Emacs и др. программах Фонда свобод-
ного распространения программного продукта.
   Эта пометка позволяет бесплатно пользоваться  этими  программами
всем желающим,  но с некоторым условием,  а именно: все программы и
системы,  в которых (или для создания которых) используется в любом
виде и количестве лицензионный код copyleft, должны распространять-
ся на тех же условиях, что и GNU, т.е. бесплатно.
   Поэтому можно  утверждать,  что  copyleft  "заражает" программы,
применяющие инструментарий GNU,  эти программы, в свою очередь, мо-
гут заразить и сделать бесплатными другие программы, и в результате
инфицирование и,  следовательно,  бесплатность  всего  программного
продукта в мире будет всего лишь вопросом времени.
   Подобный "вирус" называется 1 Всеобщим бесплатным  вирусом 0  (англ.
 1General Public Virus 0).
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                                    1Мне страшно 0! 1 Пи-пи-пи 0! 1 - запищал
                                    1Мышонок 0  1и юркнул под крыльцо.
                                           1В.Сутеев. Кто сказал мяу 0?
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                      21. 3 Операционная 0  3семантика
                         3выражений и функций 0
    21. 0 Укажите ошибки в записи следующих выражений:
 ш1.0

   (1) 1+(2+(3+4);   (5) 7 rem 4;
   (2) False - 4;    (6) (-2.1234+(3-4))/(4.213/4-0.213);
   (3) 10 && True;   (7) 4 `div` (3*2-6).
   (4) 10 10;

 ш1.2
    22. 0 Выполнив следующую последовательность выражений  в  командной
строке, определите назначение системной переменной $$:
 ш1.0

   Prelude> (220+3)-1
   ...
   Prelude> $$
   ...
   Prelude> 444 `div` $$

 ш1.2
    23. 0 Определите,  какие  из  указанных ниже функций будут отмечены
интерпретатором неверными (объясните причину этого):
 ш1.0

   x1:: Integer; x1 = 14811
   x2:: Integer; x2 = -97531
   y1:: Double;  y1 = 0.12345
   y2:: Double;  y2 = -8765543.23
   z1:: Bool; z1 = True
   z2:: Bool; z2 = False
   ---------------------
   f1 = (x1-x2)/23
   f2 = x1 `div` x2
   f3 = x1+3.14-x2
   f4 = z1 && (y1>y2) || z2
   f5 = y2*x2-x1
   f6 = (y1+y2)>0 && (x1*x2)<0
   f7 = x2 `mod` 2 + y1

 ш1.2
                   22. 0  3Функции, содержащие условные
                              3выражения
    21 4* 2. 0 Напишите программу для вычисления значения функции:
 ш1.0

         7( 00, если x=0;
   f(x)= 7* 01, если x>0;
         79 0-1 в противном случае.

 ш1.2
    22 4* 2. 0 Напишите функцию, возвращающую модуль целого числа.
    23 4* 2. 0 Напишите программу для вычисления значения функции:
 ш1.0

             7( 0│x│-10, если x 7, 00;                7( 0│2 77 0x│, если x<-5 7v 0x>5;
   (1) f(x)= 7* 0                       (5) f(x)= 7*
             79 0x 52 0+x+1, если x>0;                79 0x 52 0-4, если -5 7, 0x 7, 05;

             7( 0x 53 0, если -35 7, 0x 7, 035;               7( 01+│x│, если x<-8 7v 0x>8;
   (2) f(x)= 7* 0                       (6) f(x)= 7*
             79 0│x│, если x<-35 7v 0x>35;            79 0x 53 0+x 52 0, если -8 7, 0x 7, 08;

             7( 0│x+2│, если x 7, 02;                 7( 0-32000-x, если x 7. 0127;
   (3) f(x)= 7* 0                       (7) f(x)= 7*
             79 0x 53 0-1, если x>2;                  79 0│x 53 0│, если x<127;

             7( 0│3-x│, если x>3;                 7( 0│x 52 0+1│, x<-128;
   (4) f(x)= 7* 0                       (8) f(x)= 7*
             79 0x 53 0+x 52 0, если x 7, 03;                 79 0x 55 0, если x 7. 0-128.

 ш1.2
    24 4* 2. 0 Напишите программу для вычисления значения функции (x,y 7е ═R 0):
 ш1.0

                 x 77 0y                 x 77 0y-4             │x-9│
   (1) f(x,y)= ───────;  (5) f(x,y)= ─────;   (9) f(x)=│───│;
               2 77 0(x+y)                x+y              │x-4│

               5 77 0(x-y)               2 77 0x-y              │x-1│
   (2) f(x,y)= ───────;  (6) f(x,y)= ─────;   (10) f(x)=│───│.
                 x+y                  x-y               │x+1│

                x-y                    x+y
   (3) f(x,y)= ─────;    (7) f(x,y)= ───────;
               x-2 77 0y                 2 77 0(x-y)

               x+10 77 0y                 x 77 0y
   (4) f(x,y)= ──────;   (8) f(x,y)= ─────;
                x-y                  2 77 0x-y

 ш1.2
    25 4* 2. 0 Напишите функцию, возвращающую наибольшее из трёх чисел.
    26 4* 2. 0 Напишите  функцию,  которая  по заданным сторонам квадрата и
прямоугольника определяет,  какая из этих двух фигур  (квадрат  или
прямоугольник) имеет большую площадь и периметр.
    27. 0 Напишите функцию, определяющую по заданным  3  0вещественным чис-
лам x и y номер квадранта, в котором расположена точка A(x,y).
    28 4* 2. 0 Напишите функцию,  которая по знаку арифметической  операции
выводит её название. Например, "+" - сложение.
    29 4* 2. 0 Напишите функцию, выводящую по номеру месяца его название.
    210. 0 Напишите функцию, возвращающая сумму цифр натурального числа
n<1000.
    211 4* 2. 0 Напишите  функцию,  аргументом  которой  является  символ и
возвращает True,  если аргумент - строчная или прописная буква  ла-
тинского алфавита; в противном случае функция возвращает False.
    212. 0 Сравните  приведённые ниже функции с точки зрения количества
сравнений:
 ш1.0

   min3 x y z                    ║  min3' x y z
       = if x<=y                 ║       = if x<=y && x<=z
           then if x<=z          ║           then x
                  then x else z  ║           else if y<=z
           else if y<=z          ║                  then y else z
                  then y else z  ║

 ш1.2
                            23. 0  3Предикаты
    21. 0 Напишите функцию,  определяющую,  принадлежит ли точка M(x,y)
 1кругу 0 с центром в точке (7.33,-21.1) и R=23.5, если x, y - заданные
действительные числа.
    22. 0 Напишите функцию, определяющую, принадлежит ли точка N(x,y,z)
 1шару 0 с центром в точке (1.5,200,-4.12) и R=72.8, если x, y, z - за-
данные действительные числа.
    23. 0 Напишите функцию,  определяющую,  принадлежит ли точка M(x,y)
 1окружности 0 с центром в точке (-1.2,0.1) и R=7, если x, y - заданные
действительные числа.
    24. 0 Напишите функцию, определяющую, принадлежит ли точка N(x,y,z)
 1сфере 0 с центром в точке (-0.5,1,-1.99) и R=91.19, если x, y, z - это
заданные действительные числа.
    25. 0 Напишите функцию, реализующую предикат, определяющий, образу-
ют ли три заданных целых числа арифметическую прогрессию.
    26. 0 Напишите  функцию,  определяющую,  является ли заданное целое
число чётным.
    27. 0 Напишите функцию, определяющую, применялась ли для записи це-
лого числа m<1000 только одна цифра.
    28. 0 Напишите  функцию,  определяющую,  входит ли цифра 7 в запись
данного натурального числа n<100000.
    29. 0 Напишите функцию,  определяющую, представляет ли собой задан-
ное четырёхзначное натуральное число  1палиндром 0.
    210 5* 2. 0 Напишите функцию,  определяющую, является ли заданное нату-
ральное число 2  1простым числом 0.

                         2Контрольные задания
                        (10.02 1- 010.02.2021)
    21 4* 2. 0 Укажите назначение следующих функций:
 ш1.0

   (1) seven:: Integer -> Bool
       seven r = if (r<0) || (r>10000)
                   then error "0<r<10000"
                   else  2    0(r `div` 1000)==7
                        || ((r `mod` 1000) `div` 100)==7
                        || (((r `mod` 1000) `mod` 100) `div` 10)==7
                        || (r `mod` 10)==7

   (2) pal:: Integer -> Bool
       pal m = if (m<1000) || (m>9999)  
                 then error "0<r<10000"
                 else  2   0(((m `div` 100) - ((m `div` 1000)*10))*10)
                      + (m `div` 1000) == m `mod` 100

 ш1.2
    22 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (а) xxx s = s>='0' && s<='7';
   (б) yyy s = s>='0' && s<='9';
   (в) zzz s = s>='A' && s<='F' || s>='a' && s<='f';

 ш1.2
    23. 0 Напишите функцию, возвращающую наибольшее из четырёх чисел.
    24. 0 Напишите функцию,  подсчитывающую  _ 1число рождения . 0, которым на-
зывается сумма всех цифр указанной даты.
   Например, у  человека,  рождённого  20 декабря 1550 года,  число
рождения равно (2+0)+(1+2)+(1+5+5+0)=16.
    25 4* 2. 0  _ 1Задача FizzBuzz . 0 ( 1Имран Гари 0) 1.
   Напишите функцию,  которая печатает числа от 1 до 100, но вместо
чисел, кратных трём, печатает "Fizz", вместо чисел, кратных пяти, -
"Buzz",  а если число кратно одновременно трём и пяти,  то печатает
"FizzBuzz".

    _ 1Домашнее задание . 0:
 ш1.0

   №№ 21 41,2 0;  22 41,2,3,4,5,6,7 0 ( 1всего 9 задач 0).

    _ 1Дополнительные задачи . 0: №№. 1..
 ш1.2
