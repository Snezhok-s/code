   -- Демонстрация использования 
   -- р е к у р с и и  по  з н а ч е н и ю
   -- (с использованием накапливающего параметра) на
   -- примере функции, возвращающей факториал неотри-
   -- цательного натурального числа
   -- *****************************
   fac:: Integer -> Integer
   fac n = fac1 n 1
   fac1 n m | n==0 = m
            | True = -- fac1 (n-1) n * m             -- n=5320
                     -- m * fac1 (n-1) n             -- n=3991
                        fac1 (n-1) (n * m)           -- n=3993
                     -- fac1 (n-1) (($) ((*) n) m)   -- n=3993
                     -- fac1 (n-1) (($!) ((*) n) m)  -- n=5324

   -- ============================================
   -- Функция, возвращающая  1! + 2! + 3! +...+ k!
   -----------------------------------------------
   sumF:: Integer -> Integer
   sumF k = sum $ map fac 
                      [1..k]

   -- ****************************
   -- Неудачные тестовые примеры:
   -----------------------------------------------
   test1 n = product [1..n]             -- n=20000
   -----------------------------------------------
   test2 =   fac 5                      == 120
          && fac 82 `div` 82            == fac 81
          && fac 100 `div` 100 `div` 99 == fac 98
          && fac 1000                   == product [1..1000]
   -------------------------------------------------------------
   test3 n = all (== True) $ map (\x -> fac x == product [1..x])
                                 [1..n]
   -------------------------------------------------
   test4 = sumF 6 == sum [1, 2, 6, 24, fac 5, fac 6]
