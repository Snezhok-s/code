   -- Демонстрация принятой в языке Haskell семантики  вычис-
   -- лений, заключающейся в выборе для вычислений при рекур-
   -- сивном вызове  самой  внешней  функции  (так называемая
   -- н о р м а л ь н а я  ф о р м а  бета-редукции).
   --    Если этого не сделать, то возникает  неоднозначность
   -- процесса вычисления.
   --    Поясним сказанное с помощью функции
   --                                  
   --          │1, если x=0;
   --   f(x,y)=│
   --          │f(x-1,f(x,y)), если x>0.
   --
   --   Значение f(1,0) можно вычислить двумя способами:
   --   (1) с помощью нормальной формы бета-редукции:
   --
   --    f(1,0) = f(0,f(1,0)) = 1;
   --
   --   (2) с помощью аппликативного порядка редукции:
   --
   --    f(1,0) = f(0,f(1,0)) = f(0,f(0,f(1,0))) =
   --           = f(0,f(0,f(0,f(1,0)))) = ...
   --
   -- **********************************
   func1:: Integer -> Integer -> Integer
   func1 x y | x==0 = 1
             | True = func1 (x-1) (func1 x y)

   -- ==================================
   func2:: Integer -> Integer -> Integer
   func2 x y | y==0 = 1
             | True = func2 (func2 x y) (y-1) 

   -- ***************************
   -- Неудачные тестовые примеры:
   ------------------------------
   test1 =   func1   1  0 == 1
          && func1   1  1 == 1
          && func1   2  0 == 1
          && func1 123 34 == 1
   ---------------------------
   test2 =   func2  1   0 == 1
          && func2  1   1 == 1
          && func2  0   2 == 1
          && func2 34 123 == 1
   --------------------------------------------------------
   test3 y = all (== 0) $ map (\x -> func1 x y - func2 x y)
                              [1..1000] 
