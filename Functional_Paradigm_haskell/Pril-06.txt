    2ПРИЛОЖЕНИЕ 6.
    2Понятие об отладке и тестировании

 ш1.0
               _ 1Определение .. Тестирование -  это  процесс  нахождения
               1ошибок в тесте. Хороший тест должен содержать ошибки,
               1компенсирующие их нехватку в тестируемой программе. 0
                                            1В.Тихонов. Теория ошибок
 ш1.2

    _ 1Основные понятия . 0:
 ш1.0
    1- разработка программы и её основные этапы 0;
    1- типы ошибок  программирования 0:   1синтаксические,  семантические,
 1логические 0;
    1- отладка программ 0;
    1- тестирование программ 0;
    1- принципы тестирования 0;
    1- методы тестирования, их преимущества и недостатки 0;
    1- 0  1основной тест, вырожденный тест, тест граничных значений, ава-
 1рийный тест 0;
   -  1локализация ошибки 0;
    1- малая автоматизация тестирования 0;
    1- 0  1сопровождение "старых" кодов 0;
    1- 0  1об одном критерии качества 0  1документации. 0
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ 0
   В настоящее  время  обеспечение качества программ является одной
из наиболее актуальных задач в области применения компьютеров.
   Современное программное обеспечение -  это  сложнейший  продукт,
создаваемый большим коллективом специалистов на протяжении длитель-
ного времени. Сложность, большой объём, участие большого числа спе-
циалистов - это основные факторы,  из-за которых возникают ошибки в
процессе разработки программного обеспечения.
   Если ошибки своевременно не обнаружены,  то значительные ресурсы
тратятся на их исправление в ходе эксплуатации.
   Естественно, что  для  решения  поставленной  задачи  необходимо
иметь  _ 1внешнее . 0 ( 1по отношению к программе 0)  _ 1описание решаемой  задачи . 0,
содержащее  информацию о том,  какие функции должна выполнять прог-
рамма (какой она должна быть).
   Причём это описание в процессе подготовки задачи к решению с по-
мощью компьютера  1должно предшествовать 0 написанию программы.
   Такими внешними по отношению к программе описаниями решаемой за-
дачи являются:
 ш1.1
   (1)  _ 1техническое задание на программу . 0,  в котором содержатся тре-
бования к функционированию  программы:  ограничения  на  программу,
описания функций, которые должна реализовывать программа, входные и
выходные данные и т.д.  Информация,  необходимая для отладки, может
быть описана в техническом задании как в явном виде,  так и в неяв-
ном.  Во втором случае требуется анализ некоторых положений  техни-
ческого задания для того, чтобы выделить необходимую информацию;
   (2) описание  _ 1математической модели . 0 решаемой задачи,  которая яв-
ляется формализованным  описанием задачи.  В описании явно выделены
все исследуемые параметры, входные и выходные данные, процессы пре-
образования информации,  необходимые критерии оценки получаемых ре-
зультатов. Описаны взаимосвязи между различными величинами задачи;
   (3)  _ 1алгоритм решения задачи . 0, который описывает метод решения за-
дачи и фиксирует все процессы преобразования входных данных  в  вы-
ходные так, как это должно осуществляться в компьютере. В алгоритме
присутствуют наиболее важные переменные и константы, которые должны
быть  использованы  в  программе,  описаны соотношения между ними и
введены другие параметры, уточняющие математическую модель задачи;
   (4)  _ 1проект программы . 0, который является описанием алгоритма реше-
ния задачи в терминах,  близких к конструкциям языка программирова-
ния;
   (5)  _ 1данные . 0,  поставляемые заказчиком; они могут содержать допол-
нительные уточняющие сведения о решаемой задаче,  деталях техничес-
кого задания, функциях алгоритмов, программе.
   (6)  _ 1тесты . 0, подготовленные для проверки функционирования програм-
мы, в которых могут находиться специфические данные программы, кри-
тические значения переменных,  констант,  описание путей выполнения
программы, диапазоны изменения переменных, типы и структуры данных;
   (7)  _ 1собственное понимание программы самим разработчиком . 0.
   Это связано с тем, что, как правило, трудно полностью формализо-
вать задачу, решаемую с помощью компьютера.

 ш1.2
   В каждом  из  перечисленных внешних описаний решаемой задачи ин-
формация о том, какой должна быть отлаживаемая программа, содержит-
ся в виде, специфичном для этого описания.
   Кроме того,  часто процесс окончательной постановки  задачи,  её
более полного понимания происходит в ходе её решения,  например,  в
результате длительного общения разработчика с  заказчиком.  Поэтому
некоторые  особенности  программы  могут быть не формализованы и не
отражены ни в одном документе. Хранителем этих особенностей являет-
ся сам разработчик.
    1Процесс разработки программ 0 опишем с помощью следующей схемы:
 ш1.1
   (1) постановка задачи;
   (2) построение математической модели;
   (3) выбор и построение алгоритмов решения;
   (4) проектирование программы;
   (5) программирование;
   (6) автономная отладка;
   (7) комплексная отладка;
   (8) передача в эксплуатацию;
   (9) сопровождение.
 ш1.2

                          2Отладка программ 0
                         21. 3 Основные понятия 0
    2Определение 0.
 ш1.1
    _ 1Отладка программы . 0 - это один из этапов её решения,  во время ко-
торого  с  помощью  компьютера происходит обнаружение и исправление
ошибок, имеющихся в программе.
   В ходе  отладки программист добивается определённой степени уве-
ренности в том, что его программа соответствует своему назначению и
не делает того, для чего она не предназначена.

 ш1.2
   Составные части процесса отладки изобразим схематически в "форме
Бэкуса-Наура":
 ш1.0

   < 1Процесс отладки 0>::=< 1Процесс поиска ошибки 0> +
                       < 1Процесс исправления этой ошибки 0>

   < 1Процесс поиска ошибки 0>::=< 1Процесс тестирования 0> +
                             < 1Процесс локализации ошибки 0>

 ш1.2
   Итак,  1отладка 0 объясняет причину ошибки и исправляет её, а  1тести-
 1рование 0 устанавливает факт  наличия  ошибки;  при  этом  (см.  [Ма-
йерс,1982]) время,  которое необходимо для адекватного тестирования
программ,  составляет от 30-50% общего времени разработки программ-
ного проекта.
   Процесс  1отладки программ 0 сводится к следующей  схеме,  состоящей
из основных пяти шагов:
 ш1.1
   (1) формирование гипотезы о наличии в программе ошибок,  опреде-
ляемых критерием отладки;
   (2) формирование  на основе некоторого (отличного от самой прог-
раммы) представления данных,  описывающих функции,  которые  должна
выполнять программа;
   (3) формирование на основе самой программы  данных,  описывающих
функции, которые в действительности выполняет программа;
   (4) выполнение процесса сравнения этих двух типов данных,  полу-
ченных на втором и третьем шаге соответственно;
   (5) на основе результатов сравнения двух видов данных, выполнен-
ного на  шаге  (4),  формирование  выводов о наличии или отсутствии
ошибки в программе,  а в случае её наличия - о характере и местона-
хождении.

 ш1.2
   Естественно, что  для отладки необходимо иметь  _ 1внешнее . 0 ( 1по отно-
 1шению к программе 0)  _ 1описание решаемой задачи . 0,  содержащее информацию
о том, какие функции должна выполнять программа.
   Для  _ 1отладки программы . 0 обычно пользуются следующими приёмами:
 ш1.1
   (1) пошаговое выполнение программы;
   (2) просмотр значения любой переменной или выражения;
   (3) установка  1контрольных точек  0(точек, в которых программа вре-
менно останавливает свою работу для возможности оценки  промежуточ-
ных результатов).  При этом  _ 1контрольной печатью . 0 обычно называют вы-
вод промежуточных результатов на экран.

 ш1.2
    _ 1Контроль правильности программы . 0 состоит, как правило, из следую-
щих этапов:
 ш1.1
   1. 3  1Просмотр 0.  Текст программы просматривается на предмет обнару-
жения описок и расхождений с алгоритмом решения.  Просмотреть орга-
низацию циклов, убедиться в правильности команд, задающих количест-
во  повторений.  Просмотреть  логические  выражения  в конструкциях
ветвления и выбора, вызов процедур и функций.
   2. 3  1Проверка 0.  При проверке программы необходимо постараться мыс-
ленно восстановить вычислительный процесс, определяемый программой,
и сравнить его с требуемым процессом.
   3. 3  1Прокрутка 0.  Пошаговое выполнение программы вручную человеком.
   Для выполнения прокрутки необходимо  задать  исходные  данные  и
производить над ними необходимые вычисления. Исходные данные должны
подбираться так,  чтобы в прокрутку вовлекалось большинство  ветвей
алгоритма.
 ш1.2

                         22. 0  3Ручная прокрутка 0

 ш1.0
                     1Программисту не всегда нужна ЭВМ, иногда полез-
                     1нее удобное кресло и спокойная обстановка.
                                                     1А.Архангельский
 ш1.2

   Прокрутка является первым этапом в процессе поиска ошибок. Осно-
вой прокрутки является имитация программистом  процесса  выполнения
программы  (алгоритма) компьютером с целью более конкретного и наг-
лядного представления о процессе,  определяемом текстом проверяемой
программы. Прокрутка дает возможность приблизить последовательность
проверки программы к последовательности её выполнения, что позволя-
ет проверять программу как бы в динамике её работы,  проверять эле-
менты вычислительного процесса, задаваемого проверяемой программой,
а не только статичный текст программы.
   Ручную прокрутку (" 1walkthrough 0" -  " 1сквозной  контроль 0")  иногда
называют  "сухой"  прокруткой  (" 1dry running 0" - " 1пробный прогон 0") в
отличие от метода прокрутки, использующего компьютер.
   Для выполнения  прокрутки  обычно задают какие-то конкретные ис-
ходные данные и производят над ними необходимые вычисления, исполь-
зуя только текст программы.  Для программ со сложной логикой, в ко-
торых,  например,  характер работы одного участка программы зависит
от  результатов работы других ее участков,  необходимо осуществлять
ручную прокрутку программы для ряда специально подобранных исходных
данных и параметров.
   Трудность применения прокрутки - большой объём ручной работы при
попытке точного моделирования работы программы.  Поэтому успех при-
менения прокрутки заключается в выборе  такой  необходимой  степени
детализации моделирования,  чтобы,  с одной стороны, выявить макси-
мальное количество ошибок,  а с другой - затратить на это минималь-
ные усилия.
   Например, тело цикла можно прокрутить лишь для первых  двух-трёх
проходов  (проверка входа в цикл) и для последних одного-двух (про-
верка выхода из цикла).
   Использование прокрутки  весьма полезно потому,  что она содейс-
твует глубокому  осознанию  программистом  логики  составленной  им
программы и того реального вычислительного процесса, который ею за-
дается.
   Поговорим теперь о методике проведения ручной прокрутки.
   Нарисуйте на листе бумаги "начальную обстановку",  а затем, "ис-
полняйте"  операторы  программы  по одному,  отмечая все изменения,
происходящие при этом в запоминающем устройстве. Поэтому для ручной
прокрутки  нужно  уметь изображать на бумаге начальную обстановку в
оперативном запоминающем устройстве и происходящие в нём изменения.
   Удобнее всего рисовать блоки памяти и  их  содержимое  мелом  на
 1школьной доске 0:  ведь для того, чтобы поместить в блок новое содер-
жимое,  нужно "уничтожить" (стереть) старое - на доске это  сделать
очень просто.  Каждый блок можно рисовать в виде "домика", на "кры-
ше" которого записано имя блока,  а внутри размещается  содержимое.
Форма крыши может говорить о типе переменной.
   Если ручная  прокрутка  выполняется  на  1бумаге 0,  то таблицу имен
блоков приходится изображать по-другому,  потому что стирать старые
значения на бумаге неудобно,  лучше их зачеркивать,  а рядом писать
новые значения.

                     23. 0  3Метод контрольных тестов 0

 ш1.0
                 1Никогда не берите на корабль два хронометра, берите
                 1один или, если есть возможность, три, но не два.
                            1Наставление мореплавателям начала XIX в.
 ш1.2

   Как бы ни была тщательно проверена и "прокручена"  программа  за
столом, решающим этапом, устанавливающим её пригодность для работы,
является контроль программы по результатам выполнения на  компьюте-
ре. Поэтому рассмотрим универсальный метод контроля,  который назы-
вается  _ 1методом контрольных тестов . 0 (англ.   1test 0 -  1испытание 0,  1провер-
 1ка 0).  1Тестирование 0  - это важнейший этап в программировании и предс-
тавляет собой контроль программы по результатам  её  выполнения  на
системе  1тестов 0.
    2Определение 0 [Майерс,1982].
 ш1.1
    2(1) 0  _ 1Тестирование . 0 - это процесс исполнения программы на компьюте-
ре с целью  1обнаружения ошибок 0.
    2(2) 0  _ 1Тестом . 0 будем называть информацию, состоящую из исходных дан-
ных,  специально подобранных для отлаживаемой программы, и из соот-
ветствующих им эталонных результатов (не только окончательных, но и
промежуточных), используемых в дальнейшем для контроля правильности
работы программы.

 ш1.2
   Поясним это определение.
   Если поставить целью демонстрацию отсутствия ошибок,  то мы под-
сознательно будем стремиться к этой цели, выбирая текстовые данные,
на которых вероятность появления ошибки мала.  В то же время,  если
вашей  задачей станет обнаружение ошибок,  то создаваемый нами тест
будет обладать большей вероятностью обнаружения ошибки.  Такой под-
ход заметнее повысит качество программы.
    1Тестирование 0 - это процесс деструктивный (т.е.  обратный созида-
тельному,  конструктивному). Именно этим и объясняется, почему мно-
гие считают его трудным. Большинство людей склонно к конструктивно-
му  процессу созидания объектов и в меньшей степени - к деструктив-
ному процессу разделения на части.  Для усиления определения тести-
рования проанализируем два понятия - "удачный" и "неудачный".
   Большинство назовет тестовый прогон неудачным,  если  обнаружена
ошибка и, наоборот, удачным, если он прошел без ошибок.
   Из определения тестирования  следует  противоположное:  тестовый
прогон будет назван удачным, если в процессе его выполнения обнару-
жена ошибка, и, неудачным, если получен корректный результат.
   Вопрос о  позиции программиста по отношению к продукту его труда
связан, как это показано Вейнбергом,  с принципами безличного прог-
раммирования и когнитивного диссонанса.
    _ 1Когнитивный диссонанс . 0  1- 0 это психологический принцип, который ру-
ководит действиями человека, чьи представления о себе оказались под
угрозой. "Программист, который искренне считает программу продолже-
нием своего "я",  не будет пытаться найти все ошибки в ней.  Напро-
тив,  он постарается показать,  что программа правильна,  даже если
это  означает не замечать ошибок,  чудовищных для постороннего гла-
за... Человеческий глаз имеет почти безграничную способность не ви-
деть то, чего он видеть не желает".
   Спасти в такой ситуации может безличное программирование. Вместо
того,  чтобы  быть скрытным и защищать свою программу,  программист
занимает противоположную  позицию:  он  открыто  приглашает  других
программистов  читать а конструктивно критиковать её.  Когда кто-то
находит ошибку в его программе, программист, конечно, не должен ра-
доваться,  что ошибся;  его позиция примерно такова:  "О!  Мы нашли
ошибку в нашей программе! Хорошо, что мы нашли её сейчас, а не поз-
же! Поучимся на этой ошибке, а заодно посмотрим, не найдём ли ещё!"
   Программист, обнаруживший ошибку в чужой программе,  не  кричит:
"Посмотри  на  свою  идиотскую ошибку!",  а реагирует примерно так:
"Как любопытно! Интересно, не сделал ли и я такой ошибки в написан-
ном мною модуле?".
   При использовании метода  тестов   _ 1программа . 0  (или  отдельный  её
блок)   _ 1считается  правильной . 0,  если пропуск программы для выбранной
системы тестовых исходных данных дает правильные результаты.
   Таким образом,  контроль программы сводится к тому, чтобы подоб-
рать систему тестов,  получение правильных результатов для  которой
гарантировало бы правильную работу программы и для остальных исход-
ных данных на области, указанной в решаемой задаче.
   Для реализации метода контрольных тестов должны быть изготовлены
или заранее известны эталонные результаты,  на основании  сверки  с
которыми получаемых тестовых результатов, можно было бы сделать вы-
вод о правильности работы программы на данном тесте.
   Эталонные результаты  для  вычислительных  задач можно получить,
осуществляя вычисления вручную, применяя результаты, полученные ра-
нее  на другом компьютере или по другой программе,  или,  используя
известные факты, свойства, физические законы.
   Разрабатывая систему тестов,  нужно стремиться к тому, чтобы ус-
пешный пропуск ее на компьютере доказывал наличие ошибок в програм-
ме  (или  отдельном  её блоке),  хотя для многих достаточно сложных
программ,  особенно если над ними работает несколько программистов,
можно  практически  говорить лишь о большей или меньшей вероятности
правильности программы.  Это объясняется тем,  что  изготовление  и
пропуск всех тестов, необходимых для доказательства, может потребо-
вать такого объёма работ,  который затянет этап контроля на  многие
месяцы или годы. Поэтому при разработке системы тестов наряду с за-
дачей всестороннего и глубокого тестирования,  стоит задача миними-
зации количества необходимых тестовых результатов, машинного време-
ни и усилий программиста.
   В большинстве  случаев при использовании метода контрольных тес-
тов вопрос о доказательстве  отсутствия  ошибок  практически  можно
ставить лишь для небольших блоков (модулей) программы,  а для целой
программы приходится ограничиваться той или иной  вероятностью  от-
сутствия ошибок в программе.
   Неоднократно экспериментально установлено,  что в любой  сложной
программе в процессе эксплуатации обнаруживаются ошибки,  даже если
проведено самое тщательное  тестирование.  Тем  самым  утверждается
объективная реальность, заключающаяся в невозможности формализовать
и обеспечить абсолютную полноту всех эталонных  значений,  а  также
провести  всеобъемлющее  исчерпывающее тестирование и устранить все
ошибки в сложных программах.
   Опыт показывает, что до начала тестирования число ошибок в слож-
ных программах - порядка 1-2% от общего числа операторов в програм-
ме.  Самое тщательное тестирование сложных программ позволяет полу-
чить  программы  с   вероятностью   ошибки   в   каждом   операторе
0.0001-0.00001,  т.е. несколько ошибок может остаться. После завер-
шения тестирования программы в течение нескольких лет  эксплуатации
могут быть выявлены еще десятки ошибок.

   Перечислим  _ 1основные принципы тестирования . 0 [Майерс,1980].
   Эти принципы интересны тем,  что в основном они интуитивно ясны,
но в то же время на них часто не обращают должного внимания.

    2А. 0 Описание  предполагаемых значений выходных данных или резуль-
татов должно быть необходимой частью тестового набора.
   Нарушение этого  очевидного принципа представляет одну из наибо-
лее распространенных ошибок. Ошибочные, но правдоподобные результа-
ты  могут быть признаны правильными,  если результаты теста не были
заранее определены. Здесь мы сталкиваемся с явлением психологии: мы
видим то,  что хотим увидеть.  Другими словами, несмотря на то, что
тестирование по определению - деструктивный процесс, есть подсозна-
тельное желание видеть корректный результат. Один из способов борь-
бы с этим состоит в поощрении детального анализа выходных  перемен-
ных заранее, ещё при разработке текста.

    2Б. 0 Следует избегать тестирования программы её автором.
   Многие, кому приходилось самому делать дома ремонт,  знают,  что
процесс обрывания старых обоев (деструктивный процесс) нелегок,  но
он просто невыносим, если не кто-то другой, а вы сами первоначально
их наклеивали.
   Вот так и большинство программистов не может эффективно тестиро-
вать свои программы, потому что им трудно демонстрировать собствен-
ные ошибки.

    2В. 0 Необходимо  досконально изучать результаты применения каждого
теста.
   Представляется достоверным,  что значительная часть всех обнару-
женных в конечном итоге ошибок могла быть выявлена в результате са-
мых первых тестовых прогонов,  но они были пропущены вследствие не-
достаточно тщательного анализа результатов первого тестового прого-
на.

    2Г. 0 Тесты для неправильных  и  непредусмотренных  входных  данных
следует  разрабатывать так же тщательно,  как для правильных и пре-
дусмотренных.
   Вполне вероятно, что тесты, представляющие неверные и неправиль-
ные входные данные,  обладают большей обнаруживающей  способностью,
чем тесты соответствующие корректным исходным данным.

    2Д. 0 Необходимо проверять не только,  делает ли программа то,  для
чего она предназначена, но и ни делает ли она то, что не должна де-
лать.

    2Е. 0 Не следует выбрасывать тесты,  даже если программа уже не ис-
пользуется.
   Обычно тестирующий сидит за терминалом,  "на  лету"  придумывает
тесты и запускает программу на выполнение. При такой тактике работы
после применения тесты пропадают. После внесения изменений или исп-
равления ошибок необходимо повторить тестирование, тогда приходится
заново изобретать тесты.
   Как правило,  этого стараются избегать, поскольку повторное соз-
дание тестов требует значительной работы.

    2Ж. 0 Нельзя планировать тестирование в предположении,  что  ошибки
не будут обнаружены.

    2З. 0 Вероятность наличия необнаруженых ошибок  в  части  программы
пропорциональна числу ошибок, уже обнаруженных в этой части.
   На первый взгляд,  этот принцип лишен смысла,  но тем  не  менее
подтверждается многими программами. Например, допустим, что некото-
рая программа состоит из модулей A и B. К определенному сроку в мо-
дуле А обнаружено пять ошибок,  а в модуле В - только одна,  причем
модуль А не подвергался более тщательному  тестированию.  Тогда  из
рассматриваемого  принципа следует,  что вероятность необнаруженных
ошибок в модуле А больше,  чем в  модуле  В.  Справедливость  этого
принципа подтверждается еще и тем,  что для ошибок свойственно рас-
полагаться в программе в виде неких скоплений,  хотя данное явление
пока еще никем не объяснено.
   Таким образом,  если в какой-нибудь части  программы  обнаружено
больше ошибок, чем в других, то на её тестирование должны быть нап-
равлены дополнительные усилия.

    2И. 0 Тестирование - процесс творческий.  Вполне вероятно,  что для
тестирования большой программы требуется больший творческий  потен-
циал, чем для ее проектирования.
   Чтобы подчеркнуть некоторые мысли,  высказанные в этом  разделе,
приведём ещё раз  _ 1три наиболее важных принципа тестирования . 0:
 ш1.1
   (1)  _ 1тестирование . 0  1- 0 это процесс выполнения программ на компьютере
с целью обнаружения ошибок;
   (2)  _ 1хорошим . 0 считается тест,  который имеет  высокую  вероятность
обнаружения еще не выявленной ошибки;
   (3)  _ 1удачным . 0 является тест,  который обнаруживает ещё не выявлен-
ную ошибку.

 ш1.2
                       24. 0  3Методы тестирования 0
   При  1неупорядоченном тестировании 0 (англ.  1smoke test 0 -  1грубая про-
 1верка работоспособности  простым  запуском 0,   1дымовой тест 0) исходные
данные,  имитирующие внешнюю среду,  случайным образом генерируются
во всем диапазоне возможного изменения параметров.
   При этом многие значения исходных данных  характеризуются  малой
вероятностью  обнаружения ошибок и не оправдывают затраты на выпол-
нение тестирования. Кроме того, возможно появление логически проти-
воречивых данных.  В то же время данные,  наиболее важные с позиции
реального использования программ и возможностей обнаружения ошибок,
могут оказаться неохваченными в процессе тестирования.
   Поэтому на  практике  последовательно применяют следующие методы
тестирования:  1статический 0,  1детерминированный 0 и  1стохастический 0.

    _ 1Статическое тестирование .  0(англ.  1static check 0) является  наиболее
формализованным методом проверки корректности программ.
   Тестирование проводится  без исполнения программы путём формаль-
ного анализа текста программы на языке программирования.  Операторы
и  операнды текста программ при этом анализируются в символьном ви-
де, поэтому такой метод называют также 1 символическим тестированием 0.

   Наиболее трудоемкими и детализирующими являются методы, называе-
мые  _ 1методами детерминированного тестирования . 0.  При таком тестирова-
нии контролируется каждая комбинация исходных  эталонных  данных  и
соответствующая ей комбинация эталонных результатов.
   Разумеется, в сложных программах невозможно перебрать все комби-
нации исходных данных и проконтролировать результаты функционирова-
ния программы на каждой из них.
   В таких случаях применяется  _ 1стохастическое тестирование . 0, при ко-
тором  исходные тестовые данные задаются множеством случайных вели-
чин с соответствующими распределениями и для  сравнения  полученных
результатов  используются также распределения случайных величин.  В
результате при стохастическом тестировании возможно  более  широкое
варьирование  исходных данных,  хотя отдельные ошибки могут быть не
обнаружены,  если они мало искажают средние статистические значения
или распределения.
   Стохастическое тестирование применяется в основном для обнаруже-
ния ошибок, а для диагностики и локализации ошибок приходится пере-
ходить  к детерминированному тестированию с использованием конкрет-
ных значений параметров из области изменения использовавшихся  слу-
чайных величин.
   Рассмотрим некоторые 1  _правила тестирования . 0,  в  которых  делается
попытка  учесть как желательность доказательства правильности конт-
ролируемой программы,  так и ограниченность человеческих возможнос-
тей при проведении такого доказательства [Безбородов,1982].
    _ 1Проход участков .. 0
   Каждый линейный  участок программы должен быть обязательно прой-
ден при выполнении,  по крайней мере,  одного теста.  В том случае,
когда выполнение некоторого участка программы меняет порядок выпол-
нения или характер работы других участков,  может потребоваться пе-
ребор  всех ветвей программы,  т.е.  проход по всем возможным путям
выполнения программы.
    _ 1Точность проверки .. 0
   Контроль арифметических блоков (как и других блоков) производит-
ся путем сверки результатов, полученных при выполнении блока,с эта-
лонными результатами. Для арифметических результатов дополнительная
сложность заключается в определении точности,  с которой необходимо
сверять (и,  тем самым, вычислять) эталонные и тестовые результаты,
с тем, чтобы можно было действительно удостовериться в правильности
работы блока.
    _ 1Достоверность эталонов .. 0
   Нужно обратить внимание и на  достоверность  процесса  получения
эталонных результатов. По возможности они должны вычисляться не са-
мим программистом, а кем-то другим, с тем чтобы одни и те же ошибки
в  понимании  задания не проникли и в программу,  и в эталонные ре-
зультаты. Если тесты готовит сам программист,  то эталоны нужно вы-
числять до получения на компьютере соответствующих результатов.
   В противном случае имеется опасность невольной подгонки вычисля-
емых значений под желаемые, полученные ранее на компьютере.
   В качестве эталонных результатов часто используют и данные,  по-
лученные при ручной прокрутке программы.
    _ 1Планирование .. 0
   При отсутствии  планового подхода тестирование обычно сводится к
тому,  что программист берет какие-то, можно сказать, первые попав-
шиеся исходные данные и пропускает программу многократно, исправляя
ее при обнаружении ошибок и добиваясь того,  чтобы  получаемые  ре-
зультаты походили на желаемые.
   Ясно, что при этом контролируется только некоторая часть  блоков
и  операторов,  а  остальные  выполняются в первый раз уже во время
счета, и будут ли при этом найдены ошибки, имеющиеся в них, зависит
только от случая.
   При плановом подходе программа проверяется последовательно  блок
за блоком, причем если программа состоит из центрального блока, ко-
торый проводит обращения к периферийным блокам, мало связанным друг
с другом, то возможны следующие два основных подхода к контролю та-
кой программы,  два основных направления тестирования: от периферии
к центру (восходящее тестирование) или, наоборот, от центра к пери-
ферии (нисходящее тестирование).
   При первом, восходящем способе, применяемом обычно для небольших
программ,  сначала тестируют отдельные периферийные блоки,  а затем
переходят  к тестированию центральной части,  которая,  разумеется,
взаимодействует только с уже отлаженными блоками.
   При нисходящем тестировании, используемом для достаточно больших
программ,  параллельно с контролем периферийных блоков (или даже до
начала их контроля) производится и контроль центрального блока, вы-
полняемого на компьютере совместно с имитаторами периферийных  бло-
ков,  называемых "заглушками". В задачу имитаторов входит моделиро-
вание работы соответствующих блоков с целью поддержать функциониро-
вание  центрального блока.  Обычно "заглушки" выдают простейший ре-
зультат,  например константу и сообщение о факте своего  участия  в
работе. Вместо постоянной величины на более поздней стадии тестиро-
вания может выдаваться и случайная величина в требуемом диапазоне.
   К сожалению,  часто неверно понимают функции,  выполняемые "заг-
лушками". Так порой можно услышать, что "заглушка" должна выполнять
лишь запись сообщения, устанавливающего: "Модуль подключился".
   В большинстве  случаев эти утверждения ошибочны.  Когда модуль А
вызывает модуль В,  А предполагает,  что В выполняет некую  работу,
т.е.  модуль А получает результаты работы модуля В. Когда же модуль
В просто возвращает управление или выдпет некое сообщение без пере-
дачи  в  А определенных осмысленных результатов,  модуль А работает
неверно не вследствие ошибок в самом модуле, а из-за несоответствия
ему модуля - "заглушки". Более того, результат может оказаться неу-
довлетворительным, если "ответ" модуля-"заглушки" не меняется в за-
висимости от условий теста.  Если "заглушка" всегда возвращает один
и тот же фиксированный результат вместо конкретного значения, пред-
полагаемого вызывающим модулем именно в этом вызове,  то вызывающий
модуль срабатывает как ошибочный (например,  зациклится) или выдаст
неверное выходное значение. Следовательно, создание модулей-"заглу-
шек" - задача нетривиальная.
   Преимуществом ранней  отладки  центрального блока при нисходящем
тестировании является  то,  что  программист  получает  возможность
быстро проверить периферийные блоки в условиях, которые в необходи-
мой степени приближены к реальным. Действительно, центральный блок,
снабженный  хотя  бы  и  простейшими функциональными возможностями,
можно рассматривать как реальную среду, в которую "погружаются" от-
лаживаемые блоки, добавляемые к центральной части. Добавление отла-
живаемых блоков удобно производить по одному для быстрейшего  поика
ошибок,  возникающих при стыковке с центральным блоком. Подключение
каждого нового блока к центральной части позволяет  постепенно  ус-
ложнять испытания, которым подвергается тестируемая программа.
   Строгой, корректной  процедуры подключения очередного последова-
тельно тестируемого модуля не существует. Единственное правило, ко-
торым следует руководствоваться при выборе очередного модуля,  сос-
тоит в том, что им должен быть один из модулей, вызываемых модулем,
предварительно прошедшим тестирование.
   Следует помнить,  что даже если изменения вносятся только в одну
подпрограмму, то повторному тестированию подлежит вся система. Этот
процесс называется   1тестированием  с  возвратом. 0  Проверять  работу
только  измененной  подпрограммы недостаточно!  Недостаточно полное
тестирование такого рода повышает вероятность неудач.
   Проведём сравнение нисходящего и восходящего тестирования,  при-
ведённое в [Майерс,1980].
    _ 1Преимущества нисходящего тестирования . 0.
 ш1.1
    21. 0 Имеет преимущества, если ошибки, главным образом, в "верхней"
части программы.
    22. 0 Раннее формирование структуры программы позволяет провести ее
демонстрацию пользователю и служит моральным стимулом.

 ш1.2
    _ 1Недостатки нисходящего тестирования . 0.
 ш1.1
    21. 0 Необходимо  разрабатывать  модули-"заглушки",  которые  часто
оказываются сложнее, чем кажется в начале.
    22. 0 Может  оказаться трудным или невозможным создать тестовые ус-
ловия.
    23. 0 Сложнее оценка результатов тестирования.
    24. 0 Стимулируется незавершение тестирования некоторых модулей.

 ш1.2
    _ 1Преимущества восходящего 0  1тестирования . 0.
 ш1.1
    21. 0 Имеет преимущества, если ошибки, главным образом в модуле ниж-
него уровня.
    22. 0 Легче создавать тестовые примеры.
    23. 0 Проще оценка результатов.

 ш1.2
    _ 1Недостатки восходящего тестирования . 0.
 ш1.1
   Программа как единое целое не существует до тех пор, пока не до-
бавлен последний модуль.

 ш1.2
   Значительное повышение корректности и надёжности программ дости-
гается применением  _ 1двойного . 0 ( 1N- _кратного . 0)  _ 1программирования . 0 (от англ.
 1duplication check 0 -  1двойной пересчёт 0,  1двойная проверка 0).
   При этом  методе  при разных алгоритмах и на разных языках прог-
раммирования создается несколько вариантов программы.  Эти варианты
реализуют  одни  и те же функции и при определенных тестовых данных
должны выдавать тождественные результаты.  Различие результатов при
тестировании указывает на наличие ошибок по крайней мере в одном из
вариантов.  Обычно при разработке вариантов программы  используется
один  и  тот же алгоритм,  но программы создаются на разных языках,
разных компьютерах и разными программистами.
   На практике  применяется  программирование  с  N 7, 02.  Практически
очень редки случаи,  когда реальная программа создавалась в трёх  и
более вариантах.
                           25. 0  3Типы тестов 0
    _ 1Основным тестом . 0 будем называть тест,  проверяющий основные функ-
циональные возможности программы.  Однако существует опасность, что
после успешного  окончания  основного  тестирования  "на  радостях"
обычно  забывают  о  необходимости  дальнейшего,  более тщательного
контроля программы и отдельных е 1ё 0 участков, да и настроиться на та-
кой  контроль становится уже психологически трудно.  Поэтому помимо
основного теста необходимо применить следующие типы тестов.
    _ 1Вырожденный тест . 0 - это тест,  который затрагивает работу отлажи-
ваемой программы в самой минимальной степени.  Обычно  тест  служит
для проверки правильности выполнения самых внешних функций програм-
мы, например обращения к ней и выхода из неё.
    _ 1Тест граничных значений . 0 ( _ 1стрессовый тест . 0)  (англ.   1high-low bias
 1cheking 0,  1twin check 0) - это тест, который проверяет работу программы
для граничных значений параметров, определяющих вычислительный про-
цесс. Часто для граничных значений параметра работа программы носит
особый характер, который тем самым требует и особого контроля.
   Итак, перечислим  _ 1этапы тестирования . 0:
 ш1.1
   (1) проверка  _ 1нормальных условий . 0, заключающаяся в тестировании на
основе данных,  характерных для реальных  условий  функционирования
программы;
   (2) проверка  _ 1экстремальных условий . 0. Тестовые данные включают гра-
ничные  значения  области  изменения  исходных переменных,  которые
должны восприниматься программой как правильные  данные.  Типичными
примерами могут  служить  "очень маленькие" и "очень большие" числа
или отсутствие входных данных;
   (3) проверка  _ 1исключительных ситуаций . 0. Проводится с использовани-
ем данных,  значения которых лежат за пределами допустимой  области
изменения.

 ш1.2
   Например, если в качестве примера рассмотреть тестирование подп-
рограммы сортировки, то нужно исследовать следующие ситуации:
 ш1.1
   (а) сортируемый массив пуст;
   (б) сортируемый массив содержит только один элемент;
   (в) все элементы в сортируемом массиве одинаковы;
   (г) массив уже отсортирован.

 ш1.2
    _ 1Аварийный тест . 0 - это тест,  который проверяет реакцию  программы
на  возникновение  разного  рода аварийных ситуаций в программе,  в
частности вызванных неправильными исходными данными, то есть прове-
ряется диагностика, выдаваемая программой, а также окончание её ра-
боты или,  может быть, попытка исправления неверных исходных данных
(разработчики реальных программ знают, что пользователи подобны ре-
бёнку,  играющему в отсутствие старших с телевизором или магнитофо-
ном).
   Поэтому в реальных программах,  спроектированных  с  достаточной
надежностью,  совокупности приказов, которые должны работать только
в особых аварийных ситуациях,  занимают порой более 90% общего объ-
ема программы.
   Эти совокупности приказов называют иногда блоками " 1защиты от ду-
 1рака 0" (англ.  1fool proof 0). Такие системы, обладая достаточной надёж-
ностью,  устойчиво функционируют даже при самых неподходящих  дейс-
твиях работающих с ними людей.
   Фирмы, занятые разработкой программного обеспечения,  специально
нанимают профессионально неподготовленных людей,  чтобы они порабо-
тали с вновь созданными программами. В их задачу входит за короткое
время сделать столько неправильных обращений к  программе,  сколько
пользователь не сделает и за долгий период.
   Наконец, перечислим  _ 1правила тестирования . 0 для начинающих програм-
мистов:
 ш1.1
   (1) набор  тестов должен быть приготовлен  1заранее 0 вместе с соот-
ветствующими эталонными результатами;
   (2) тесты должны быть целенаправленными и систематизированными;
   (3) первый тест должен быть максимально прост;
   (4) усложнение тестовых данных должно быть постепенное.
   (5) очередной  тест  должен  контролировать то,  что ещё не было
проверено на предыдущих тестах;
   (6) должна быть испытана каждая "ветвь" программы.

 ш1.2
    2Пример 0.
 ш1.1
   Составим систему тестов для задачи нахождения корней квадратного
уравнения ax 52 0+bx+c=0:
 ш1.0

   (1)  a=1, b=1, c=-2    (хороший начальный тест);
   (2)  a=1, b=0, c=0.25  (проверка в нормальных условиях);
   (3)  a=0, b=0, c=0     (что произойдет в этом случае?);
   (4)  a=0, b=2, c=1     (должен быть получен один корень);
   (5)  a=2, b=1, c=0     (всё должно быть в порядке);
   (6)  a=1, b=1, c=1     (вещественных корней нет);
   (7)  a=0, b=0, c=2     (не является уравнением);
   (8)  a=0, b=2, c=0     (должен быть один корень);
   (9)  a=2, b=0, c=0     (должно быть два одинаковых корня);
   (10) a=1, b=0, c=4     (должно быть два одинаковых корня).

 ш1.2
                       26. 0  3Принципы 0  3локализации 0
                               3ошибок 0
   После того как установлено,  что в программе или в конкретном её
блоке имеется ошибка,  возникает задача её 1 локализации 0,  т.е. уста-
новления точного места в программе, где она находится.
   Можно считать,  что процесс локализации ошибок состоит  из  трёх
основных компонентов:
 ш1.1
   (1) получение вручную или с помощью компьютера тестовых  резуль-
татов;
   (2) анализ тестовых результатов и сверка их с эталонными;
   (3) выявление  ошибки или формулировка предположения о характере
и месте ошибки в программе. Если ошибка найдена, то производится ее
исправление;  в противном случае осуществляется переход к пункту 1,
т.е. к получению дополнительных тестовых результатов.

 ш1.2
   В ходе  поиска  ошибок  программист,  анализируя  полученные  на
компьютере результаты, проверяет различные предположения о характе-
ре и месте ошибки в программе,  которые при этом приходят ему в го-
лову.  В случае несоответствия этих гипотез  выданным  результатам,
программист выдвигает новые гипотезы и проверяет их или в уме,  или
проводя вычисления за столом,  или обращаясь за новыми результатами
к компьютеру.
   В таком характере работы программиста можно найти нечто общее  с
расчётом  вариантов,  который осуществляет шахматист во время игры,
когла он путем расчётов в уме ищет выигрывающий ход  в  позиции  на
шахматной доске,  подвергая проверке один из заслуживающих внимания
ходов за другим.  Не найдя выигрывающего хода, шахматист делает ка-
кой-то, по его мнению, хороший ход, приближающий его к цели.
   Так и программист, не найдя ошибки путём исследования полученных
тестовых результатов,  делает новое предположение о месте или о ха-
рактере ошибки,  вставляет новую  отладочную  печать  или  изменяет
программу ("ход  программиста"),  а компьютер выдает новые тестовые
результаты ("ход компьютера"). Итак, компьютер выступает в качестве
партнёра, задача которого заключается в том, чтобы вскрыть ошибки в
рассуждениях программиста,  сформулированных им в тексте отлаживае-
мой программы. Продолжая аналогию, можно сказать, что подобно тому,
как нельзя реально надеяться выиграть партию в два-три хода, так же
нельзя найти все ошибки в реальной программе за несколько обращений
к компьютеру.
   Программистов, успешно проводящих поиск ошибок в программе, мож-
но условно разделить на  1аналитиков 0 и  1экспериментаторов 0.
   Аналитики отлаживают программу, редко используя компьютер и при-
меняя простейшие способы получения тестовых результатов путём  тща-
тельного изучения этих результатов и на основании чёткого представ-
ления о структуре и особенностях отлаживаемой программы.
   Экспериментаторы ищут ошибки,  изощрённо используя  всевозможные
отладочные  средства,  быстро получая необходимые для все большей и
большей локализации ошибок промежуточные результаты и легко  ориен-
тируясь в них.
    1Идеальным является  случай,  когда  программист  сочетает в себе
 1способность к глубокому расчёту в уме  различных  вариантов  работы
 1программы и навыки работы с разнообразными отладочными средствами 0.
   Если успех аналитического подхода к поиску ошибок зависит, види-
мо, от способностей и опыта программиста, то изучение и использова-
ние  средств,  помогающих  локализации  ошибок  -  главным  образом
средств получения необходимых промежуточных результатов, - доступно
каждому программисту.
   Приведём следующие принципы  1Г.Майерса 0 [1982].
 ш1.1
   1. Думайте!  Наиболее  эффективный  метод  отладки заключается в
глубоком анализе информации об ошибках.  Для ее эффективного прове-
дения  специалист  должен  обладать  способностью  точно определять
большинство ошибок без использования компьютера.
   2. Используйте средства отладки только как вспомогательные.
   Не применяйте эти средства вместо того, чтобы обдумывать задачу.
   Эксперименты показали,  что программисты,  избегающие применения
средств отладки, даже при отлаживании незнакомых им программ выпол-
няют её лучше, чем те, кто пользуется этими средствами.
   3. Избегайте экспериментирования. Пользуйтесь им только как пос-
ледним средством. Наиболее общей ошибкой, которую допускают начина-
ющие программисты,  занимающиеся отладкой,  является попытка решить
задачу посредством внесения в программу экспериментальных изменений
("Я не знаю,  где ошибка, но я изменю этот оператор и посмотрю, что
получится"). Экспериментирование  не  только  уменьшает вероятность
успеха, но часто и усложняет задачу, поскольку при этом в программу
вносятся новые ошибки.
   4. Если вы зашли в тупик,  отложите рассмотрение программы. Наше
подсознание является мощным механизмом решения проблем.  То, что мы
часто приписываем вдохновению,  оказывается всего лишь  выполненной
подсознанием работой по решению задачи, тогда как наша сознательная
деятельность в это время связана с чем-нибудь другим.
   Если вы  не можете локализовать ошибку в приемлемые сроки (пред-
положительно за 30 минут для небольших программ и за несколько  ча-
сов для больших), прекратите поиски и займитесь каким-нибудь другим
делом, так как эффективность работы значительно снизится.
   Проблему следует " забыть" до тех пор, пока вы подсознательно не
найдете её решения,  либо отдохнете и будете готовы вновь  рассмот-
реть симптомы ошибки.
   Наконец, если вы окончательно зашли в тупик,  то изложите задачу
кому-нибудь ещё. Сделав это, вы, вероятно, обнаружите что-то новое.
   Часто случается так,  что просто пересказав задачу хорошему слу-
шателю, вы вдруг найдёте решение даже без помощи с его стороны.
 ш1.2

                       27. 0  3Принципы исправления 0
                               3ошибок 0

 2   0ш1.0
           1Вы должны радоваться, что мост разрушился, - я планировал
           1построить еще тринадцать по тому же проэкту. 0
                1Замечание, приписываемое Х.Брюнелю, адресованное ди-
                1рекции Большой западной железной дороги

           1Все ошибки  будут не дальше трёх операторов в ту или дру-
           1гую сторону от места последнего изменения программы. 0
                                                   1Закон отладки Джо
 ш1.2

   Перечислим  _ 1принципы исправления ошибок . 0 по  1Г.Майерсу 0 [1982].

    21 0. Там, где есть одна ошибка, вероятно есть и другие.
   Другими словами, ошибки имеют тенденцию группироваться. При исп-
равлении  ошибки  проверьте  её непосредственное окружение:  нет ли
здесь каких-нибудь подозрительных симптомов.

    22 0.  1Находите ошибку, 0  1а не её симптом. 0 Плохо, если вследствии это-
го вы устраненяете симптомы ошибки, а не её саму. Если предполагае-
мое  изменение  устраняет  не все симптомы ошибки,  то она не может
быть полностью выявлена.

    23 0.  1Вероятность правильного нохождения ошибки не равна 100%.
   Никогда нельзя предполагать,  что текст, который включен в прог-
рамму для исправления ошибки,  правилен. С этим, безусловно, согла-
шаются,  а в процессе исправления ошибки часто наблюдается иная ре-
акция  (например,  "да,  в большинстве случаев это справедливо,  но
данная корректировка столь незначительна, что она правильна").
   Можно утверждать, что корректировки более склонны к ошибкам, чем
исходный текст программы. Подразумевается, что корректирующая прог-
рамма должна тестироваться, возможно, даже более тщательно, чем ис-
ходная.

    24 0.  1Вероятность  правильного нахождения ошибки уменьшается с уве-
 1личением объёма программы. 0
   Это утверждение формулируется по-разному. Эксперименты показали,
что отношение числа неправильно найденных ошибок к  числу  первона-
чально  выявленных  увеличивается  для больших программ.  В большой
программе,  рассчитанной на широкое применение, каждая шестая вновь
обнаруженная ошибка может быть допущена при предшествующем внесении
изменений в программу.

    25 0.  1Остерегайтесь внесения новой ошибки при корректировке.
   Необходимо рассматривать не только неверные корректировки,  но и
те,  которые  кажутся верными,  однако имеют нежелательный побочный
эффект и таким образом приводят к новым ошибкам.
   Подобные ошибки называются  _ 1наведёнными ошибками . 0.
   Другими словами,  существует  вероятность  не  только того,  что
ошибка будет обнаружена неверно, но и того, что её исправление при-
ведет к наведённой ошибке.  Поэтому после проведения  корректировки
должно  быть выполнено повторное тестирование,  позволяющее устано-
вить, не внесена ли новая ошибка.

                 28. 0  3Малая автоматизация тестирования 0

 2   0ш1.0
                                1Программа, свободная от ошибок, есть
                                1абстрактное теоретическое понятие.
                                                        1Д.Ван Тассел
 ш1.2

   Итак, вы разработали алгоритм, написали программу, и она уже вы-
даёт правильные ответы на нескольких  подготовленных  вами  тестах.
Если всё-таки  появятся  тесты,  на которых она перестанет работать
правильно, то придётся вносить изменения в программу,  добиваясь её
правильной работы  и  на этих тестах.  Но ведь после изменения кода
нужно опять всё перепроверять.
   Предлагается поступить  следующим образом [Долинский,2005,с.85]:
сразу после того,  как вы написали программу и приступили к её тес-
тированию (а ещё лучше -  1до того 0),  составить тесты и разместить их
в файлах 1.in, 2.in, 3.in и т.д., 1.out, 2.out, 3.out и т.д.
   Причём в  файлы  *.in  должно  попадать то,  что нужно вводить в
программу в тесте с соответствующим номером, а в файлы *.out - дан-
ные, которые программа должна выводить в случае правильной работы.
   После этого составляются два пакетных файла
 ш1.0

   1. All.bat

   @echo off
   cls
   for %%i in (1,2) do call test.bat %%i

   2. Test.bat

   @echo off
   2-02.exe <%1.in >output.txt
   fc output.txt %1.out
   pause

 ш1.2
   В файле All.bat в скобках указываются номера тестов,  которые Вы
подготовили. Он циклически запускает для всех этих номеров пакетный
файл Test.bat (передавая ему в качестве параметра номер теста).
   Файл Test.bat  запускает  разработанную  вами  программу  (здесь
2-02.exe) и перенаправляет ей ввод и вывод (предполагается,  что по
умолчанию она вводила с клавиатуры и выводила на экран). При этом в
качестве входного подаётся подготовленный вами очередной тест,  а в
качестве выходного - для сохранения вывода вашей программы  -  файл
output.txt.
   Его содержимое потом сверяется с подготовленными вами эталонными
ответами утилитой операционной системы fc (англ.  1File Compare 0).
   Пользуясь запуском All.bat,  в любой момент после очередной пос-
ледовательности изменений можно убедиться,  что программа  работает
на  всех  подготовленных  вами тестах,  или быстро обнаружить те из
них, на которых она  1ещё 0 или  1уже 0 не работает.
    3Замечание 0.
 ш1.1
   Есть по существу две вещи,  которые нужно автоматизировать и ко-
торые, по существу,  никто больше не автоматизировал,  но они самые
трудные:
   (а) генерация   _ 1контрольных примеров . 0 (англ.   1test cases 0),  потому
что их нужно как-то создавать,  а их может быть тысячи, десятки ты-
сяч, сотни тысяч;
   (б) проблема прогона этих десятков тысяч  тестов,  когда  кто-то
должен решать для каждого из них,  пройден он или нет,  и эта также
нужно автоматизировать с помощью  _ 1оракулов тестирования . 0 (англ.   1test
 1oracles 0).
 ш1.2

                      2Дополнительная информация 0
                   21. 0  3Сопровождение "старых" кодов 0
   Сопровождение "старых"  кодов  может  оказаться сложной задачей.
Если у вас есть исходные тексты, то это - всегда преимущество.
   Вы не слишком преуспеете в исправлении старого  кода,  если  для
этого у вас нет нужных средств. Решение таких проблем требует изоб-
ретательности и большого внимания.  Но вы можете сделать так, чтобы
ваша программа,  сейчас совершенно новая,  через какое-то время  не
создавала сложностей при её сопровождении.
   Как сделать так,  чтобы сопровождающий вашу программу специалист
и через десять лет не проклинал вас?
   Убедитесь, что  следующие вещи надёжно сохранены и при необходи-
мости будут доступны такому специалисту [Хэзфилд,Кирби,2001,с.163]:
 ш1.1
   (1)  1компьютер 0, работающий под управлением  1операционной системы 0;
   (2)  1компилятор 0, используемый первоначально (имейте доступ к ста-
рым компиляторам);
   (3) список  1опций 0 этого компилятора и его используемых ключей;
   (4)  1исходный код 0 вместе с заголовочными файлами;
   (5) вся доступная  1документация 0;
   (6)  1тестовые сценарии 0,  условия,  данные,  а также ожидаемые  1ре-
 1зультаты тестов 0.

 ш1.2
                    22. 0  3Об одном критерии качества 0
                            3документации 0
   Рассмотрим одну любопытную точку зрения ( 1метафору 0)  на  програм-
мный проект [Дзержинский,1980].
   Суть её в том,  что любая документация оказывалась бы  ненужной,
если  бы можно было сопровождать каждую поставку программы её авто-
ром. Другими словами,   _ 1идеальная  документация . 0  -  это  разработчик
программного продукта;  он в состоянии давать адресные и самые ква-
лифицированные  консультации,  конструктивно  отвечать  на  вопросы
пользователей.
   Итак, в этой точке зрения отражён взгляд на документацию как  на
заместителя разработчика при используемой программе.
   Отсюда следует и  _ 1критерий качества документации . 0:  она тем лучше,
чем точнее  имитирует непосредственное взаимодействие разработчиков
с пользователями.
   Взгляд на документацию как на заместителя разработчика позволяет
сделать явным разграничение между видами документов для разных  ва-
риантов использования:  в разных ситуациях требуются различные кон-
сультации и разъяснения.

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ 0

 ш1.0
                      1Какую бы программу Вы ни писали, любая ошибка,
                      1которая может в неё вкрасться, - вкрадется.
                                   1Следствие первого закона Чизхолма
 ш1.2

                         21. 0  3Ручная прокрутка
    21. 0 Осуществите  ручную прокрутку программы при заданных исходных
данных:
 ш1.0

   begin
      If b>c
        then h:=b else h:=c;
      If a<h
        then t:=a else t:=h;
      If a*a>b*b                  ║ (а) a=5, b=-2, c=0.4;
        then z:=a*a else z:=b*b;  ║
      n:=z-t; WriteLn(n)          ║ (б) a=1, b=0, c=0.
   end.

 ш1.2
    22. 0 Напишите программу,  которая  определяет  количество  гласных
букв в заданном слове ( _ 1словом . 0 назовём цепочку букв латинского алфа-
вита).  Осуществите ручную прокрутку программы при следующих исход-
ных данных:
 ш1.0

   (а) hklmnprstfg; (б) aabbcuuwyqoozp; (в) uyo.

 ш1.2
    23. 0 Выполните ручную прокрутку программы при исходных данных:
 ш1.0

   For i:=1 to length(s) do
     If s[i]='('
       then h:=h+1
       else k:=k+1;
   If k=h                  ║ (а) ((());
     then WriteLn('да ')   ║
     else WriteLn('нет')   ║ (б) (()()(().

 ш1.2
                           22. 3 Тестирование
    21. 0 [Майерс,1982]
   Составьте тесты  для программы,  которая по трём заданным числам
печатает сообщение о том,  является ли  треугольник  со  сторонами,
длины которых равны данным значениям,   1неравносторонним 0,   1равнобед-
 1ренным 0 или  1равносторонним 0.
    22. 0 ( 1Классическая задача. 0)
   Оцените Ваш выбор тестов для предыдущей  задачи,  попытавшись  с
его  помощью ответить на приведённые ниже вопросы.  За каждый ответ
"да" присуждается одно очко.
 ш1.1
   (1) Составили ли Вы тест, который представляет правильный нерав-
носторонний треугольник?  (Заметим, что ответ "да" на тесты со зна-
чениями 1, 2, 3, и 2, 5, 10  не обоснован, т.к. не существует треу-
гольников, имеющих такие стороны).
   (2) Составили ли Вы тест,  который представляет правильный  рав-
носторонний треугольник?
   (3) Составили ли Вы тест, который представляет правильный равно-
бедренный  треугольник?  (Тесты со значениями 2,  2,  4 принимать в
расчет не следует.)
   (4) Составили ли Вы,  по крайней мере, три теста, которые предс-
тавляют правильные равнобедренные треугольники,  полученные как пе-
рестановки двух равных сторон треугольника (например,  3,  3, 4; 3,
4, 3; 4, 3, 3)?
   (5) Составили ли Вы тест,  в котором длина одной из сторон треу-
гольника принимает нулевое значение?
   (6) Составили ли Вы тест,  в котором длина одной из сторон треу-
гольника принимает отрицательное значение?
   (7) Составили  ли  Вы  тест,  включающий три положительных целых
числа, сумма двух из которых равна третьему? (Другими словами, если
программа выдала сообщение о том,  что числа 1,  2,  3 представляют
собой стороны неравностороннего треугольника,  то  такая  программа
содержит ошибку.)
   (8) Составили ли Вы, по крайней мере, три теста с заданными зна-
чениями всех трех перестановок, в которых длина одной стороны равна
сумме длин двух других сторон (например, 1, 2, 3; 1, 3, 2; 3, 1,2)?
   (9) Составили ли Вы тест из трех целых положительных чисел,  та-
ких,  что сумма двух из них меньше третьего числа (т.е. 1, 2, 4 или
12, 15, 30)?
   (10) Составили ли Вы, по крайней мере, три теста из категории 9,
в которых Вами испытаны все три перестановки (например, 1, 2, 4; 1,
4, 2 и 4, 1, 2)?
   (11) Составили  ли  Вы тест,  в котором все стороны треугольника
имеют длину, равную нулю (0, 0, 0)?
   (12) Составили ли Вы, по крайней мере, один тест, содержащий не-
целые значения?
   (13) Составили ли Вы хотя бы один тест,  содержащий неправильное
число значений (например, два, а не три целых числа)?

 ш1.2
    3Замечание 0.
 ш1.1
   Профессиональные программисты набирают в среднем 7-8 очков из 13
возможных.

 ш1.2
    23. 0 Составьте тесты для программы,  которая по заданным  действи-
тельным числам x, y, z вычисляет значение функции
 ш1.0

    x 53 0+y 53 0+ 1max 0(x,y,z)
   ───────────────────.
    1max 0(x 52 0,y 52 0,z+1)+x 53 0-1

 ш1.2
    24. 0 Напишите программу, которая в данной матрице B[3,4] ищет сум-
му элементов строки, в которой располагается наименьший по значению
элемент.  Составьте всевозможные тесты  для  проверки  правильности
данной программы.
    25. 0 Напишите  программу,  которая  в заданной матрице C[5,5] ищет
элементы входящие в неё более одного раза. Составьте несколько тес-
тов для проверки правдоподобности данной программы.
    26. 0 Составьте тесты для программы,  которая вносит в данный текс-
товый файл, состоящий из списка фамилий, новую фамилию с сохранени-
ем упорядоченности.

                              2ЛИТЕРАТУРА 0
    1Безбородов Ю.М. 3   0Индивидуальная отладка программ.  - М.:  Наука,
1982. - 102 с.
    1Дзержинский Ф.Я. 0  Разработка программной документации: понятия и
принципы неформального программирования. - М.: ЦНИИатоминформ, 1980.
    1Йодан Э.   0Структурное программирование и  конструирование  прог-
рамм. - М.: Мир, 1979. - 416 с.
