    2ЛАБОРАТОРНАЯ РАБОТА 5 41 2.
    2ЛИТЕРАТУРНОЕ ПРОГРАММИРОВАНИЕ КАК ТЕХНОЛОГИЯ ПРОГРАММИРОВАНИЯ

 ш1.0
                  1... в  основе литературного программирования лежит
                  1идея,  что лучший способ передачи сообщения - сов-
                  1мещение формального и неформального способов.  Та-
                  1кой подход обеспечивает  естественную  основу  для
                  1переключения  между естественным языком - английс-
                  1ким - и формальным языком - Си,  Лиспом или  любым
                  1другим языком программирования - и их совмещения. 0
                                          1Д.Кнут 0 [ 1Сейбел,2011,с.499 0]
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - понятие " 1литературное программирование 0";
   - понятие " 1литературный код 0": "птичий язык", L 5a 0T 4E 0X.

    _ 1Уметь . 0:
   - использовать  литературное  программирование  для   реализации
простых программ.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                      3Литературное  0( 1грамотное 0)
                          3программирование

 ш1.0
               1- Я ищу всего лишь одно слово, - произнёс отец Браун.
               1- Слово, которого там нет. 0
                                      1Г.К.Честертон. Сломанная шпага
 ш1.2

    _ 1Литературное программирование . 0 - это способ программирования, при
котором код гораздо легче прочитать неспециалисту. В основе литера-
турного программирования лежит идея о том,  что лучший способ пере-
дачи сообщения - совмещение формального и неформального способов.
   Такой подход  обеспечивает  естественную основу для переключения
между естественным языком (русским, английским и т.п.) и формальным
языком (C, Lisp, ML, C# и т.п.) и их совмещения.
    _ 1Литературное . 0 ( _ 1грамотное . 0)  _ 1программирование . 0 (англ.   1literate prog-
 1ramming 0 - грамотное,  культурное программирование) - это концепция,
методология программирования и документирования программного кода.
   Термин и  саму концепцию разработал Д,Кнут (1981) при разработке
системы компьютерной вёрстки T 4E 0X. Он писал: "Давайте изменим тради-
ционные приоритеты в создании программ:  вместо представления о на-
шей  задаче  как о создании инструкций "Что делать?" для компьютера
сконцентрируемся на объяснении другим людям описаний нашего видения
того, что под управлением программы должен делать компьютер".
   Для понимания литературного программирования вспомним объяснения
в курсах программирования, написанные фразами на псевдокоде на "че-
ловеческом" языке. Они понятны, если код труден, и скрывают под од-
ной фразой-"оператором" множество других вложенных абстракций и/или
программного кода на непосредственно машинном языке.
   Литературное программирование в некотором смысле - это "програм-
мирование на псевдокоде" с помощью произвольных фраз, которые затем
раскрываются как макросы с помощью утилиты из исходного файла,  ко-
торый включает в себя одновременно документированные текстовые объ-
яснения концепций, сам код и псевдокод.
   Поговорим о  1сущности подхода 0.
    1Литературное программирование 0 - это метаподход к написанию прог-
рамм, т.е.  1парадигма 0, применимая к любой (процедурной, функциональ-
ной, декларативной, объектно-ориентированной) компьютерной програм-
ме на любом машинном языке.
   Литературное программирование является системой  1макросов 0, созда-
ваемая из фраз на естественном языке, которые превращаются в метая-
зык над конкретным языком программирования.  Пользование этими фра-
зами подобно объяснению алгоритмов на псевдокоде, но в случае лите-
ратурного  программирования они становятся точными "новыми операто-
рами" метаязыка. При этом:
 ш1.1
   (1) программа и документация более не пишутся как машинный код с
примечаниями.  Само конструирование программы идёт в порядке, опре-
деляемом логикой мысли (или объяснений), где макросы псевдокода иг-
рают роль абстракций (над кодом) для ясности мысли. Меняется карди-
нально порядок следования в программе, он не машинный, а тот, кото-
рого требует логика;
   (2) технически  литературное программирование делается с помощью
утилиты,  которая одной командой запускает препроцессор, раскрывает
все  макросы  и "запутывает" (англ.   1tangle 0) логическое изложение в
машинный код,  который потом можно компилировать или запускать  как
обычно.  Другая команда "сплетает" (от англ.  1weave 0) из этого общего
для программы и  объяснений  файла  отформатированную  документацию
(для печати, Интернета и т.д.).
   Другими словами,  программа мыслится  не  как  иерархия,  "свер-
ху вниз"  или "снизу вверх",  но как  _ 1взаимозависимая сеть концепций
(отсюда название первой системы  литературного  программирования  -
WEB) и создается как "поток мысли", проходящий по этой сети в связ-
ном, логичном виде, что внешне делает форму описания похожей на ли-
тературное эссе.  Программист,  таким образом, отказывается от при-
вязки к порядку, предписанному компьютеру.

 ш1.2
   Другими словами,  в основе литературного программирования  лежит
уверенность в  том,  что   _ 1поток  сознания . 0 всегда является наилучшим
принципом организации материала.
   Литературное программирование используется в следующих случаях:
 ш1.1
   (1) для выражения  _ 1концепции записи текста программы . 0,  превращаю-
щей программу в аналог литературного произведения, в котором "лите-
ратурно" записанные  1комментарии 0 имеют определённый приоритет  перед
собственно программным кодом;
   (2) для фиксирования "потока сознания" программиста при  органи-
зации программного кода: программист в определённом смысле разгова-
ривает сам с собой; в результате, читая год спустя программу, запи-
санную в  1литературном коде 0,  можно понять, о чём думал автор в про-
цессе её написания;
   (3) для эффективного ведения программной документации, обеспечи-
вающей связи между группами программистов.  Например, когда вы вво-
дите некоторые тонкие детали в свою программу,  литературное  прог-
раммирование показывает,  что перед нами не просто код, выполняющий
поставленные задачи,  - это ещё и документация.
   Вы говорите:  "Здесь был использован запрещённый приём, он рабо-
тает,  потому что..." - и расписываете  в  мельчайших  подробностях
причины и основные положения;
   (4) для написания статей и книг:  с одной стороны, такой код бу-
дет понятен трансляторам Haskell,  а с другой -  оформленные  таким
образом тексты можно сдавать в издательства для публикации.

 ш1.2
   Перечислим ряд ошибочных представлений о литературном программи-
ровании:
 ш1.1
   (1) система  литературного  программирования мало распространена
из-за непонимания: многие думают, что литературное программирование
- это  лишь  система  документирования  или  система форматирования
обычных комментариев. На самом деле, программа практически без ком-
ментариев  может  быть написана с применением подхода литературного
программирования,  равно как и многословные примечания сами по себе
не создают подхода литературного программирования;
   (2) самое частое непонимание относится к роли системы  макросов,
позволяющей строить произвольные системы абстракций над абстракция-
ми и к изменению порядка следования кусков от машинно-ориентирован-
ного  к  тому,  который  требует  мышление.  Так,  неверно  считать
литературным программированием использование  1систем  документирова-
 1ния интерфейсов 0 (JavaDoc, doxygen, DOC++, autoduck, POD).

 ш1.2
   Приведём  1инструменты литературного программирования 0:
 ш1.1
   (1) WEB - система программирования для языка Pascal;
   (2) CWEB - версия WEB, разработанная для документирования С, C++
и Java;
   (3) FWEB - система программирования для языка Fortran;
   (5) Rambutan - система программирования для языка Java;
   (4) pyWeb - система,  позволяющая создавать программы  на  любом
языке программирования и описывать их с помощью произвольного языка
разметки, например, HTML, LaTeX, reStructured Text.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 1 Литературный 0 (англ.  1literary 0); 1 грамотный 0 (англ.  1literate 0).
    22. 0 Литературное программирование не превращает сложную программу
в простую - это лишь один из способов программирования.
 ш1.2

                  3Литературный код на языке Haskell

 ш1.0
                       1... он говорил на пяти или шести языках, хотя
                       1в основном на жаргонных диалектах. 0
                                 1Г.К.Честертон. Грехи князя Сарадина
 ш1.2

   В языке Haskell литературное программирование выражается  в  ис-
пользовании  _ 1литературного кода . 0,  который характеризуется тем, что в
текстовом файле записан не исходный код программы,  а поясняющий её
текст, при этом сама программа определённым образом вставлена в та-
ком файле так,  что транслятор языка Haskell  "понимает",  что  это
именно код, который надо исполнять или компилировать.
   Человек, только начинающий программировать, думает в первую оче-
редь об исходном коде, а во вторую - о комментариях к нему.
   Литературный код меняет такой подход: в первую очередь коммента-
рии,  а  только во вторую - сами программы.  Поэтому в литературном
коде сам текст комментария записывается обычным образом,  а опреде-
ления программных сущностей выделяются специальным образом.
   Большинство трансляторов языка Haskell поддерживают два типа ли-
тературных кодов.  При любом из этих двух подходов файл,  в котором
хранится 2  0программа в литературном коде, имел расширение
 ш1.0

    2.lhs

 ш1.2
(вместо расширения .hs, которое обычно используется).
    21. 0 " _ 1Птичий язык . 0".
   В модулях, записанных на "птичьем языке", для выделения значимых
для трансляции строк используется символ " 1больше 0" (>).
   При этом принят следующий стиль, который называется  _ 1литературным
 _ 1стилем Р.Бёрда . 0: пустые строки между обычным текстом и текстом прог-
раммы, который 2  0начинается с символа ">",  1значимы 0. При их отсутствии
транслятор "не понимает", где начинается значимая часть текста.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
   Многие трансляторы языка Haskell выводят предупреждающие сообще-
ния, если встретят символ ">" внутри обычного текста.
    22. 0 L 5a 0T 4E 0X- _ 1код . 0.
   Для использования  этого вида литературного кода необходимо зак-
лючить все интересные для транслятора языка Haskell строки в  окру-
жение code; этого достаточно, чтобы транслятор "понимал", где нахо-
дится исходный код на языке Haskell,  и использовал для  построения
программ именно его.
                3Работа с демонстрационными примерами
   См. Пример 2, Пример 3.

                    3Комплексные числа 0  3в Haskell 2:
                           3модуль Complex

 ш1.0
            1Я давно чувствовал,  что талант к программированию в ос-
            1новном  заключается в способности легко переключиться от
            1микроскопического к макроскопическому взгляду  на  вещи,
            1т.е. без затруднений менять уровни абстракции. 0
                                                            1Д.Е.Кнут
 ш1.2

   Среди библиотечных модулей находится модуль Complex,  предназна-
ченный для работы с  1комплексными числами 0.
   Просматривая список экспорта данного модуля, мы встречаем список
стандартных функций для работы с  комплексными  числами  [Роганова,
2002,с.239-240].
                3Работа с демонстрационными примерами
   См. Пример 4.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

   Демонстрация использования литературного кода при
   написании текста программы.
   -----------------------------------------------------
   Функция, возвращающая абсолютное значение аргумента n

> absN:: Double -> Double
> absN n | n<0 = -n
>        | n>=0 = n 

   Функция, возвращающая абсолютное значение аргумента n,
   в записи которой используются альтернативы

> absN1:: Integer -> Integer
> absN1 n = if n<0
>             then -n
>             else n

   Функция, возвращающая наибольшее из двух чисел с исполь-
   зованием охранных выражений

> maxMN:: Double -> Double -> Double
> maxMN m n | m>n  = m
>           | m<=n = n

   Функция, определяющая наименьшее из двух чисел с выводом
   текстового результата на экран дисплея

> maxMN1:: Int -> Int -> String
> maxMN1 m n | m<n  = "Первое число меньше второго"
>            | m>n  = "Второе число меньше первого"
>            | True = "Значения равны"
 ш1.2

    2Пример 0  22.
 ш1.0

   Демонстрация использования литературного кода в LaTEX
   при написании текста программы
   ------------------------------
\begin{code}
module Main where

main :: IO ()
main = putStr "Здравствуй, мир!"
\end{code}
 ш1.2

    2Пример 3.
 ш1.0

      Решим следующую задачу: написать функцию, вычеркивающую
   из заданного слова word буквы, которые встречаются в нём n
   раз. Использование функционалов обязательно!
      Заметим, что  функционалов очень много,  поэтому первой
   проблемой является их выбор (понятно,  что функционалы map
   и filter придётся использовать).  Предположим вначале, что
   буквы в слове отсортированы; это легко сделать так (word -
   это входное слово):
      sort word
      Далее, вспомним функционал, позволяющий выполнить груп-
   пировку совпадающих букв в слове word:
      groupBy (==) $ sort word
      Теперь, например, получим для word="asaswasaszewz":
      "asaswasaszewz" -> ["aaaa","e","ssss","ww","zz"]
      Оставим только "нужные" буквы с помощью фильтрации:
      filter (\x -> length x==n)
             (groupBy (==) $ sort word)
      Например, для n=2 получим:
      ["aaaa","e","ssss","ww","zz"] -> ["ww","zz"]
      Удаляем лишние буквы:
      map (\y -> head y)
          (filter (\x -> length x==n)
                  (groupBy (==) $ sort word))
   и для сокращения воспользуемся замыканием:
      where z = map (\y -> head y)
                    (filter (\x -> length x==n)
                            (groupBy (==) $ sort word))
      Итак, ["ww","zz"] -> ['w','z'].
      Остаётся удалить "буквы", входящие в список z, из слова
   word.
      Заметим, что существует редко используемая функция (\\)
   из библиотеки List, которая осуществляет это удаление; од-
   нако предварительно приходится выполнить следующие  преоб-
   разования:
      ['w','z'] -> [['w','z'],['w','z']] -> ['w','z','w','z']
                -> "wzwz"
      Наконец, функция (\\) позволяет получить:
      (\\) "asaswasaszewz" "wzwz" -> "asasasase"
      Итоговый код:

>   import List (sort,groupBy,(\\))
>   import Random
>   bca word n = (\\) word (concat (replicate n z))
>           where z = map (\y -> head y)
>                         (filter (\x -> length x==n)
>                                 (groupBy (==) $ sort word))

      Остаётся провести примитивное тестирование:

>   test =   bca "aaaasssssweqew" 4 == "sssssweqew"
>         && bca "aaaasssssweqew" 5 == "aaaaweqew"
>         && bca "aaaasssssweqew" 2 == "aaaasssssq"
>         && bca "aaaasssssweqew" 1 == "aaaasssssweew"
>         && bca "aaaasssssweqew" 0 == "aaaasssssweqew"

      Выполним случайное тестирование;  для этого  произведём
   генерацию k случайных натуральных чисел от 97 до 122 (коды
   строчных латинских букв от 'a' до 'z'), а затем преобразу-
   ем  эти  числа в символы (201 - случайное натуральное чис-
   ло):

>   wrd k = map chr
>             (take k $ randomRs (97,122) (mkStdGen 201):: [Int])

>   test1 = (w,sort w,sort $ bca w 2,2)
>       where w = wrd 20  
 ш1.2

    2Пример 4. 0 ( 1Библиотека Complex 0)
 ш1.0
   ...

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                       1Чтоб хорошо писать - страдать надо, страдать 0!
                                                     1Ф.М.Достоевский
 ш1.2
                                ...
