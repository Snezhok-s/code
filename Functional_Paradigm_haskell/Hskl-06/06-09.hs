   -- Демонстрация моделирования функционалов
   --
   --  map, filter 
   -- 
   -- из библиотеки Prelude с помощью рекурсии
   -- ****************************************
   import Prelude hiding (map, filter)

   ----------------------------
   map:: (a -> b) -> [a] -> [b]
   map f []     = []
   map f (x:xs) = f x : map f xs
   -----------------------------
   map1:: (a -> b) -> [a] -> [b]
   map1 f []     = []
   map1 f (x:xs) = let y = f x
                       z = map1 f xs
                   in y : z
   -----------------------------
   map2:: (a -> b) -> [a] -> [b]
   map2 f xs = [f x | x <- xs]

   -- *******************************
   filter:: (a -> Bool) -> [a] -> [a]
   filter p []     = []
   filter p (x:xs) | p x  = x : filter p xs
                   | True = filter p xs

   -- ***************************
   -- Неудачные тестовые примеры:
   -------------------------------------------
   test1 =   map abs [-1,2,-3]      == [1,2,3]
          && map sqrt [0,4,9,16,25] == [0.0,2.0,3.0,4.0,5.0]
   ---------------------------------------------------------
   test2 =   map1 abs [-1,2,-3]      == [1,2,3]
          && map1 sqrt [0,4,9,16,25] == [0.0,2.0,3.0,4.0,5.0]
   ----------------------------------------------------------
   test3 =   map2 abs [-1,2,-3]      == [1,2,3]
          && map2 sqrt [0,4,9,16,25] == [0.0,2.0,3.0,4.0,5.0]
   ----------------------------------------------------------
   test4 =   filter null [[2],[3,3],[],[5,4],[],[2]]
                      == [          [],      []    ]
          && filter (elem 3) [[2],[3,3],[],[5,4,3],[],[3]]
                      ==     [    [3,3],   [5,4,3],   [3]]
          && filter (0>) [2,3,4,(-4),9,(-1)]       
                      == [       -4,    -1 ]
