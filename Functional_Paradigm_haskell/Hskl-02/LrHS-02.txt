    2ЛАБОРАТОРНАЯ РАБОТА 2.
    2ОСНОВНЫЕ ФУНКЦИИ БИБЛИОТЕКИ Prelude

 ш1.0
                             1Всё неизвестное принимается за великое.
                                                               1Тацит
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - иерархию классов типов модуля Prelude.h;
   - стандартные функции модуля Prelude.hs:  арифметические, триго-
нометрические,  логические, компараторы, распознаватели, преобразо-
ватели, приведения к типу;
   - операция  аппликации,  операция  нестрогой  аппликации функций
($);
   - операция композиции функций (.);
   - определение функций с помощью замыкания  (частных  определений
функций);
   - двухмерный синтаксис;
   - определение функций с помощью синтаксиса  7l 0-исчисления.

    _ 1Уметь . 0:
   - реализовывать на языке Haskell функции, содержащие стандартные
функции модуля Prelude.hs и не содержащие рекурсивных определений.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                   2Классы типов модуля Prelude.hs

 ш1.0
            1Что касается меня,  то я обнаружил, что когда хочу напи-
            1сать книгу на какую-нибудь тему,  то должен сначала впи-
            1тать  в  себя все подробности,  пока все остальные части
            1предмета не станут мне хорошо известны 0; 1 тогда в какой-то
            1день,  если  мне посчастливится,  я воспринимаю целое со
            1всеми его  частями,  должным  образом  взаимосвязанными.
            1После этого мне надо лишь записать то, что я увидел. 0
                                1Б.Рассел. История западной философии
 ш1.2

                         21. 3 Основные понятия
    2Определение 0 ( 1описательное 0) [Липовача,2012,с.51-52].
 ш1.1
    _ 1Класс типов . 0 - это интерфейс, определяющий некоторое поведение.
   Если некоторый тип является  _ 1экземпляром класса типов . 0 (см. ниже),
то он поддерживает и реализует поведение, описанное классом типов.
   Более точно,  _ 1класс типов определяет набор функций . 0, и если мы ре-
шаем сделать  некоторый пользовательский тип  1экземпляром класса ти-
 1пов 0, то должны  _явно . указать, что эти функции означают применительно
к нашему типу.

 ш1.2
    2Пример 0 [Липовача,2012,с.52].
 ш1.1
   Рассмотрим класс типов, определяющих равенство, и имеющий следу-
ющую  _ 1сигнатуру . 0:
 ш1.0

   (==) :: Eq a => a -> a -> Bool

 ш1.1
   Текст, расположенный перед символом => (т.е. "Eq a"), называется
 _ 1ограничением класса . 0.
   Мы можем прочитать предыдущее объявление типа следующим образом:
"функция сравнения на равенство принимает два значения  одинакового
типа и возвращает значение типа Bool. Тип этих двух значений должен
быть  1экземпляром класса 0 Eq" (это и есть ограничение класса).
   Класс типа Eq предоставляет интерфейс для проверки на равенство,
т.е. каждый тип, для значений которого операция проверки на равенс-
тво имеет смысл, должен быть экземпляром класса Eq.
   Кстати, все стандартные типы языка Haskell (кроме типов для  ор-
ганизации ввода/вывода) являются экземплярами класса Eq.

 ш1.2
   Создавая тип,  мы думаем о том,  какие поведения он поддерживает
(как он может действовать),  а затем решаем, экземпляры каких клас-
сов типов для него определить, основываясь на необходимом нам пове-
дении. Например,  если  разумно,  чтобы  значения  нашего типа были
сравниваемыми, мы определяем для нашего типа экземпляр класса Eq.
   Если мы видим, что наш тип является чем-то вроде  1функтора 0 (!?) -
определяем для него экземпляр класса Functor, и т. д.
                 22. 0  3Иерархия классов модуля Prelude
   Приведём  _ 1иерархию классов . 0,  определённых  в  стандартном  модуле
Prelude.hs (по [Душкин,2007,с.183,192-206]):
 ш1.0

              ┌──────┐
              │Enum a├────────────────────────── 4┐
              └──────┘                          │
   ┌──────┐   ┌───────┐   ┌────┐                │
   │ Eq a ├── 76 0│ Ord a ├── 76 0│Ix a│                │
   │      ├─ 4┐ 0 │       ├─ 4┐ 0 └────┘                │
   └──────┘ │ └───────┘ │                       │
   ┌──────┐ │ ┌───────┐ │ ┌──────┐         ┌──── 7^ 0─────┐
   │Show a│  4└ 76 0│ Num a │  4└ 76 0│Real a├──────── 76 0│Integral a│
   │      ├── 76 0│       ├── 76 0│      ├─────── 4┐ 0 └──────────┘
   └──────┘   └───┬───┘   └──────┘       │
                  │       ┌────────────┐ │ ┌──────────┐
                   4└ 0────── 76 0│Fractional a│  4└ 76 0│RealFrac a├─── 4┐
                          │            ├── 76 0│          │   │
                          └─────┬──────┘   └──────────┘   │
   ┌─────────┐  ┌─────────┐     │          ┌──────────┐   │
   │ Read a  │  │Bounded a│      4└ 0───────── 76 0│Floating a├─ 4┐ 0 │
   └─────────┘  └─────────┘                └──────────┘ │ │
   ┌─────────┐  ┌─────────┐                       ┌───── 7^ 0─ 7^ 0───┐
   │Functor f│  │ Monad m │                       │RealFloat a│
   └─────────┘  └─────────┘                       └───────────┘

 ш1.2
    2А. 0 Класс  2Eq 0 определяет класс типов,  над которыми определены от-
ношения равенства. Результат сравнения элементов таких типов предс-
тавляет собой значение булевского  типа  (True  -  "истина",  False
- "ложь").
    _ 1Операции класса . Eq a 0:
 ш1.1

   (==), (/=) :: a -> a -> Bool

 ш1.2
    2Б. 0 Класс  2Show 0 определяет шаблон для типов, элементы которых име-
ют графически представляемую форму.  Все элементы таких типов можно
передать в функцию show для вывода на  1экран 0 ( 1консоль 0).
    _ 1Операции класса . Show a 0:
 ш1.1

   show      :: a -> String
   showsPrec :: Int -> a -> ShowS
   showList  :: [a] -> ShowS

 ш1.2
    2В. 0 Значения  из экземпляров класса  2Enum 0 могут быть пронумерованы
с помощью целого числа (уникального для конкретного значения типа),
т.е. может быть определён порядок следования элементов такого типа.
    _ 1Операции класса . Enum a 0:
 ш1.1

   succ, pred     :: a -> a
   toEnum         :: Int -> a
   fromEnum       :: a -> Int
   enumFrom       :: a -> [a]              -- [n..]
   enumFromThen   :: a -> a -> [a]         -- [n,m..]
   enumFromTo     :: a -> a -> [a]         -- [n..m]
   enumFromThenTo :: a -> a -> a -> [a]    -- [n,n'..m]

 ш1.2
    2Г. 0 Класс  2Ord 0 определяет шаблон для типов, над экземплярами кото-
рых определён порядок следования.
    _ 1Операции класса . Ord a 0:
 ш1.1

   compare              :: a -> a -> Ordering
   (<), (<=), (>=), (>) :: a -> a -> Bool
   max, min             :: a -> a -> a

 ш1.2
   Здесь
 ш1.0

   Ordering  ═+ 0 {EQ,LT,GT},

 ш1.2
где EQ,  LT,  GT читаются соответственно: " 1равно 0", " 1меньше или рав-
 1но 0", " 1больше 0".
    2Д. 0 Класс  2Num 0 является родительским для  _ 1всех числовых классов . 0.
   Любой экземпляр этого класса должен поддерживать   1арифметические
 1операции 0 (сложение, вычитание и умножение).
    _ 1Операции класса . Num a 0:
 ш1.1

   (+), (-), (*) :: a -> a -> a
   negate        :: a -> a
   abs, signum   :: a -> a
   fromInteger   :: Integer -> a
   fromInt       :: Int -> a

 ш1.2
    2Е. 0 Класс  2Ix 0 определяет шаблон для типов,  значения которых могут
выступать в качестве индексов в массивах данных.
    _ 1Операции класса . Ix a 0:
 ш1.1

   range              :: (a,a) -> [a]
   index, unsafeIndex :: (a,a) -> a -> Int
   inRange            :: (a,a) -> a -> Bool
   rangeSize          :: (a,a) -> Int

 ш1.2
    2Ж. 0 Класс  2Real 0 определяет класс числовых типов,  элементы которых
могут быть представлены как отношения (например,  рациональные чис-
ла).
    _ 1Операции класса . Real a 0:
 ш1.1

   toRational :: a -> Rational

 ш1.2
    2З. 0 Класс  2Fractional 0 определяет шаблон для любого типа, элемента-
ми которого являются дробные (рациональные) числа.
   Все такие типы должны иметь определённую операцию деления.
   Кроме того,  каждый элемент должен иметь обратное значение отно-
сительно операции деления.
   Далее, все значения этого класса должны иметь возможность преоб-
разования из рациональных чисел.
    _ 1Операции класса . Fractional a 0:
 ш1.1

   (/)          :: a -> a -> a
   recip        :: a -> a
   fromRational :: Rational -> a
   fromDouble   :: Double -> a

 ш1.2
    2И. 0 Класс  2Integral 0 определяет шаблон для любого типа, который со-
держит в себе любые целые числовые элементы.
    _ 1Операции класса . Intgral a 0:
 ш1.1

   quot, rem, div, mod :: a -> a -> a
   quotRem, divMod     :: a -> a -> (a,a)
   toInteger           :: a -> Integer
   toInt               :: a -> Int

 ш1.2
    2К. 0 Класс   2RealFrac 0  объединяет  в  себе  свойства классов Real и
Fractional,  но при этом дополнительно включающий некоторые функции
для  работы с числами,  представленными в виде значений с плавающей
точкой, а именно функции для округления величин.
    _ 1Операции класса . RealFrac a 0:
 ш1.1

   properFraction  :: (Integral b) => a -> (b,a)
   truncate, round :: (Integral b) => a -> b
   ceiling, floor  :: (Integral b) => a -> b

 ш1.2
    2Л. 0 Класс  2Floating 0 определяет поведение всех числовых типов,  чьи
элементы являются числами с плавающей точкой.
    _ 1Операции класса . Floating a 0:
 ш1.1

   pi                  :: a
   exp, log, sqrt      :: a -> a
   (**), logBase       :: a -> a -> a
   sin, cos, tan       :: a -> a
   asin, acos, atan    :: a -> a
   sinh, cosh, tanh    :: a -> a
   asinh, acosh, atanh :: a -> a

 ш1.2
    2М. 0 Класс  2RealFloat 0 объединяет в себе свойства классов RealFrac и
Floating,  но при этом дополнительно описывающий некоторые  функции
для  работы с числами,  представленными в виде значений с плавающей
точкой.
    _ 1Операции класса . RealFloat a 0:
 ш1.1

   floatRadix       :: a -> Integer
   floatDigits      :: a -> Int
   floatRange       :: a -> (Int,Int)
   decodeFloat      :: a -> (Integer,Int)
   encodeFloat      :: Integer -> Int -> a
   exponent         :: a -> Int
   significand      :: a -> a
   scaleFloat       :: Int -> a -> a
   isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE
                    :: a -> Bool
   atan2            :: a -> a -> a

 ш1.2
    2Н. 0 Класс   2Read 0  представляет шаблон для типов,  элементы которых
имеют строковое представление.
    _ 1Операции класса . Read a 0:
 ш1.1

   read      :: Read a => String -> a,
   readsPrec :: Read a => Int -> ReadS a
   readList  :: Read a => ReadS [a]

 ш1.2
   Функция  2read 0 выполняет преобразование типа String к другому типу.
    2Примеры 0.
 ш1.0

   > read "12" :: Int      ║ > read "1.22" :: Double
   12                      ║ 1.22
                           ║
   > read "12" :: Double   ║
   12.0                    ║

 ш1.2
    2Пример 0.
 ш1.0

   main = print (rInt "12", rBool "True")
   --------------------------------------
   rInt :: String -> Int
   rInt = read
   -----------------------
   rBool :: String -> Bool
   rBool = read

   > main
   (12,True)

 ш1.2
    2О. 0 Экземпляры класса  2Bounded 0 представляют собой множества, огра-
ниченные сверху и снизу, т.е. это означает, что имеются минимальный
элемент множества и максимальный элемент множества.
   Однако само множество может быть и неупорядоченным, т.е. отноше-
ние порядка в нём может отсутствовать.
    _ 1Операции класса . Bounded a 0:
 ш1.1

   minBound, maxBound :: a

 ш1.2
    3Замечание 0 [Липовача,2012,с.59].
 ш1.1
   Иногда для типа данных должен быть определён экземпляр некоторо-
го  класса для того,  чтобы имелась возможность определить для него
экземпляр другого  класса.  Например,  для  определения  экземпляра
класса Ord необходимо иметь экземпляр класса Eq.
   Другими словами, наличие экземпляра класса Eq является  1предвари-
 1тельным 0  ( 1необходимым 0)   1условием 0  для определения экземпляра класса
Ord.
 ш1.2

                2Стандартные функции модуля Prelude.hs
   Приведём примитивы и встроенные функции языка  Haskell,  опреде-
лённые в стандартном модуле Prelude.hs.
    2Определение 0.
 ш1.1
    _ 1Примитив . 0 (от англ.  1primitive 0) - это функция, определение которой
встроено в интерпретатор (более точно, они содержатся в Prelude.hs).

 ш1.2
                      21.  3Арифметические функции
    21. 0 Функция, возвращающая модуль заданного числа:
 ш1.0

    2abs 0:: Num a => a -> a
    2abs 0  2n

   Например:

   > abs 4/6          > abs 0   > abs (-398)   > abs (-0.2345)
   0.66666666666667   0         398            0.2345

 ш1.2
    22. 0 Функция,  возвращающая 1, -1 или 0 в зависимости от того, яв-
ляется ли заданное число  1положительным 0,  1отрицательным 0 или  1нулём 0:
 ш1.0

           7( 0 1, если x>0;
   sgn(x) 7"* 0-1, если x<0;
           79 0 0, если x=0;

    2signumReal 0:: Num a => a -> a
    2signumReal 0  2n

   Например:

   > signumReal 23.4   > signumReal 0   > signumReal (-1111)
   1                   0                -1

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции:
 ш1.0

    2signum n

   Например:

   > signum 14/3   > signum 0   > signum (-0.32587)
   1.0             0            -1.0

 ш1.2
    23. 0 Функция, возвращающая квадратный корень из заданного числа:
 ш1.0

    2sqrt 0:: Floating a => a -> a
    2sqrt n

   Например:

   > sqrt 5           > sqrt 4.444       > sqrt 9   > sqrt 0
   2.23606797749979   2.10807969488822   3.0        0.0

 ш1.2
   Определена примитивом в трансляторе.
    24. 0 Функция, вычисляющая значение функции y= 1e 5x 0:
 ш1.0

    2exp 0:: Floating a => a -> a
    2exp n

   Например:

   > exp 0   > exp 1            > exp 2            > exp 2.7
   1.0       2.71828182845905   7.38905609893065   14.8797317248728

 ш1.2
   Определена примитивом в трансляторе.
    25. 0 Функция, возвращающая натуральный логарифм числа:
 ш1.0

    2log 0:: Floating a => a -> a
    2log n

   Например:

   > log 1   > log 2             > log 2.222
   0.0       0.693147180559945   0.798407691217438

 ш1.2
   Определена примитивом в трансляторе.
    26. 0 Функция,  возвращающая разность значений своих аргументов (из
второго вычитается первый):
 ш1.0

    2subtract 0:: Num a => a -> a -> a
    2subtract 0  2m n

   Например:

   > subtract 2 3   > subtract (-2) (-3)   > subtract 1.0 1.9202
   1                -1                     0.9202

 ш1.2
    27. 0 Функция,  выполняющая целочисленное деление своих целых аргу-
ментов и возвращающая результат этой операции:
 ш1.0

    2div 0:: Integral a => a -> a -> a
    2div m n

   Например:

   > div 2 3   > div 5 2   > div (-18) (-2)   > div 10 (-2)
   0           2           9                  -5

 ш1.2
   Определена примитивом в трансляторе.
    28. 0 Функция, возвращающая остаток от деления одного целочисленно-
го аргумента на другой:
 ш1.0

    2mod 0:: Integral a => a -> a -> a
    2mod m n

   Например:

   > mod 2 3   > mod 5 2   > mod (-18) (-2)   > mod 10 (-2)
   2           1           0                  0

   > mod 5 (-2)
   -1

 ш1.2
   Определена примитивом в трансляторе.
    29. 0 Функция,  возвращающая наибольший общий делитель  двух  целых
чисел:
 ш1.0

    2gcd 0:: Integral a => a -> a -> a
    2gcd m n

   Например:

   > gcd 23 20   > gcd 12 16   > gcd (-18) (-36)   > gcd 30 (-100)
   1             4             18                  10

   > gcd 50 0
   50

 ш1.2
    3Замечание 0.
 ш1.1
   Функция не определена, если оба аргумента равны нулю.

 ш1.2
    210. 0 Функция,  возвращающая  наименьшее  общее кратное двух целых
чисел:
 ш1.0

    2lcm 0:: Integral a => a -> a -> a
    2lcm m n

   Например:

   > lcm 23 20   > lcm 12 16   > lcm (-18) (-36)   > lcm 30 (-100)
   460           48            36                  300

   > lcm 0 35    > lcm 23 0
   0             0

 ш1.2
    211. 0 Функция, возвращающая числитель дробного числа:
 ш1.0

    2numerator 0:: Integral a => Ratio a -> a
    2numerator n

   Например:

   > numerator (2/3)   > numerator (-5/3)   > numerator (10/5)
   2                   -5                   2

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Ratio.

 ш1.2
    212. 0 Функция, возвращающая знаменатель дробного числа:
 ш1.0

    2denominator 0:: Integral a => Ratio a -> a
    2denominator n

   Например:

   > denominator (4/5)   > denominator (-8/3)   > denominator (8/4)
   5                     3                      1

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Ratio.

 ш1.2
    213. 0 Функция, сокращающая дробь и возвращающая дробь, которую уже
нельзя сократить:
 ш1.0

    2reduce 0:: Integral a => a -> a -> Ratio a
    2reduce m n

   Например:

   > reduce 10 5   > reduce (-25) 30   > reduce 36 (-12)
   2 % 1           -5 % 6              4 % -1

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    214. 0 Функция,  удаляющая дробную часть числа с плавающей точкой и
оставляющая только целую часть:
 ш1.0

    2truncate 0:: (RealFrac a, Integral b) => a -> b
    2truncate 0  2n

   Например:

   > truncate 234.56789   > truncate (-0.56789)   > truncate 12
   234                    0                       12

 ш1.2
   Определена примитивом в трансляторе.
    215. 0 Функция,  округляющая значение аргумента до ближайшего цело-
го:
 ш1.0

    2round 0:: (RealFrac a, Integral b) => a -> b
    2round 0  2n

   Например:

   > round 2.56789   > round (-123.46789)   > round (-123.54)
   3                 -123                   -124

 ш1.2
   Определена примитивом в трансляторе.
    216. 0 Функция,  возвращающая  наибольшее  целое число,  которое не
больше значения аргумента:
 ш1.0

    2floor 0:: (RealFrac a, Integral b) => a -> b
    2floor n

   Например:

   > floor 23.6207   > floor (-111.4321)   > floor 8253
   23                -112                  8253

 ш1.2
   Определена примитивом в трансляторе.
    217. 0 Функция,  возвращающая наименьшее целое  число,  которое  не
меньше значения аргумента:
 ш1.0

    2ceiling 0:: (RealFrac a, Integral b) => a -> b
    2ceiling 0  2n

   Например:

   > ceiling 23.6207   > ceiling (-111.4321)   > ceiling 8253
   24                  -111                    8253

 ш1.2
   Определена примитивом в трансляторе.
    218. 0 Функция для получения из действительного числа пары, состоя-
щей из его целой и дробной части:
 ш1.0

    2floatProperFraction 0:: (RealFrac a, Integral b) => a -> (b, a)
    2floatProperFraction n

   Например:

   > floatProperFraction 5.5   > floatProperFraction 27.28
   (5,0.5)                     (27,0.280001)

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции:
 ш1.0

    2properFraction n

   Например:

   > properFraction 5.5   > properFraction 27.28
   (5,0.5)                (27,0.280000000000001)

 ш1.2
                    22. 0  3Функции приведения к типу
    21. 0 Функция,  преобразующая число из типа Integer в целочисленный
тип из класса Num:
 ш1.0

    2fromInteger 0:: Num a => Integer -> a
    2fromInteger 0  2n

   Например:

   > fromInteger 1   > fromInteger 2147483649   > fromInteger (-12)
   1                 2147483649                 -12

 ш1.2
   Определена примитивом в трансляторе.
    22. 0 Функция,  преобразующая число типа Int в число целочисленного
типа из класса Num:
 ш1.0

    2fromInt 0:: Num a => Int -> a
    2fromInt n

   Например:

   > fromInt 2147483647
   2147483647

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    23. 0 Функция  для  приведения  числа типа Double к числу одинарной
точности (тип Float):
 ш1.0

    2doubleToFloat 0:: Double -> Float
    2doubleToFloat n

   Например:

   > doubleToFloat 5.99999   > doubleToFloat 5.999999
   5.99999                   6.0

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    24. 0 Функция для преобразования целого числа в рациональное.
   В качестве числителя берётся заданное число, в качестве знамена-
теля - 1:
 ш1.0

    2intToRatio 0:: Integral a => Int -> Ratio a
    2intToRatio n

   Например:

   > intToRatio 4
   4 % 1

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    25. 0 Функция  для  перевода  действительного  числа в рациональное
представление:
 ш1.0

    2realToFrac 0:: (Real a, Fractional b) => a -> b
    2realToFrac 0  2n

   Например:

   > realToFrac 12   > realToFrac (-123)   > realToFrac 1234567890
   12.0              -123.0                1.234567e+009

 ш1.2
    26. 0 Функция для преобразования рационального числа в действитель-
ное двойной точности (тип Double):
 ш1.0

    2rationalToDouble 0:: Rational -> Double
    2rationalToDouble n

 ш1.1
   Например:
 ш1.0

   > rationalToDouble 23/4   > rationalToDouble (-28)
   5.75                      -28.0

   > rationalToDouble 567/1024
   0.553711

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции:
 ш1.0

    2fromRational n

 ш1.1
   Например:
 ш1.0

  > fromRational 23/4  > fromRational (-28)  > fromRational 567/1024
  5.57                 -28                     0.5537109375

 ш1.2
    27. 0 Функция для преобразования рационального числа в действитель-
ное число одинарной точности (тип Float):
 ш1.0

    2rationalToFloat 0:: Rational -> Float
    2rationalToFloat n

   Например:

   > rationalToFloat 123456789/987654321
   0.125

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции:
 ш1.0

    2fromRational n

   Например:

   > fromRational 123456789/987654321
   0.124999998860938

 ш1.2
    28. 0 Функция для приведения числа типа Double к виду обычной  дро-
би:
 ш1.0

    2doubleToRatio 0:: Integral a => Double -> Ratio a
    2doubleToRatio n

   Например:

   > doubleToRatio 2.25   > doubleToRatio 0.005
   9 % 4                  5368709 % 1073741824

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    29. 0 Функция для преобразования числа типа  Double (действительно-
го) к рациональному:
 ш1.0

    2doubleToRational 0:: Double -> Rational
    2doubleToRational n

   Например:

   > doubleToRational 4   > doubleToRational 2.5
   4 % 1                  5 % 2

   > doubleToRational 3.1415
   6588203 % 2097152

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции таково:
 ш1.0

    2toRational n

   Например:

   > toRational 4   > toRational 2.5
   4 % 1            5 % 2

   > toRational 3.1415
   7074029114692207 % 2251799813685248

 ш1.2
    210. 0 Функция  для преобразования действительного числа типа Float
в рациональное:
 ш1.0

    2floatToRational 0:: Float -> Rational
    2floatToRational n

   Например:

   > floatToRational 12.345   > floatToRational (-5.0e-10)
   12944671 % 1048576         -9007199 % 18014398509481984

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) имя функции таково:
 ш1.0

    2toRational n

   Например:

   > toRational 12.345
   6949617174986097 % 562949953421312

   > toRational (-5.0e-10)
   (-4835703278458517) % 9671406556917033397649408

 ш1.2
    211. 0 Функция  для  получения реального дробного значения действи-
тельного числа:
 ш1.0

    2realFloatToRational 0:: RealFloat a => a -> Ratio Integer
    2realFloatToRational n

   Например:

   > realFloatToRational 2.25   > realFloatToRational (-0.00005)
   9 % 4                        -13743895 % 274877906944

 ш1.2
    3Замечание 0.
 ш1.1
   В версии интерпретатора Haskell (май,2006) данная функция не об-
наружена.

 ш1.2
    212. 0 Функция,  преобразующая заданное число в перечислимое.  Осу-
ществляет простое преобразование в целое число и обратно:
 ш1.0

    2fromIntegral 0:: (Integral a, Num b) => a -> b
    2fromIntegral n

   Например:

   > fromIntegral 12/3   > fromIntegral 12   > fromIntegral 23/4
   4.0                   12                  5.75

 ш1.2
                     23. 0  3Аппроксимирующая функция
    2Определение 0 [Математический,1995].
 ш1.1
    _ 1Аппроксимация . 0 (от лат.   1approximo 0 -  1приближаюсь 0) - замена  одних
математических  объектов другими,  в том или ином смысле близкими к
исходным.  Аппроксимация позволяет исследовать числовые характерис-
тики и качественные свойства объекта, сводя задачу к изучению более
простых или более удобных объектов (например, таких, характеристики
которых легко вычисляются или свойства которых уже известны).

 ш1.2
    21. 0 Функция для аппроксимации с заданной точностью  "вещественно-
го" числа рациональным числом:
 ш1.0

    2approxRational 0:: RealFrac a => a -> a -> Rational
    2approxRational 0  2m 0  2n

   Например:

   > approxRational 3.4564564 0.0000003
   1151 % 333

   > approxRational (55/3) 3
   16 % 1

 ш1.2
    3Замечание 0.
 ш1.1
    21. 0 Если значение точности равно положительному целому N,  то но-
вое дробное число,  сгенерированное числовыми функциями,  автомати-
чески округляется,  если для размещения меньшей из величин его чис-
лителя и знаменателя требуется больше, чем N слов памяти ( 1слово 0 со-
держит 16 битов).  Такое дробное число заменяется его  1аппроксимаци-
 1ей 0,  причём такой, которая требует для размещения наименьшей из ве-
личин числителя и знаменателя не более N слов.
    22. 0 В версии интерпретатора Haskell (май,2006) требуется  подклю-
чить модуль Ratio.

 ш1.2
                    24. 0  3Тригонометрические функции
    21. 0 Функция, возвращающая число  7p 0:
 ш1.0

    2pi

   Например:

   > pi
   3.14159265358979

 ш1.2
   Определена примитивом в трансляторе.
    22. 0 Тригонометрическая функция для  вычисления  значения  функции
y=sin(x). Аргумент задаётся в радианах:
 ш1.0

    2sin 0:: Floating a => a -> a
    2sin n

   Например:

   > sin 1.4          > sin (-1.4)        > sin 3.14
   0.98544972998846   -0.98544972998846   0.00159265291648683

   > sin (pi/2)       > sin (-(pi/2))     > sin pi
   1.0                -1.0                1.22460635382238e-016

   > sin 0
   0.0

 ш1.2
   Определена примитивом в трансляторе.
    23. 0 Тригонометрическая  функция  для  вычисления значения функции
y=cos(x). Аргумент задаётся в радианах:
 ш1.0

    2cos 0:: Floating a => a -> a
    2cos 0  2n

   Например:

   > cos 1.4              > cos (-1.4)           > cos 3.14
   0.169967142900241      0.169967142900241      -0.99999873172754

   > cos pi/2             > cos (-pi/2)          > cos pi
   6.12303176911189e-017  6.12303176911189e-017  -1.0

   > cos 0
   1.0

 ш1.2
   Определена примитивом в трансляторе.
    24. 0 Тригонометрическая функция для  вычисления  значения  функции
y=tg(x). Аргумент задаётся в радианах:
 ш1.0

    2tan 0:: Floating a => a -> a
    2tan n

   Например:

   > tan 0   > tan pi                 > tan pi/4     > tan (-pi/4)
   0.0       -1.22460635382238e-016   1.0            -1.0

 ш1.2
   Определена примитивом в трансляторе.
    25. 0 Тригонометрическая  функция  для  вычисления значения функции
y=arctg(x). Аргумент задается в радианах:
 ш1.0

    2atan 0:: Floating a => a -> a
    2atan n

   Например:

   > atan 0   > atan 1            > atan (-1)
   0.0        0.785398163397448   -0.785398163397448

 ш1.2
   Определена примитивом в трансляторе.
    26. 0 Тригонометрическая  функция  для  вычисления значения функции
y=arcsin(x). Аргумент задается в радианах:
 ш1.0

    2asin 0:: Floating a => a -> a
    2asin n

   Например:

   > asin 0   > asin 1
   0.0        1.5708

 ш1.2
   Определена примитивом в трансляторе.
    27. 0 Тригонометрическая  функция  для  вычисления значения функции
y=arccos(x). Аргумент задается в радианах:
 ш1.0

    2acos 0:: Floating a => a -> a
    2acos n

   Например:

   > acos 0   > acos 1
   1.5708     0.0

 ш1.2
   Определена примитивом в трансляторе.
                        25. 0  3Логическая функция
   Функция, возвращающая логическое отрицание от булева аргумента:
 ш1.0

    2not 0:: Bool -> Bool
    2not n

   Например:

   > not True  > not False  > not (5>4)&&(3<2)  > not True||False
   False       True         True                False

 ш1.2
                       26. 0  3Функции-компараторы
    21. 0 Функция,  возвращающая максимальное значение из двух заданных
значений  одного  типа,  которые  можно сравнивать в соответствии с
действием операции ">=":
 ш1.0

    2max 0:: Ord a => a -> a -> a
    2max m n

   Например:

   > max 3 5   > max (-2) (-7)   > max 12.345 12.34   > max 'a' 'b'
   5           -2                12.345               'b'

 ш1.2
    22. 0 Функция,  возвращающая минимальное значение из двух  заданных
значений  одного типа,  которые можно сравнивать с помощью операции
"<=":
 ш1.0

    2min 0:: Ord a => a -> a -> a
    2min 0  2m n

   Например:

   > min 3 5   > min (-2) (-7)   > min 12.345 12.34   > min 'a' 'b'
   3           -7                12.34                'a'

 ш1.2
                      27. 0  3Функции-распознаватели
    21. 0 Предикат, предназначенный для определения, является ли задан-
ное целое число нечётным:
 ш1.0

    2odd 0:: Integer -> Bool
    2odd 0  2n

   Например:

   > odd 3   > odd 4   > odd 256   > odd 32767
   True      False     False       True

 ш1.2
    22. 0 Предикат, предназначенный для определения, является ли задан-
ное целое число чётным.
 ш1.0

    2even 0:: Integer -> Bool
    2even 0  2n

   Например:

   > even 4   > even 3   > even 32767   > even 256
   True       False      False          True

 ш1.2
    23. 0 Предикат, предназначенный для определения, является ли задан-
ный символ цифрой или алфавитным символом из латинского алфавита:
 ш1.0

    2isAlphaNum 0:: Char -> Bool
    2isAlphaNum s

   Например:

   > isAlphaNum 'a'   > isAlphaNum '3'   > isAlphaNum '`'
   True               True               False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    24. 0 Предикат, предназначенный для определения, является ли задан-
ный символ алфавитным символом:
 ш1.0

    2isAlpha 0:: Char -> Bool
    2isAlpha s

   Например:

   > isAlpha 'a'   > isAlpha '3'
   True            False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    25. 0 Предикат, предназначенный для определения, является ли задан-
ный символ строчной буквой латинского алфавита:
 ш1.0

    2isLower 0:: Char -> Bool
    2isLower s

   Например:

   > isLower 'a'   > isLower 'A'   > isLower '5'
   True            False           False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    26. 0 Предикат, предназначенный для определения, является ли задан-
ный символ прописной буквой латинского алфавита:
 ш1.0

    2isUpper 0:: Char -> Bool
    2isUpper 0  2s

   Например:

   > isUpper 'E'   > isUpper 'e'
   True            False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    27. 0 Предикат, предназначенный для определения, является ли задан-
ный символ представлением десятичной цифры:
 ш1.0

    2isDigit 0:: Char -> Bool
    2isDigit s

   Например:

   > isDigit '1'   > isDigit 'a'
   True            False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    28. 0 Предикат, предназначенный для определения, является ли задан-
ный символ шестнадцатеричной цифрой:
 ш1.0

    2isHexDigit 0:: Char -> Bool
    2isHexDigit s

   Например:

   > isHexDigit 'f'   > isHexDigit 'g'   > isHexDigit '0'
   True               False              True

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    29. 0 Предикат, предназначенный для определения, является ли задан-
ный символ восьмеричной цифрой:
 ш1.0

    2isOctDigit 0:: Char -> Bool
    2isOctDigit s

   Например:

   > isOctDigit '7'   > isOctDigit '8'
   True               False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    210. 0 Предикат,  предназначенный для определения,  является ли за-
данный символ стандартным символом в кодировке ASCII:
 ш1.0

    2isAscii 0:: Char -> Bool
    2isAscii s

   Например:

   > isAscii 'a'   > isAscii '7'
   True            True

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    211. 0 Предикат,  предназначенный для определения,  является ли за-
данный символ печатаемым (код печатаемого символа больше кода  сим-
вола ' ' (пробел) и меньше кода символа '~'):
 ш1.0

    2isPrint 0:: Char -> Bool
    2isPrint s

   Например:

   > isPrint 'e'   > isPrint '\DEL'
   True            False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    212. 0 Предикат,  предназначенный для определения,  является ли за-
данный символ  1пробельным 0 ( 1пустым 0) (' ',  '\t',  '\n',  '\r',  '\f',
'\v'):
 ш1.0

    2isSpace 0:: Char -> Bool
    2isSpace 0  2s

   Например:

   > isSpace ' '   > isSpace '\n'   > isSpace '\DEL'
   True            True             False

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    213. 0 Предикат,  предназначенный для определения,  является ли за-
данный символ контрольным символом.
    _ 1Контрольным символом . 0 называется символ, код которого меньше кода
символа ' ' ( 1пробел 0),  а также символ '\DEL' ( 1удаление  предыдущего
 1символа 0):
 ш1.0

    2isControl 0:: Char -> Bool
    2isControl s

   Например:

   > isControl '\DEL'   > isControl ' '
   True                 True

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
                     28. 0  3Преобразователи символов
    21. 0 Функция, преобразующая алфавитный символ в верхнем регистре в
соответствующий строчный алфавитный символ.  Если функция применена
к аргументу, который не является строчным символом латинского алфа-
вита, то возвращается символ без изменений:
 ш1.0

    2toLower 0:: Char -> Char
    2toLower 0  2s

   Например:

   > toLower 'A'   > toLower 'b'   > toLower '3'
   'a'             'b'             '3'

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    22. 0 Функция,  преобразующая алфавитный символ в нижнем регистре в
соответствующий заглавный алфавитный символ. Если функция применена
к аргументу, который не является строчным символом латинского алфа-
вита, то возвращается символ без изменений:
 ш1.0

    2toUpper 0:: Char -> Char
    2toUpper 0  2s

   Например:

   > toUpper 'a'   > toUpper 'B'   > toUpper '3'
   'A'             'B'             '3'

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    23. 0 Функция, возвращающая символьное представление заданной "циф-
ры" 0,1,2,...,15:
 ш1.0

    2intToDigit 0:: Int -> Char
    2intToDigit n

   Например:

   > intToDigit 0   > intToDigit 10   > intToDigit 15
   '0'              'a'               'f'

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    24. 0 Функция,  преобразующая  символьное  представление десятичной
цифры в соответствующее целое значение:
 ш1.0

    2digitToInt 0:: Char -> Int
    2digitToInt 0  2c

   Например:

   > digitToInt '0'   > digitToInt '1'   > digitToInt '9'
   0                  1                  9

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    25. 0 Функция, возвращающая ASCII-код символа:
 ш1.0

    2ord 0:: Char -> Int
    2ord s

   Например:

   > ord '$'   > ord '\r'   > ord '\n'
   36          13           10

 ш1.2
   Определена примитивом в трансляторе.
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
    26. 0 Функция, возвращающая символ по указанному целому числу (коду
символа)  из диапазона от 0 до 255.  Если функция будет применена к
целому числу, находящемуся за пределами заданного интервала, то вы-
водится сообщение об ошибке:
 ш1.0

    2chr 0:: Int -> Char
    2chr 0  2n

   Например:

   > chr 10   > chr 13   > chr 36
   '\n'       '\r'       '$'

 ш1.2
    3Замечание 0.
 ш1.1
   В версии  интерпретатора Haskell (май,2006) требуется подключить
модуль Char.

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 1, Пример 2.

                 2Важнейшие операции функционального
                          2программирования
                 21. 0  3Операции аппликации  2( 3применения 2)
    2А. 0  _ 1Операция аппликации . 0.
   Традиционно в математике f(a) понимается как результат  примене-
ния функции f к значению аргумента a. На месте аргумента, или иначе
-  1операнда 0,  может стоять любое выражение, значение которого вычис-
ляется перед применением функции,  а на месте  1операции 0,  т.е. конс-
трукции,  которую можно применить к значению операнда - только  имя
некоторой функции. Налицо определённая асимметрия.
   С этого момента предлагается рассматривать  f(a)  как  результат
выполнения операции аппликации (применения) с аргументами f и a.
   Иными словами,
 ш1.0

   f(a)  756 0  1apply 0(f,a).

 ш1.2
   Обобщение состоит в том,  что операция 1 apply 0 вычисляет оба своих
аргумента и имеет следующий тип:
 ш1.0

   (a -> a) -> (a -> a).

   В языке Haskell операция аппликации записывается так:

    1apply 0(f,a)  756 0 f a

 ш1.2
    3Замечание 0 ( 1для знатоков каррирования 0).
 ш1.1
   Введённое обобщение  необходимо  для работы с объектами функцио-
нального типа,  которые неизбежно появляются при  1каррировании функ-
 1ций многих переменных 0.  Так, если рассматривать add как каррирован-
ную функцию, то для сложения двух чисел 3 и 5 необходимо записать
 ш1.0

    1apply 0 ( 1apply 0 ( 1add 0,3),5).

 ш1.1
   То, что 1 apply 0 вычисляет оба своих  аргумента,  даёт  возможность
вычислить значение данного выражения. Значением  1apply 0 ( 1add 0,3) будет
функция одного аргумента,  которая прибавляет к  нему  значение  3,
значением константы  является сама константа.  Далее может быть вы-
числено внешнее вхождение  1apply 0, что и даст результат - 8.
   Итак, введение операции  1apply 0 позволяет:
   (1) работать не только с вычисляемым операндом, но и вычисляемым
оператором;
   (2) применять функцию к аргументу.

 ш1.2
    2Б. 0  _ 1Операция 0  1нестрогой аппликации 0  1функций . 0 ($) определяется так:
 ш1.0

   f $ x = f x

 ш1.2
   Операция нестрогой аппликации является полным аналогом   1операции
 1композиции 0 (.),  однако  её  приоритет (равный 0)  1ниже  приоритетов
 1всех остальных операций 0, поэтому она применяет функцию к аргументам
и избавляет от необходимости использовать скобки.
   Например, можно
 ш1.1
   (1) вместо (f x)           писать f $ x;
   (2) вместо f (g (h x))     писать f $ g $ h x;
   (3) вместо (+) 2 ((*) 3 4) писать (+) 2 $ (*) 3 4.

 ш1.2
    2В. 0  _ 1Операция строгой аппликации . 0 ($!) будет рассмотрена далее.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 3.

 ш1.2
                   22. 0  3Операция композиции функций
    _ 1Операция 0  1композиции функций . 0 перешла в язык Haskell из  математи-
ки, где  1композиция функций 0 определяется как применение первой функ-
ции к результату,  который был возвращён  в  результате  вычисления
значения второй функции.
    _ 1Операция 0  1композиции функций . 0 (.) определяется так:
 ш1.0

   (.):: (b -> c) -> (a -> b) -> a -> c
   (f . g) x = f (g x)

 ш1.2
   Операцию композиции можно выразить с помощью  операции  апплика-
ции.
    2Примеры 0 ( 1вычислений с помощью операций аппликации и композиции 0).
 ш1.0

   Prelude> (sin . cos) 4 2     0 Prelude> sin $ cos 4
   -0.608083                 2  0 -0.608083

 ш1.2
    3Замечание 0 ( 1повторение 0).
 ш1.1
   Математическая нотация вызова функции традиционна полагала  зак-
лючение входных параметров функции в круглые скобки ().  Эту тради-
цию переняли практически все языки императивного  программирования.
Однако  в языках функционального программирования имя функции отде-
ляется от её параметров просто пробелом, и сами аргументы также от-
деляются друг от друга пробелами.

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 3.

               3Определение функций с помощью 0  3замыкания
                    2( 3частных определений 0  3функций 2)

 ш1.0
                            1Определение понятий - это начало ссылок.
                                                              1Сократ
 ш1.2

   Необходимость включения в парадигму функционального программиро-
вания понятия " 1локальная переменная 0" возникла в связи  с  тем,  что
иногда в  процессе вычисления производятся лишние действия.
   Например, для решения задачи может несколько  раз  потребоваться
значение  одной  и  той же функции,  вычисленной при одних и тех же
входных данных.  В этом случае экономию времени и ресурсов во время
вычислений позволят осуществить  1локальные функции 0,  которые в функ-
циональном программировании называются   _ 1замыканиями . 0  (или   _ 1частными
 _ 1определениями функций . 0).
   Существует два способа определения замыканий.
    21. 0  _ 1Префиксный способ . 0 подразумевает объявление локальной  функции
< 1Имя_функции 0> до её использования в выражении или функции:
 ш1.0

    2let 0 < 1Имя_функции 0> = < 1Выражение 0>│< 1Функция 0>< 1Аргументы 0>
    2in 0 < 1Выражение_1 0>│< 1Функция_1 0>< 1Аргументы 0>

 ш1.2
   В объектах < 1Выражение_1 0> или < 1Аргументы 0>  должно  присутствовать
имя локальной функции < 1Имя_функции 0>.
    22. 0  _ 1Постфиксный способ . 0 подразумевает объявление локальной функции
после её использования в некотором выражении:
 ш1.0

   < 1Функция 0>
        2where 0 < 1Имя_функции_1 0> = < 1Выражение_1 0>│< 1Функция_1 0>< 1Аргументы 0>
                            ...
             < 1Имя_функции_n 0> = < 1Выражение_n 0>│< 1Функция_n 0>< 1Аргументы 0>

 ш1.2
   После ключевого слова  2where 0 должны быть объявлены функции,  вхо-
дящие в тело функции < 1Функция 0>.
   Описанные способы  определения  локальных функций являются почти
эквивалентными. Тем не менее:
 ш1.1
   (1) префиксный способ позволяет возвращать значение
 ш1.0

   < 1Выражение_1 0>│< 1Функция_1 0>< 1Аргументы 0>

   Рассмотрим простейший пример: ║ Сравните с постфиксным способом:
                                 ║
   > (let x=y*y; y=5 in x/5)+5   ║ z=x/5
   10.0                          ║  where x = y*y
                                          y = 5

 ш1.1
   (2) постфиксный способ записи используется  чаще  в  выражениях,
имеющих охрану.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4, Пример 5, Пример 5 41 0.

 ш1.2
                        3Двухмерный синтаксис
    2Определение 0 ( 1содержательное 0).
 ш1.1
    _ 1Двухмерным синтаксисом . 0  называется  способ структурирования син-
таксических конструкций языка программирования,  требующий  опреде-
лённого расположения элементов конструкции на "плоскости".
   Двухмерный синтаксис позволяет не  перегружать  текст  программы
лишними символами, необходимыми для разделения выражений.

 ш1.2
   С учётом сказанного,  замыкания допустимо записывать,  например,
следующим образом [Душкин,2007,с.149-150]:
   (1) без использования двухмерного синтаксиса
 ш1.0

   fun a b c = x*y/z where { x = a+b; y = b+c; z = c+a }

   (2) с использованием двухмерного синтаксиса

   fun a b c = x*y/z
     where x = a+b
           y = b+c
           z = c+a

 ш1.2
   Смысл использования двухмерного синтаксиса состоит в следующем.
   Каждое выражение,  следующее после ключевого слова 2 where 0, должно
находиться на новой строке и при этом начинаться с одного и того же
знакоместа в самой строке,  т.е. все выражения должны располагаться
"в столбик" друг под другом, начинаясь на одной и той же позиции.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Всё сказанное касается и служебных слов 2 let 0,  2case 0, 2 do 0.
 ш1.2

                    3Определение функций с помощью
                       3синтаксиса 0  7l 3-исчисления

 ш1.0
             1Написано это не немцем. Букву "A", если вы заметили, он
             1пытался вывести готическим шрифтом,  а настоящий  немец
             1всегда пишет печатными буквами на латинский манер, поэ-
             1тому мы можем утверждать,  что писал не немец, а неуме-
             1лый и перестаравшийся имитатор. 0
                                1А. Конан Дойл. Этюд в багровых тонах
 ш1.2

   Парадигма функционального программирования основана на математи-
ческом формализме  7l 0-исчисления, используемом при описании функций.
   Напомним, что  в   7l 0-исчислении имеется математическая абстракция
для записи функций. Например:
 ш1.1
   (1)  7l 0x.x соответствует записи функции с аргументом x, определяе-
мой термом x;
   (2)  7l 0x.(x 52 0+5) соответствует записи функции с аргументом x, опре-
деляемой термом x;
   (3)  7l 0y. 7l 0x.(x+y) соответствует записи функции с аргументами  x  и
y, определяемой термом x+y;
   (4)  7l 0z. 7l 0y. 7l 0x.(x 52 0+y 52 0+z 52 0) соответствует записи функции с  аргумен-
тами x, y, z, определяемой термом x 52 0+y 52 0+z 52 0;
   (5)  7l 0x.(f(gx)) соответствует записи композиции функций f(g(x)).
 ш1.0

    4┌ 0─────────────────────────────────────── 4┐
   │Тип  7l 0-абстракции определяется с помощью│
   │команды HUGS 98 для определения типа:  │
   │> :t (\x y ... -> ...)                 │
    4└ 0─────────────────────────────────────── 4┘

 ш1.2
   На языке Haskell  7l 0-абстракция кодируется следующим образом:
 ш1.0

   ┌───────────────────────┬─────────────────────────┐
   │  3Символы  7l 3-исчисления 0  │   3Символы языка Haskell 0  │
   ╞═══════════════════════╪═════════════════════════╡
   │  7l 0 (читается " 1лямбда 0") │  \ (читается " 1лямбда 0")  │
   ├───────────────────────┼─────────────────────────┤
   │  2. 0 (читается " 1точка 0")  │ -> (читается " 1точка 0")   │
   └───────────────────────┴─────────────────────────┘

 ш1.2
    2Пример 0 ( 1сопоставления записи  7l 0- 1выражений 0).
 ш1.0

   ┌────────────────┬───────────────────┐
   │ 2   7l 3-исчисление 0  │    3Язык Haskell 0    │
   ╞════════════════╪═══════════════════╡
   │     7l 0x.(x+1)    │   \x -> x + 1     │
   ├────────────────┼───────────────────┤
   │   7l 0x. 7l 0y.(x+y)   │ \x -> \y -> x + y │
   ├────────────────┼───────────────────┤
   │    7l 0xy.(x+y)    │   \x y -> x + y   │
   ├────────────────┼───────────────────┤
   │ 7l 0z. 7l 0y. 7l 0x.(x+y+z)│\z y x -> x + y + z│
   └────────────────┴───────────────────┘

 ш1.2
   Итак, в языке Haskell функции можно определять так:
 ш1.0

   inc   = \x -> x + 1            ║ inc x   = x + 1
   add   = \x -> \y -> x + y      ║ add x y = x + y
   add   = \x y -> x + y          ║ add x   = \y -> x + y
   summa = \z y x -> (x + y + z)  ║ summa z = \y x -> x + y + z

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6.

 ш1.2
    3Замечание 0.
 ш1.1
   В языках семейства  C++0x  облегчается  написание  "одноразовых"
объектов-функций благодаря наличию " 1ламбда-функций 0",  которые можно
писать в контексте выражения (т.е.  в виде  функций-аргументов),  и
соответствующей генерации объектов-функций ("замыканий").

 ш1.2
                       3Понятие о выводе типов
   В языке Haskell реализован  _ 1механизм вывода типов . 0.
    2Определение 0 [Кирпичёв,2009,с.85].
 ш1.1
    _ 1Выводом типов . 0 называется  1автоматическое 0 полное или частичное вы-
числение типов некоторых выражений программы, основанное лишь на её
синтаксической структуре и производимое  1статически 0,  т.е. без необ-
ходимости запуска программы.

 ш1.2
   Алгоритм и  сама возможность вывода типов целиком зависят от ис-
пользуемой системы типов.
   Исходная информация для алгоритма вывода типов - сама программа,
способ присваивания типов литералам,  типы некоторых функций и зна-
чений,  а также правила типизации синтаксических конструкций  (типы
встроенных арифметических операций,  типы операций доступа к струк-
турам данных, взятые из определений этих структур, и т.п.). Правила
типизации синтаксических конструкций и литералов обычно фиксированы
в рамках одного алгоритма вывода типов.
   Наиболее известный,  простой  и  широко применяющийся в алгоритм
вывода типов - это  _ 1алгоритм Хиндли-Милнера . 0 (используемый,  в  част-
ности, в типизированном  7l 0-исчислении).
   Алгоритм, называемый  _ 1System . F 0,  является  основой  систем  типов
большинства современных функциональных языков программирования, та-
ких как OCaml и Haskell.
   Таким образом,  в большинстве случаев программисту не нужно явно
указывать тип выражений, т.к. этот тип будет автоматически вычислен
на основе контекста вычислительного процесса.
   Однако  1культура  программирования на языке Haskell 0 подразумевает
явное указание типа используемых функций.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ

 ш1.0
         1Программирование - одна из немногих областей,  где  сначала
         1учат писать, а только потом - читать. Это явная ошибка. Нет
         1ничего лучше, чем взять кусок скверного кода и попытаться в
         1нём  разобраться.  Очень поучительно. Я бы также постарался
         1познакомить учащихся с хорошо разработанными и хорошо спро-
         1ектированными  действующими продуктами,  чтобы они увидели,
         1как это выглядит не только снаружи, но и изнутри. 0
                         1Том Лав 0 ( 1один из авторов языка Objective-C 0)
 ш1.2

   См. Пример 1, Пример 2, Пример 3, Пример 4, Пример 5.

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                        1- Какое из двух чисел больше: 22/7 или 3.14 0?
                        1- Они равны.
                        1- Почему 0?!
                        1- Каждое из них равно 7 p 0.
                              1А.А.Власов. Из экзаменационных ответов
                                          1// Квант, 1986, 2, с.24
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                   21. 0  3Основные функции библиотеки
                               3Prelude
    21 4* 2. 0 Определите  1прагматику 0 следующей функции:
 ш1.0

   xxx _ 0 = 0
   xxx 0 _ = 0
   xxx x y = abs ((x `quot` gcd x y)*y)

 ш1.2
    22 4* 2. 0 Определите  1прагматику 0 следующей функции:
 ш1.0

   yyy x y | y==0 = error "Знаменатель дроби равен 0"
           | True = (x `quot` d) % (y `quot` d)
       where d = gcd x y

 ш1.2
    23 4* 2. 0 Напишите  функцию,  определяющую   1абсолютную 0 и  1относительную
 1погрешность 0 приближённого равенства
 ш1.0

   1.49 52.87 7~p 0.

 ш1.2
    3Замечание 0 (по [Жуков,2004,с.202]).
 ш1.1
   Во второй  трети XX века пол-литра водки стоил 2.87 руб,  а чет-
вертинка - 1.49 руб. Оказывается, что 1.49 52.87 0 даёт хорошее прибли-
жение для числа 7 p 0. (Это можно рассматривать как доказательство сба-
лансированности советской экономики того периода.)

 ш1.2
    24 4* 2. 0 Вычислите число 7 p 0 с помощью тригонометрических функций.
    25. 0 [Анисимов,Пупышев,2006,с.75,№8.8]
   Пусть f(a) - сумма цифр целого числа a.
   Для заданного x вычислите:
 ш1.0

   f(f(x+2)+f(2x)) 77 0f(x 52 0).

 ш1.2
   Например, если x=12, то результатом является 18.
    26. 0 ( 1Задача-шутка 0.)  Используя  некоторую  функцию  из библиотеки
Prelude обоснуйте название дня 22 июля - "день приближённого значе-
ния числа 7 p 0".
 ш1.1
    _ 1Указания . 0.
   1.  1Леонтий Магницкий  0писал (Арифметика, 1703): "В колесе же про-
порция Архимедова диаметра ко окружности как 7 к 22".
   2. 03.14  - на западе так предпочитают записывать дату:  вначале
номер месяца,  а затем - номер дня;  поэтому понятно,  почему "День
 7p 0", ежегодно отмечаемый Internet-сообществом - это 14 марта.

 ш1.2
    27 4* 2. 0 Напишите функцию для вычисления значения выражения
 ш1.0

       7|\\\\\\\\\\\\\\\\\\\\\\
      7/ 0       7|\\\\\\\\\\\\\\\\
     7/ 0       7/ 0       7|\\\\\\\\\\
    7? 01+2005 7? 01+2004 7? 01+2003 77 02001.

 ш1.2
    28. 0 Напишите функцию, вычисляющую наименьшее из двух целых чисел,
без использования функции if/then/else.
    _ 1Указание . 0.
 ш1.0
                                    7|\\\\\
              a+b   │a-b│   a+b    7? 0(a-b) 52
    1min 0(a,b) = ─── - ───── = ─── - ───────.
               2      2      2       2

 ш1.2
    29. 0 Напишите функции,  моделирующие операции сложения и умножения
над  1комплексными числами 0.
    210 5* 2. 0 Напишите функции,  моделирующие операции сложения и умноже-
ния над  1кватернионами 0.
    211 5* 2. 0 Напишите функцию,  моделирующую операции сложения и умноже-
ния над  1октонионами 0.
    212 5* 2. 0 [Анисимов,Пупышев,2006,с.13-14,№1.4])
   Будем изображать  следы  ног человека с помощью обычных символов
на клавиатуре следующим образом
 ш1.0

   .oooO  Oooo.
   (   )  (   )
    \ (    ) /
     \_)  (_/

 ш1.2
   Заполните следами N человек, идущих рядом  и проходящих путь в S
полушагов, S<12, N<12.
   Приведём пример для N=3 и S=5:
 ш1.0

   .oooO        .oooO        .oooO
   (   )        (   )        (   )
    \ (  Oooo.   \ (  Oooo.   \ (  Oooo.
     \_) (   )    \_) (   )    \_) (   )
   .oooO  ) /   .oooO  ) /   .oooO  ) /
   (   ) (_/    (   ) (_/    (   ) (_/
    \ (  Oooo.   \ (  Oooo.   \ (  Oooo.
     \_) (   )    \_) (   )    \_) (   )
   .oooO  ) /   .oooO  ) /   .oooO  ) /
   (   ) (_/    (   ) (_/    (   ) (_/
    \ (          \ (          \ (
     \_)          \_)          \_)

 ш1.2
   Начало движения всегда с левой ноги и снизу вверх.
   Шаги и расстояние между людьми всегда такие как в примере.

                            22. 3 Календарь

 ш1.0
               1- Что же такое Дьюрин день 0? 1 - поинтересовался Элронд.
               1- Как всем должно быть известно, мы называем Дьюриным
               1тот день, когда последняя осенняя луна и солнце стоят
               1в небе одновременно.  Боюсь,  что нам это  знание  не
               1очень-то поможет,  так как в наше время утрачено уме-
               1ние вычислять, когда же наступит такой день. 0
                              1Дж. Толкин. Хоббит, или Туда и Обратно
 ш1.2

    21 5* 2. 0 Напишите функцию, которая возвращает день недели по заданно-
му месяцу и по дню недели первого числа этого месяца.
   Например, день недели первого числа месяца - пятница, тогда шес-
тым днём этого месяца является  1среда 0.
    22. 0 (По [Ламуатье,1978,с.130])
   Напишите программу определения соответствующего  дня  недели  по
известным целым числам: J - число, М - месяц, А - год.
   Воспользуйтесь следующим алгоритмом ( 1М.Ленуар 0):
 ш1.1
   (1) вычислите величину N: если месяц - январь или  февраль висо-
косного года, то N=1; если месяц - январь или февраль обычного  го-
да, то N=2; в остальных случаях N=0.
   Чтобы узнать,  является ли год  1високосным 0,  "разложите" год A на
две части А 41 0 и А 42 0:  А 41 0 содержит две старшие цифры года,  А 42 0  -  две
младшие цифры  года.  Теперь если (А 42 0=0 и А 41 0 делится на 4) или если
(А 42 7- 00 и А 42 0 делится на 4), то год является високосным;
   (2) вычислите "код" дня С по формуле
 ш1.0

   С=[365.25 77 0А 42 0] + [30.56 77 0М] + J + N,

 ш1.2
где [] - функция, вычисляющая целую часть числа;
   (3) наконец, вычислите остаток S от деления С на 7:
 ш1.1
   - если S=0, то день -  1среда 0;
   - если S=1, то день -  1четверг 0;
   - если S=2, то день -  1пятница 0; ...;
   - если S=0, то день -  1вторник 0.

 ш1.2
    23 5* 0. (По [Абрамов,Гнездилова,Капустина,Селюн,1988,с.165,№828])
    1" _Вечный" 0  1календарь . 0. Даны натуральные числа  3d 0 - число,  3n 0 - месяц,
 3G 0 - год. Определите день недели, на который попадает эта дата.
   Воспользуйтесь следующим алгоритмом, пригодным для  номера года,
принадлежащего отрезку [1582,4902].
   Пусть  1воскресенье 0 имеет номер 0,  1понедельник 0 - 1,...,  1суббота 0 -6.
   Далее обозначим:
   d   - номер  _ 1дня . 0 в месяце (1,2,...),
    3m 0   - номер  _ 1месяца . 0 в году, нумерация начинается  с  марта  (март
ет номер 1,  апрель - 2,..., декабрь - 10, но январь и февраль счи-
таются месяцами с номерами 11 и 12, но  1предыдущего 0 года).
   Другими словами, 3 m 0 - приведённый номер месяца, а  3P 0 - приведённый
год, определяемые как
 ш1.0

        7( 3n 0-2, если n>2;         7( 3G 0, если n>2;
    3m 0  ═+ 0  7* 0                   3P 0  ═+ 0  7*
        79 3n 0+10, если n 7, 02;        79 3G 0-1, если n 7, 02;

 ш1.2
   с - число, образованное двумя старшими цифрами года (15,...,49),
т.е. полное число столетий, прошедших к заданному дню;
   y - число, образованное двумя младшими цифрами года (00,...,99),
т.е. номер года в текущем столетии.
   Теперь 3 P 0=100 77 0c+y.
   Например, для 12.04.1961: 3 d 0=12, 3 n 0=4 => 3 m 0=2, 3 P 0=1961 => 3 G 0=1961.
   Тогда искомый номер дня недели вычисляется как (w mod 7), где
 ш1.0

   w  ═+ 0  3d 0 + [(13 77 3m 0-1)/5] + y + [y/4] + [c/4] - 2 77 0c,

 ш1.2
где [] - функция, вычисляющая целую часть числа.
   Заметим, что w - количество дней, прошедших с некоторого извест-
ного дня, который пришёлся на воскресенье.
    3Замечание 0.
 ш1.1
   Для создания  более универсального календаря,  охватывающего все
годы, можно использовать непосредственный  подсчёт,  основанный  на
том, что 1 января 1 г. н.э. было  1понедельником 0.

 ш1.2
    24. 0 (По [Абрамов,Гнездилова,Капустина,Селюн,1988,с.165,№829])
   Вычислите количество пятниц, приходящихся на 13-е числа:
 ш1.1
   (а) XX столетия;
   (б) столетия с номером n, где n - натуральное число.

 ш1.2
    25. 0 [Гашков,2012,с.143]
   В какой день недели начнётся XXII век (это 1 января 2101 г.)?
    26. 0 ( 1Очень полезная задача 0.)
   Вы решили не выбрасывать старый настенный календарь.
   Через сколько лет он опять сможет вам пригодиться?
    27. 0 (По [Абрамов,Гнездилова,Капустина,Селюн,1988,с.165,№830])
   Даны натуральные числа a, b, c, обозначающие дату (число, месяц,
год) по  _ 1юлианскому календарю . 0.
   Получите эту дату по современному календарю.
   Расхождение между  датами определяется тем, что  в юлианском ка-
лендаре каждый год,  номер которого делится на 4, является високос-
ным, и из этого правила нет никаких исключений.
    28 5* 2. 0 (По [Гашков,2012,с.144])
   Напишите функцию для вычисления дня Пасхи по  1формуле Гаусса 0.
   В n-й год  от  Рождества Христова  _ 1западные церкви . 0 (!)  празднуют
Пасху или (22+d+e) марта, или (d+e-9) апреля.
   При этом:
 ш1.0

   если n=17**, то M=23, N=3;
   если n=18**, то M=23, N=4;
   если n=19**, то M=24, N=5;
   если n=20**, то M=24, N=6;
   если n=21**, то M=24, N=7;
   a=n  1mod 0 19, b=n  1mod 0 4, c=n  1mod 0 7, d=(19 77 0a + M)  1mod 0 30,
                                     e=(2 77 0b + 4 77 0c + 6 77 0d + N)  1mod 0 7.

 ш1.2
    29 5** 2. 0 Укажите назначение следующей функции:
 ш1.0

   f210:: String -> Int -> String
   f210 wd d | indexOf week wd<0 
                    = "Incorrect day of week"
             | True = week !! ((d - 1 + indexOf week wd) `rem` 7)
     where indexOf lst x = innerIndexOf lst x 0
           innerIndexOf lst x n | n >= length lst = -1
                                | lst !! n==x     = n
                                | True            = innerIndexOf
                                                        lst x (n+1)
           week = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]

   -- ***************************
   -- Неудачные тестовые примеры:
   -------------------------------
   test =   f210 "Fri" 27 == "Wed"
         && f210 "Mon" 22 == "Mon"
         && f210 "Wed" 30 == "Thu"
 ш1.2

                         2Контрольные задания
                        (24.02 1- 024.02.2021)
    21. 0 Напишите функции для вычисления (x,y 7е ═R 0):
 ш1.0

   (а) x├─ 76 1arcsin 0(x);  (в) x├─ 76 1arctg 0(x);   (д) 5* 0 x├─ 76 1arcsec 0(x);

   (б) x├─ 76 1arccos 0(x);  (г) x├─ 76 1arcctg 0(x);  (е) 5* 0 x├─ 76 1arccosec 0(x).

 ш1.2
    22. 0 Напишите функцию,  определяющую,  является ли заданное  нату-
ральное число 2  1простым числом 0.
    23. 0 Даны натуральные числа a, b, c, обозначающие дату (число, ме-
сяц, год) по  _ 1юлианскому календарю . 0.
   Получите эту дату по современному календарю.
   Расхождение между  датами определяется тем, что  в юлианском ка-
лендаре каждый год,  номер которого делится на 4, является високос-
ным, и из этого правила нет никаких исключений.
    24 4* 2. 0 ( 1Приёмный экзамен по  математике  на  физическом  факультете
 1МГУ, 1968 0.)
   Купили несколько одинаковых книг и одинаковых альбомов. За книги
заплатили 10 руб. 56 коп.
   Сколько купили книг,  если цена одной книги более чем на  1 руб.
превосходит цену альбома, а книг купили на 6 больше, чем альбомов?
 ш1.0
                                                            _Ответ .: 8

 ш1.2
    25 4* 2. 0 Студент за 5 лет учёбы сдал 31 экзамен.  В каждом  следующем
году он сдавал экзаменов больше,  чем в предыдущем.  На пятом курсе
экзаменов было втрое больше, чем на первом.
   Сколько экзаменов было на четвёртом курсе?

    _ 1Домашнее задание . 0:
 ш1.0

   №№  21 44,5,7,9 0 ;  22 42,6 0 ( 1всего 6 задач 0).

    _ 1Дополнительные задачи . 0: №№  21 412 0.
 ш1.2
