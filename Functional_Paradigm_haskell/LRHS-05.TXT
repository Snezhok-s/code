    2ЛАБОРАТОРНАЯ РАБОТА 5.
    2ПРОСТАЯ РЕКУРСИЯ НА СПИСКАХ

 ш1.0
                                          1Если тебе дадут линованную
                                          1бумагу, пиши поперек.
                                                  1Хуан Рамон Хименес
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - простые типы рекурсии на списках;
   - понятия:  1"as-образец",  0" 1именованный образец 0".

    _ 1Представлять . 0:
   - понятие " 1функциональные типы данных 0".

    _ 1Уметь . 0:
   - составлять  рекурсивные функции на языке Haskell для обработки
списков, пользуясь простыми типами рекурсии.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                        3Простые типы рекурсии
                             3на списках
   Ранее мы  рассмотрели  _ 1простые типы рекурсии . 0 на числовых структу-
рах, которые представляют собой инструмент и для обработки списков:
 1рекурсия по аргументам 0,  1рекурсия по значению 0 и  1рекурсия по значению
 1и по аргументам 0. Данные типы рекурсии применимы и к спискам.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1, Пример 2, Пример 3, Пример 4, Пример 5,
       Пример 6, Пример 7.

 ш1.2
                             3as-образцы
   В некоторых случаях удобно использовать форму образцов,  которая
называется " 1as-образцы 0".  Она применяется, если имя образца предпо-
лагается использовать в правой части уравнения, задающего функцию.
   Например, функция, дублирующая первый элемент списка, может быть
записана так:
 ш1.0

   f(x:xs) = x : x : xs

 ш1.2
   Напомним, что операция ":" является правоассоциативной.
   Обратите внимание на то, что выражение x:xs входит в это выраже-
ние дважды:  как образец ( 1as-pattern 0) в левой части определения и в
выражение в правой части.
   Для улучшения читабельности программы хотелось бы включать выра-
жение x:xs в подобное определение лишь один раз;  для этого исполь-
зуются  1именованные образцы 0.
                         3Именованные образцы
   В рекурсивных функциях в качестве аргумента  иногда  удобно  ис-
пользовать 1 именованный образец. 0
    2Определение 0 (по [Душкин,2007,с.124]).
 ш1.1
    _ 1Именованный образец . 0 - это образeц,  представляющий собой состав-
ной объект сложного типа, к которому имеется возможность обратиться
как к целому, так и к его частям:
 ш1.0

   < 1Имя_образца 0> 2@ 0< 1Составные_части_образца 0>

 ш1.2
    2Пример 0.
 ш1.1
   Функция, дублирующая первый элемент списка (x:xs), который обоз-
начен буквой l, имеет следующий вид:
 ш1.0

   headDupl l@(x:xs) = x:l

 ш1.2
    3Замечание 0 ( 1по использованию сложных типов рекурсии 0).
 ш1.1
   В функциональном языке программирования LISP  _ 1сложные типы рекур-
 _ 1сии . 0 представляли собой удобное средство не только  для  перемещения
по многоуровневому списку и конструированию нового списка, но и для
"погружения" на определённые уровни списков,  являющихся элементами
исходного.
   Жёсткая типизация языка Haskell,  следствием  которой  структура
многоуровневых списков стала ограниченной ( 1элементы многоуровневого
 1списка 0 -  1это списки одного уровня погружения 0),  привела к отказу от
использования сложных типов рекурсии на многоуровневых списках.
   Итак, данный вид рекурсии остаётся рассматривать только на  чис-
ловых структурах, либо строить собственный тип данных " 1Многоуровне-
 1вый список 0", подобный имеющемуся в языке LISP.
 ш1.2

                   3Представление о функциональных
                          3структурах данных

 ш1.0
                     1Очередь, серая, каменная, была несокрушима, как
                     1греческая фаланга. Каждый знал своё место и го-
                     1тов был умереть за свои маленькие права. 0
                           1И.Ильф, Е.Петров. Золотой телёнок, гл. 35
 ш1.2

    2Пример 0 [Марлоу,2014,с.235].
 ш1.1
   Реализуем структуру данных  " 1Очередь 0",  поддерживающую  операции
извлечения из  начала очереди и добавления в конец очереди со слож-
ностью 7 O 0(1).
   Известен следующий  способ представления очереди с такими свойс-
твами, идеей которого является хранение очереди в виде двух списков
xs  и ys так,  чтобы содержимое очереди совпадало со списком (xs ++
reverse ys).
   Теперь для того,  чтобы  _ 1извлечь . 0 элемент из  начала  очереди,  мы
извлекаем его из списка xs,  а для  _ 1добавления . 0 элемента в конец оче-
реди, мы помещаем его в начало списка ys.  При этом сложность обеих
операций есть  7O 0(1). Если же список xs оказывается пустым, а необхо-
димо извлечь элемент, то обращённый список (reverse ys) превращает-
ся в новый список xs.
   Итак, большую часть времени сложность извлечения элемента из на-
чала очереди есть  7O 0(1) и только изредка  7O 0(n).
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ

 ш1.0
           _ 1Как бы вы обучали разработчиков программного обеспечения . 0?
           1Сначала я сформировал бы из них группу  тестеров  и  стал
           1учить тестированию и чтению кода.
           1Программирование - одна из немногих областей, где сначала
           1учат   _писать .  и только потом -  _читать ..  Это явная ошибка.
           1Нет ничего лучше,  чем взять кусок скверного кода и попы-
           1таться ... разобраться. 0
                                                               1Т.Лав
 ш1.2

    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

    2Пример 6.
 ш1.0

 ш1.2

    2Пример 7.
 ш1.0

 ш1.2

    2Пример 8.
 ш1.0

 ш1.2

    2Пример 9.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                       1Ultra posse nemo obligatur 0 ( 1лат. 0).
                       1Никого нельзя обязать сверх его возможностей.
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                 21.  3Подсчёт элементов одноуровневого
                               3списка
    21 4* 2. 0 Напишите функцию,  вычисляющую произведение элементов число-
вого списка.
    22 4* 2. 0 Напишите функцию,  возвращающую список,  у  которого  первый
элемент является суммой квадратов, а второй ─ произведением квадра-
тов элементов числового списка.
    23. 0 Напишите функцию, вычисляющую произведение сумм положительных
и отрицательных элементов числового списка LST.
    24. 0 Напишите функцию, определяющую наибольшее из всевозможных по-
парных произведений элементов числового списка.
    25. 0 Напишите функцию,  возвращающую список пар,  первым элементом
которых является символ,  а вторым - количество вхождений его в за-
данный список символов.
    26 4* 2. 0 Даны две строки. Найдите  1расстояние Хэмминга 0 между ними.
 ш1.1
    _ 1Указание . 0.  _ 1Расстоянием  Хэмминга  между строками одинаковой длины
s 41 0  _ 1и . 0 s 42 0 называется количество несовпадающих символов  в  s 41 0  и  s 42 0,
стоящих на одинаковых позициях.

 ш1.2
    27 5* 2. 0 (По [Анисимов,Пупышев,2006,с.68,№7.60])
   Прочитайте строку и сообщите,  сколько  раз  встречается   1нужный
 1символ 0.
 ш1.1
    _ 1Указание . 0.  _ 1Нужным символом . 0 называется символ, который встречается
в заданной строке чаще других.

 ш1.2
                 22. 3 Свойства элемента одноуровневого
                               3списка
    21 4* 2. 0 Напишите функцию,  возвращающую элемент по номеру его распо-
ложения в списке.
    22 4* 2. 0 Напишите функцию,  возвращающую номер первого вхождения  за-
данного элемента в список.
    23. 0 Напишите функцию от трёх аргументов, включающую заданный эле-
мент в список на указанную позицию.
    24. 0 (По [Анисимов,Пупышев,2006,с.67-68,№7.57])
   Напишите программу,  запрашивающую число (не более 100 знаков) и
печатающую слово "Плавное", если число  1плавное 0, и "Нет" в противном
случае.
 ш1.1
    _ 1Указание . 0.  _ 1Плавным числом . 0 назовём десятичное натуральное число, у
которого любые две соседние цифры отличаются не более чем на едини-
цу. Однозначное число является плавным.

 ш1.2
                   23. 3 Трансформация одноуровневого
                               3списка
    21 4* 2. 0 Напишите  функцию,  увеличивающую  каждый  элемент числового
списка в k раз.
    22 4* 2. 0 Напишите функцию, обращающую элементы списка: первый элемент
становится последним,  второй - предпоследним и т.д.  до последнего
элемента, который становится первым.
    23 4* 2. 0 Напишите функцию, осуществляющую перестановку местами сосед-
них элементов списка. Например:
 ш1.0

   [1,2,3,4,5,6] -> [2,1,4,3,6,5],
   [1,2,3] 4       0 -> [2,1,3].

 ш1.2
    24 4* 2. 0 Напишите  функцию,  которая по двум заданным спискам выводит
единый список,  элементы которого образованы путём сложения элемен-
тов исходных списков, стоящих на одинаковых позициях.
    25 4* 2. 0 Напишите функцию, позволяющую приписывать один список к дру-
гому.
    26. 0 Напишите функцию,  обращающую каждый элемент списочной струк-
туры (т.е. списки), а также саму списочную структуру. Например:
 ш1.0

   [1,2,3,4,5,6,7,8,9] -> [9,8,7,6,5,4,3,2,1],
   [[1,2],[3],[4,5,6]] -> [[6,5,4],[3],[2,1]],
   [[[1,(-2),(-5),10]],[[(-3),(-2),1]]]
                       -> [[[1,(-2),(-3)]],[[10,(-5),(-2),1]]].

 ш1.2
    27. 0 Напишите функцию, которая удаляет из списка повторные вхожде-
ния элементов.
    28. 0 Укажите назначение следующих функций:
 ш1.0

   add1:: [Integer] -> Int -> [Integer]
   add1 lst k = take (k-1) lst ++ [1+lst !! (k-1)] 
                               ++ drop k lst
   -----------------------------------------
   add12:: [Integer] -> Int -> [Integer]
   add12 lst k | k==0 = lst
               | k==1 = 1+head lst : add1' (tail lst) (k-1)
               | True = head lst : add1' (tail lst) (k-1)
   ------------------------------------------------------
   prom1:: [Integer] -> Int -> [Integer]
   prom1 lst k = [lst !! (k-1),lst !! k]
   ------------------------------------------------           
   prom2 lst k | k==1 = [head lst, head $ tail lst]
               | True = prom' (tail lst) (k-1)
   -------------------------------------------
   -- Неудачные тестовые примеры:
   -----------------------------------------------
   test1 =   add1 [1,1,1,1,1,1] 6 == [1,1,1,1,1,2]
          && add1 [1,1,1,1,1,1] 1 == [2,1,1,1,1,1]
   test2 =   add2 [1,1,1,1,1,1] 3 == [1,1,2,1,1,1]
          && add2 [1] 1           == [2]
          && add2 [1,1,1,1,1,1] 1 == [2,1,1,1,1,1]
   test3 = prom1 [1,2,3,4,5,6]  5 == [5,6]
   test4 = prom2 [1,2,3,4,5,6]  2 == [2,3]

 ш1.2
    29. 0 Укажите назначение следующей функции:
 ш1.0

   swap lst i j
       | null lst || i==j || lst !! i==lst !! j
              = lst
       | i<j  = take i lst ++ [lst !! j] ++
                take (j-i-1) (drop (i+1) lst) ++
                [lst !! i] ++ drop (j+1) lst
       | True = swap lst j i
   ------------------------------
   -- Неудачные тестовые примеры:
   ---------------------------------------------------
   test =   swap [3,4, 5,6,7,89,0,12,34,55,666,78] 5 2
              == [3,4,89,6,7, 5,0,12,34,55,666,78]
         && swap [0,45,3,2,4] 2 4 == [0,45,4,2,3]
         && swap [4,6,7,5] 3 1    == [4,5,7,6]
         && swap [2,3,4,5,6,1,45,234,36] 5 2
                                  == [2,3,1,5,6,4,45,234,36]

 ш1.2
    210 5* 2. 0 Напишите функцию, моделирующую  1функционал 0 map.
    211 5* 2. 0 [Анисимов,Пупышев,2006,с.104,№10.42]
   Определим  2  0последовательность   _ 1строк Фибоначчи . 0  s 41 0,s 42 0,...,s 4k 0,...
следующим образом:
 ш1.0

   s 41 0='b', 4  0s 42 0='a', s 4k 0=s 4k-1 0s 4k-2 0, k>2.

 ш1.2
   Тогда начало последовательности строк Фибоначчи выглядит так:
 ш1.0

   b, a, ab, aba, abaab, abaababa, abaababaabaab.

 ш1.2
   Решите следующие задачи:
 ш1.1
   (а) Чему равна длина s 4k 0?
   (б) Дано k. Найдите s 4k 0.
   (в) Дана строка s. Проверьте, не является ли она  последователь-
ностью Фибоначчи.

 ш1.2
    212 5* 2. 0 [Анисимов,Пупышев,2006,с.146,№13.3]
   Можно ли разбить заданную строку на две части так, чтобы, перес-
тавив их местами, получить результирующую?
