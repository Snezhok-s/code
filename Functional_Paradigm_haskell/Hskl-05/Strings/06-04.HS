   -- Функция, проверяющая, можно ли из букв, входящих
   -- в слово WRD, составить слово WRD1. 
   -- Буквы можно переставлять, но каждую букву  можно
   -- использовать не более одного раза
   ---------------------------------------------
   kr2 wrd wrd1 = kr2_0 (kr2_1 wrd) (kr2_1 wrd1)
   -----------------------------------------------------------
   -- Функция, устанавливающая вхождение пар списка LST1 в LST
   -----------------------------------------------------------
   kr2_0:: [(Char,Int)] -> [(Char,Int)] -> Bool
   kr2_0 lst lst1 | null lst1 = True
                  | True      =    elem (head lst1) lst
                                && kr2_0 lst (tail lst1)
   -------------------------------------------------------------
   -- Функция, превращающая слово WRD в список, состоящий из пар
   -- <Буква слова, Количество вхождений буквы в слово>
   ----------------------------------------------------
   kr2_1:: String -> [(Char,Int)]
   kr2_1 wrd | null wrd = []
             | True     = (head wrd,kr2_2 (head wrd) wrd):
                          kr2_1 (tail wrd)
   --------------------------------------------------------
   -- Рекурсивная функция, вычисляющая количество вхождений 
   -- буквы X в слово WRD
   -----------------------------
   kr2_2:: Char -> String -> Int
   kr2_2 x wrd = length (filter (==x) wrd)
   --------------------------------------------------------
   -- Рекурсивная функция, вычисляющая количество вхождений 
   -- буквы X в слово WRD
   --------------------------------
   -- kr2_2 x wrd | null wrd    = 0
   --             | head wrd==x = 1 + kr2_2 x (tail wrd)
   --             | otherwise   = kr2_2 x (tail wrd)
   -------------------------------------------------
   -- Неудачные тестовые примеры:
   ------------------------------
   test =   kr2 "Листопад" "Лисп"
         && kr2 "СТРОКИ" "КРОТ"
         && not (kr2 "Строки" "Крот")
         && not (kr2 "Лиса" "Сила")
