   -- Демонстрация функции, "переворачивающей" список
   -- ***********************************************

   -- (1) с использованием охран
   --     (рекурсия по аргументам)
   -------------------------------
   reverse':: [a] -> [a]
   reverse' lst | null lst = lst
                | True     = reverse' (tail lst) ++ [head lst]

   -- **********************************************
   -- (2) с использованием сопоставления с образцом
   --     (рекурсия по аргументам)
   -------------------------------
   rLst:: [a] -> [a]
   rLst []     = []
   rLst (x:xs) = rLst xs ++ [x]

   -- *****************************************
   -- (3) с использованием именованных образцов
   --     (рекурсия по аргументам)
   -------------------------------
   rLst':: [a] -> [a]
   rLst' []           = []
   rLst' l@(m@x:f@xs) = rLst' f ++ [m]

   -- **************************
   -- (4) с использованием охран
   --     (рекурсия по значению)
   -----------------------------
   reverse'':: [a] -> [a]
   reverse'' lst = rev'' lst []
        where rev''   []   res = res
              rev'' (x:xs) res = rev'' xs (x : res)

   -- **********************************
   -- (5) с использованием "продолжения"
   --     (CPS-стиль, рекурсия по значению)
   ----------------------------------------
   reverse''':: [a] -> [a]
   reverse''' lst = rev lst id
        where rev   []   f = f []
              rev (x:xs) f = rev xs ((x :) . f)

   -- ***************************
   -- Неудачные тестовые примеры:
   --------------------------------------------------
   test1 =   (reverse' [1,2,3]   :: [Int]) == [3,2,1]
          && (reverse' []        :: [Int]) == []
          && (reverse' [1..2500] :: [Int]) == reverse [1..2500]
   ------------------------------------------------------------
   test2 =   (rLst []          :: [Int]) == []
          && (rLst [1]         :: [Int]) == [1]
          && (rLst [1,2,3]     :: [Int]) == [3,2,1]
          && (rLst [1..32767]  :: [Int]) == reverse [1..32767]
   -----------------------------------------------------------
   test3 =   (rLst' []         :: [Int]) == []
          && (rLst' [1]        :: [Int]) == [1]
          && (rLst' [1,2,3]    :: [Int]) == [3,2,1]
          && (rLst' [1..32767] :: [Int]) == reverse [1..32767]
   -----------------------------------------------------------
   test4 = length $ reverse    [1..29000] 
   test5 = length $ reverse'   [1.. 3000] 
   test6 = length $ reverse''  [1..55000]
   test7 = length $ reverse''' [1..48000]
